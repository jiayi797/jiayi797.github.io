<!doctype html>




<html class="theme-next pisces" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="true" />







  <meta name="baidu-site-verification" content="q1zwhBKKPA" />







  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="DP," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="理解动态规划引入例题：triangle 给一个三角形，找到从上到下最短的路径： 123456[     [2],    [3,4],   [6,5,7],  [4,1,8,3]]  最短路径是11 (i.e., 2 + 3 + 5 + 1 &#x3D; 11). n &#x3D; 三角形高度 我们用下面几种方法来思考这个题。">
<meta property="og:type" content="article">
<meta property="og:title" content="算法-DP">
<meta property="og:url" content="http://jiayi797.github.io/about/2017/11/17/%E7%AE%97%E6%B3%95-DP/index.html">
<meta property="og:site_name" content="甲乙小朋友的房子">
<meta property="og:description" content="理解动态规划引入例题：triangle 给一个三角形，找到从上到下最短的路径： 123456[     [2],    [3,4],   [6,5,7],  [4,1,8,3]]  最短路径是11 (i.e., 2 + 3 + 5 + 1 &#x3D; 11). n &#x3D; 三角形高度 我们用下面几种方法来思考这个题。">
<meta property="og:locale">
<meta property="og:image" content="http://jiayi797.oss-cn-beijing.aliyuncs.com/2018-01-16-17-16-47.png">
<meta property="og:image" content="https://leetcode.com/static/images/problemset/ring.jpg">
<meta property="og:image" content="http://jiayi797.oss-cn-beijing.aliyuncs.com/2018-03-08-13-48-34.png">
<meta property="og:image" content="http://jiayi797.oss-cn-beijing.aliyuncs.com/2018-03-17-15-50-34.png">
<meta property="og:image" content="http://jiayi797.oss-cn-beijing.aliyuncs.com/2018-03-17-16-39-22.png">
<meta property="article:published_time" content="2017-11-17T12:26:50.000Z">
<meta property="article:modified_time" content="2018-12-17T07:42:04.000Z">
<meta property="article:author" content="jiayi797">
<meta property="article:tag" content="DP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://jiayi797.oss-cn-beijing.aliyuncs.com/2018-01-16-17-16-47.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: false,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://jiayi797.github.io/about/2017/11/17/算法-DP/"/>





  <title>算法-DP | 甲乙小朋友的房子</title>
<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-110169171-1', 'auto');
  ga('send', 'pageview');
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?9856596edaab494b299151eb0e9bb214";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>











  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">甲乙小朋友的房子</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            时光机
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            琐碎
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2017/11/17/%E7%AE%97%E6%B3%95-DP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">算法-DP</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-17T12:26:50+00:00">
                2017-11-17
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-12-17T07:42:04+00:00">
                2018-12-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2017/11/17/%E7%AE%97%E6%B3%95-DP/#SOHUCS" itemprop="discussionUrl">
                  <span id="changyan_count_unit" class="post-comments-count hc-comment-count" data-xid="2017/11/17/算法-DP/" itemprop="commentsCount"></span>
                </a>
              
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="理解动态规划"><a href="#理解动态规划" class="headerlink" title="理解动态规划"></a>理解动态规划</h1><p>引入例题：<strong>triangle</strong></p>
<p>给一个三角形，找到从上到下最短的路径：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>最短路径是<code>11</code> (i.e., 2 + 3 + 5 + 1 = 11).</p>
<p>n = 三角形高度</p>
<p>我们用下面几种方法来思考这个题。</p>
<span id="more"></span>

<h2 id="方法1，DFS遍历"><a href="#方法1，DFS遍历" class="headerlink" title="方法1，DFS遍历"></a>方法1，DFS遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="keyword">int</span>[][] triangle)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> best = Integer.MAX_VALUE;</span><br><span class="line">  n = triangle.length;</span><br><span class="line">  dfs(triangle,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> best;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sum = root -&gt; x,y ,不包含x,y的路径和</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> vid <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] triangle,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>( x == n )&#123;</span><br><span class="line">    best = Math.max(best,sum);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs( triangle, x+<span class="number">1</span>, y, sum + triangle[x][y] );</span><br><span class="line">  dfs( triangle , x+<span class="number">1</span>, y+<span class="number">1</span>, sum + triangle[x][y] );</span><br><span class="line">  <span class="comment">/**坐标关系</span></span><br><span class="line"><span class="comment">   [2]   -&gt;    [0,0]</span></span><br><span class="line"><span class="comment">   [3,4]  -&gt;   [1,0],[1,1]</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度：$O(2^n)$</p>
<h2 id="方法2，分治法"><a href="#方法2，分治法" class="headerlink" title="方法2，分治法"></a>方法2，分治法</h2><p>没有best全局变量，更好一些。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divideConquer</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>( x == n )&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> A[x][y] + Math.min(</span><br><span class="line">    divideConquer(x+<span class="number">1</span>,y),</span><br><span class="line">  	divideConquer(x+<span class="number">1</span>,y+<span class="number">1</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">divideConquer(<span class="number">0</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>我们分析一下这个分治的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**分治定义</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[x,y]表示从x,y出发，到底层的最短距离</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  [x,y]</span></span><br><span class="line"><span class="comment">    ↓    ↘</span></span><br><span class="line"><span class="comment">[x+1,y] [x+1,y+1]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">从[x,y]出发，有两条路：[x+1,y]和[x+1,y+1]，这其实是两个子问题</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">而[x,y] = Math.min( [x+1,y],[x+1,y+1] ) + A[x,y]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>

<p>复杂度：$2^n$</p>
<h2 id="方法3，记忆化搜索"><a href="#方法3，记忆化搜索" class="headerlink" title="方法3，记忆化搜索"></a>方法3，记忆化搜索</h2><p>我们先回头看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  [x,y]</span></span><br><span class="line"><span class="comment">    ↓    ↘</span></span><br><span class="line"><span class="comment">[x+1,y] [x+1,y+1]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   ↓      ↘ ↓       ↘</span></span><br><span class="line"><span class="comment">[x+2,y] [x+2,y+1] [x+2,y+2]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>

<p>我们发现[x+2,y+1]被调用了两次！</p>
<p>就可以用一张哈希表来存储曾经计算过的[x,y]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divideConquer</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x == n)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果之前计算过，就直接返回</span></span><br><span class="line">  <span class="keyword">if</span>( hash[x][y] != Integer.MAX_VALUE )&#123;</span><br><span class="line">    <span class="keyword">return</span> hash[x][y];</span><br><span class="line">  &#125;</span><br><span class="line">  hash[x][y] =  A[x][y] + Math.min(</span><br><span class="line">    divideConquer(x+<span class="number">1</span>,y),</span><br><span class="line">  	divideConquer(x+<span class="number">1</span>,y+<span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> hash[x][y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initialize: hash[*][*] = Integer.MAX_VALUE;</span><br><span class="line">answser: divideConqure(<span class="number">0</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>复杂度:$n^2$</p>
<p>解决了重复计算的问题。</p>
<p>记忆化搜索是一种lazy loading模式，需要的时候再去算，算完了存下来。属于自顶向下的计算。</p>
<h2 id="方法4，多重循环"><a href="#方法4，多重循环" class="headerlink" title="方法4，多重循环"></a>方法4，多重循环</h2><p>这是一种很勤劳的模式。就是提前算好所需要的一切，然后再返回。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span>,<span class="number">3</span></span><br><span class="line"><span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>有两种方式，一种是自顶向下，一种是自底向上。</p>
<h3 id="自顶向下"><a href="#自顶向下" class="headerlink" title="自顶向下"></a>自顶向下</h3><p>我们先看一下自顶向下。</p>
<p>我们先计算从1到2、3的最短路径，然后计算从1到4/5/6的最短路径。最后从4/5/6中挑一个最小的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">f[i][j]表示从顶出发，走到i,j的最小路径长度</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = A[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"><span class="comment">//初始化三角形的左边和右边</span></span><br><span class="line"><span class="comment">//最左、右边的所有点，从1出发只有一条路径！</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++i)&#123;</span><br><span class="line">f[i][<span class="number">0</span>] = f[i-<span class="number">1</span>][<span class="number">0</span>] + A[i][<span class="number">0</span>];</span><br><span class="line">f[i][i] = f[i-<span class="number">1</span>][i-<span class="number">1</span>] + A[i][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自顶向下</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++i )&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; i ; ++j )&#123;</span><br><span class="line">	f[i][j] = Math.min(f[i-<span class="number">1</span>][j],f[i-<span class="number">1</span>][j-<span class="number">1</span>]) + A[i][j];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Math.min(f[n-<span class="number">1</span>][<span class="number">0</span>],f[n-<span class="number">1</span>][<span class="number">1</span>],...);</span><br></pre></td></tr></table></figure>

<h3 id="自底向上"><a href="#自底向上" class="headerlink" title="自底向上"></a>自底向上</h3><p>接下来看一下自底向上的方式。</p>
<p>我们想要计算1到最底端的最小距离，那就需要知道2和3的。那么就要需要知道4,5,6的。那我们先从4,5,6计算起。属于自底向上的计算。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">A[][]</span><br><span class="line"></span><br><span class="line"><span class="comment">//状态定义</span></span><br><span class="line">f[i][j]表示从i,j出发走到最后一层的最小路径长度</span><br><span class="line"><span class="comment">//初始化,终点先有值</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++i )&#123;</span><br><span class="line">	f[n-<span class="number">1</span>][i] = A[n-<span class="number">1</span>][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//循环求解</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span> ; --i )&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= i ; ++j)&#123;</span><br><span class="line">	f[i][j] = Math.min(f[i+<span class="number">1</span>][j],f[i+<span class="number">1</span>][j+<span class="number">1</span>]) + A[i][j];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> f[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>



<h1 id="什么时候用DP"><a href="#什么时候用DP" class="headerlink" title="什么时候用DP"></a>什么时候用DP</h1><p>三个条件满足其一即<strong>有可能</strong>是要用DP：</p>
<ul>
<li>求极值</li>
<li>判断是否可行</li>
<li>统计方案个数</li>
<li>擅长将$2^n-&gt;n^2$</li>
</ul>
<h1 id="什么时候不用DP"><a href="#什么时候不用DP" class="headerlink" title="什么时候不用DP"></a>什么时候不用DP</h1><p>三个条件满足其一即<strong>有可能</strong>是不用DP：</p>
<ul>
<li>求所有<strong>具体</strong>的方案（输出所有回文串）</li>
<li>输入是<strong>集合</strong>（是无序的），而不是序列（求最长连续序列），背包问题是例外</li>
<li>暴力方法的复杂度已经是多项式级别，不擅长$n^3-&gt;n^2$</li>
</ul>
<h1 id="DP四要素"><a href="#DP四要素" class="headerlink" title="DP四要素"></a>DP四要素</h1><p><strong>状态</strong>：<code>f[][]</code>的含义，<strong>最难</strong>！</p>
<p><strong>方程</strong>：状态之间的联系，怎么用小状态算大状态</p>
<p><strong>初始化</strong>：最小状态是什么，起点</p>
<p><strong>答案</strong>：最大状态是什么，终点</p>
<p><strong>VS递归三要素</strong></p>
<ul>
<li><strong>定义</strong>（状态）<ul>
<li>接受了什么参数</li>
<li>做了什么事情</li>
<li>返回了什么值</li>
</ul>
</li>
<li><strong>拆解</strong>（方程）<ul>
<li>符合将参数变小</li>
</ul>
</li>
<li><strong>出口</strong>（初始化）<ul>
<li>什么时候可以直接return</li>
</ul>
</li>
</ul>
<h1 id="常见DP"><a href="#常见DP" class="headerlink" title="常见DP"></a>常见DP</h1><p><strong>坐标型 15%</strong></p>
<p><strong>序列型 30%</strong></p>
<p><strong>双序列 30%</strong></p>
<p>划分型 10%</p>
<p>背包型 10%</p>
<p>区间型 5%</p>
<h2 id="坐标型（矩阵）DP"><a href="#坐标型（矩阵）DP" class="headerlink" title="坐标型（矩阵）DP"></a>坐标型（矩阵）DP</h2><p>特点：小人在按照某种方向跳</p>
<p><strong>状态</strong>：</p>
<ul>
<li><code>f[x]</code>：从起点走到坐标x…</li>
<li><code>f[x][y]</code>：从起点走到坐标x,y…</li>
</ul>
<p><strong>方程</strong>：研究走到x,y这个点之前的这一步</p>
<p><strong>初始化</strong>：起点</p>
<p><strong>答案</strong>：重点</p>
<h3 id="例题1：Minimum-Path-Sum"><a href="#例题1：Minimum-Path-Sum" class="headerlink" title="例题1：Minimum Path Sum"></a>例题1：Minimum Path Sum</h3><p>题目：从左上走到右下最短距离。只能向右向下走。求最小路径</p>
<p><strong>状态：</strong><code>f[x][y]</code> : 从起点走到x,y的最短路径</p>
<p><strong>方程</strong>：<code>f[x][y] = Math.min(f[x-1][y],f[x][y-1]+A[x][y]</code></p>
<p><strong>初始化</strong>：边界</p>
<p><strong>答案</strong>：<code>f[n][m]</code></p>
<h3 id="例题2，Unique-Paths"><a href="#例题2，Unique-Paths" class="headerlink" title="例题2，Unique Paths"></a>例题2，Unique Paths</h3><p>题目：从左上走到右下最短距离。只能向右向下走。求方案个数。</p>
<p><strong>状态</strong>：<code>f[x][y]</code>：从[0,0]出发，到[x,y]的方案总数</p>
<p><strong>方程</strong>：<code>f[x][y] = f[x-1][y] + f[x][y-1]</code>（需要强调的是，<code>[x-1,y]</code>和<code>[x,y-1]</code>两种方案不会重叠！）</p>
<p><strong>初始化</strong>：第0行、第0列的边界</p>
<p><strong>答案</strong>：<code>f[n][m]</code></p>
<h3 id="例题3，Unique-Paths-II"><a href="#例题3，Unique-Paths-II" class="headerlink" title="例题3，Unique Paths II"></a>例题3，Unique Paths II</h3><p>如果路上有障碍，求方案个数。</p>
<h3 id="Knight-Probability-in-Chessboard"><a href="#Knight-Probability-in-Chessboard" class="headerlink" title="Knight Probability in Chessboard"></a>Knight Probability in Chessboard</h3><p>给一个$n \times n$ 的棋盘，每次可以走八个方向，如图所示。求从[r,c] 出发走K步之后它还停留在棋盘上的概率。</p>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2018-01-16-17-16-47.png"> </p>
<p><strong>方法1，暴解</strong></p>
<p>暴解肯定会超时，但是基础思路</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> in;</span><br><span class="line">        <span class="keyword">int</span> all;</span><br><span class="line">        Node(<span class="keyword">int</span> in, <span class="keyword">int</span> all)&#123;</span><br><span class="line">            <span class="keyword">this</span>.in = in; </span><br><span class="line">            <span class="keyword">this</span>.all = all;</span><br><span class="line">        &#125;</span><br><span class="line">        Node()&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[][] direct = &#123;&#123;<span class="number">2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">2</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,-<span class="number">2</span>&#125;,&#123;-<span class="number">2</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">2</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;-<span class="number">1</span>,-<span class="number">2</span>&#125;&#125;; <span class="comment">// 这个方向很重要啊，一开始的时候看错题了，以为是相邻的八个，结果调了好久</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">helper</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r &gt;= N || c &gt;= N)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(<span class="number">0</span>, (<span class="keyword">int</span>)Math.pow(<span class="number">8</span>,K)); <span class="comment">// 此时已经出格子了，无论接下来的K步怎么走，都不能跳回去。因此接下来的K步的所有方案都不行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(K == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> Node(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        Node curr = <span class="keyword">new</span> Node();</span><br><span class="line">		<span class="comment">// 当前格子走K步后，留在棋盘内的可能个数 = curr.in</span></span><br><span class="line">        <span class="comment">// 当前格子走K步的全部可能的走法个数 = curr.all</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 遍历所有的方向</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] dir : direct)&#123;</span><br><span class="line">            Node next = helper(N, K - <span class="number">1</span>, r + dir[<span class="number">0</span>], c + dir[<span class="number">1</span>]);</span><br><span class="line">            curr.all += next.all;</span><br><span class="line">            curr.in += next.in;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">knightProbability</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        Node res = helper(N, K, r, c);</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">double</span>)res.in) / ((<span class="keyword">double</span>)res.all);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其实到最后res.all 都会等于$8^K$ ,因此只需要记录in的个数即可。</p>
<p><strong>方法2，记忆化搜索</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] direct = &#123;&#123;<span class="number">2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">2</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,-<span class="number">2</span>&#125;,&#123;-<span class="number">2</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">2</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;-<span class="number">1</span>,-<span class="number">2</span>&#125;&#125;;</span><br><span class="line"> <span class="keyword">double</span> [][][] memo;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r &gt;= N || c &gt;= N)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span>(memo[r][c][K] &gt;= <span class="number">0</span>) <span class="keyword">return</span> memo[r][c][K];</span><br><span class="line">     <span class="keyword">if</span>(K == <span class="number">0</span>)&#123;</span><br><span class="line">         memo[r][c][K] = <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">     <span class="comment">// 当前格子走K步后，留在棋盘内的可能个数 = curr</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span>[] dir : direct)&#123;</span><br><span class="line">         curr += helper(N, K - <span class="number">1</span>, r + dir[<span class="number">0</span>], c + dir[<span class="number">1</span>]);</span><br><span class="line">     &#125;</span><br><span class="line">     memo[r][c][K] = curr;</span><br><span class="line">     System.out.println(curr);</span><br><span class="line">     <span class="keyword">return</span> memo[r][c][K];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">knightProbability</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     memo = <span class="keyword">new</span> <span class="keyword">double</span>[N][N][K + <span class="number">1</span>];</span><br><span class="line">     <span class="comment">// 初始化</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)&#123;</span><br><span class="line">             Arrays.fill(memo[i][j], -<span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">double</span> inCount = helper(N, K, r, c);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> inCount / Math.pow(<span class="number">8</span>, K);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>然而即使记忆化搜索，会出现inCount爆了double的情况。我们还是需要想其它办法！——那就不要返回全部的和，每次都返回概率嗷嗷嗷嗷嗷</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] direct = &#123;&#123;<span class="number">2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">2</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,-<span class="number">2</span>&#125;,&#123;-<span class="number">2</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">2</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;-<span class="number">1</span>,-<span class="number">2</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">double</span> [][][] memo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r &gt;= N || c &gt;= N)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(memo[r][c][K] &gt;= <span class="number">0</span>) <span class="keyword">return</span> memo[r][c][K];</span><br><span class="line">    <span class="keyword">if</span>(K == <span class="number">0</span>)&#123;</span><br><span class="line">        memo[r][c][K] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> curr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] dir : direct)&#123;</span><br><span class="line">        curr += helper(N, K - <span class="number">1</span>, r + dir[<span class="number">0</span>], c + dir[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    memo[r][c][K] = curr/<span class="number">8.0</span>;</span><br><span class="line">    <span class="comment">//System.out.println(curr);</span></span><br><span class="line">    <span class="keyword">return</span> memo[r][c][K];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">knightProbability</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    memo = <span class="keyword">new</span> <span class="keyword">double</span>[N][N][K + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)&#123;</span><br><span class="line">            Arrays.fill(memo[i][j], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helper(N, K, r, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法3，DP递推</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">memo[r][c][K] : [r,c]走K步后留在棋盘内的概率</span><br><span class="line"></span><br><span class="line">转移方程：</span><br><span class="line"></span><br><span class="line">memo[r][c][K] += memo[r+dir[<span class="number">0</span>]][c+dir[<span class="number">1</span>]][K-<span class="number">1</span>]</span><br><span class="line">memo[r][c][K] = memo[r][c][K]/<span class="number">8</span></span><br><span class="line">  </span><br><span class="line">初始化：</span><br><span class="line"></span><br><span class="line">memo[r][c][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">代码：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">knightProbability</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] direct = &#123;&#123;<span class="number">2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">2</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,-<span class="number">2</span>&#125;,&#123;-<span class="number">2</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">2</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;-<span class="number">1</span>,-<span class="number">2</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">double</span> [][][] memo = <span class="keyword">new</span> <span class="keyword">double</span>[N][N][K + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)&#123;</span><br><span class="line">                memo[i][j][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= K; ++k)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i )&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)&#123;</span><br><span class="line">                    <span class="comment">// 遍历八个方向</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span>[] dir : direct)&#123;</span><br><span class="line">                        <span class="keyword">int</span> i_new = i + dir[<span class="number">0</span>], j_new = j + dir[<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span>(i_new &lt; <span class="number">0</span> || j_new &lt; <span class="number">0</span> || i_new &gt;= N || j_new &gt;= N) <span class="keyword">continue</span>;</span><br><span class="line">                        memo[i][j][k] += memo[i_new][j_new][k-<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    memo[i][j][k] /= <span class="number">8</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[r][c][K];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="Out-of-Boundary-paths"><a href="#Out-of-Boundary-paths" class="headerlink" title="Out of Boundary paths"></a>Out of Boundary paths</h3><p>给一个$m\times n$ 的棋盘，每次可以走向上下左右四个方向。可以走回头路。求问在N步限制下，有多少种走出棋盘的方法。</p>
<p>这道题与之前的不同之处在于，可以向四个方向走。但限制条件就是最多能走N步。</p>
<p><strong>解法一，暴解</strong></p>
<p>暴力DFS！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> M=<span class="number">1000000007</span>;</span><br><span class="line">   <span class="keyword">int</span>[][][] memo;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> stepRemain)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span>(stepRemain == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 这一步一定要写在上一个判断之后</span></span><br><span class="line">       </span><br><span class="line">       <span class="keyword">int</span>[] di = &#123;<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>&#125;; <span class="keyword">int</span>[] dj = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">       <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)&#123;</span><br><span class="line">           sum += helper(m, n, i + di[k], j + dj[k], stepRemain - <span class="number">1</span>);</span><br><span class="line">           sum %= M;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sum%M;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> N, <span class="keyword">int</span> i_in, <span class="keyword">int</span> j_in)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(i_in &lt; <span class="number">0</span> || i_in &gt;= m || j_in &lt; <span class="number">0</span> || j_in &gt;= n || N == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">return</span> helper(m, n, i_in, j_in,N);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这种方式最容易想到。（一开始没理清题意，以为不可以成环，但其实可以）</p>
<p><strong>解法二，记忆化搜索</strong></p>
<p>这里的关键点就是，状态不仅由i和j决定，还有stepRemain！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> M=<span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">int</span>[][][] memo;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> stepRemain)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(stepRemain == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(memo[i][j][stepRemain] &gt;= <span class="number">0</span>) <span class="keyword">return</span> memo[i][j][stepRemain];</span><br><span class="line">        <span class="keyword">int</span>[] di = &#123;<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>&#125;; <span class="keyword">int</span>[] dj = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)&#123;</span><br><span class="line">            sum += (helper(m, n, i + di[k], j + dj[k], stepRemain - <span class="number">1</span>)%M);</span><br><span class="line">            sum %= M;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[i][j][stepRemain] = sum%M;</span><br><span class="line">        <span class="keyword">return</span> memo[i][j][stepRemain];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> N, <span class="keyword">int</span> i_in, <span class="keyword">int</span> j_in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i_in &lt; <span class="number">0</span> || i_in &gt;= m || j_in &lt; <span class="number">0</span> || j_in &gt;= n || N == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[m][n][N + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; m; ++a)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; n; ++b)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt;= N; ++c) memo[a][b][c] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(m, n, i_in, j_in,N);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>解法三，DP递推</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">状态 memo[i][j][step] : 从[i,j]出发走step步有多少种方式走出去</span><br><span class="line"></span><br><span class="line">为了方便起见，我们做以下符号处理：</span><br><span class="line"><span class="number">1.</span> 状态记为memo[i,j][step]</span><br><span class="line"><span class="number">2.</span> memo[right][step] 为[i,j]的右边格子出发走step步</span><br><span class="line"><span class="number">3.</span> memo[left][step] 、 memo[down][step] 、memo[up][step]同理，分别为左边，下面，上面</span><br><span class="line"></span><br><span class="line">方程：</span><br><span class="line"></span><br><span class="line">当left,right,down,up都没有出边界时：</span><br><span class="line">memo[i,j][step] = memo[left][step-<span class="number">1</span>] + memo[right][step-<span class="number">1</span>] + memo[down][step-<span class="number">1</span>] + memo[up][step-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">根据状态我们得知，本次计算需要用到上次计算的step-<span class="number">1</span>的所有状态，因此最外层循环一定是step依次++</span><br><span class="line">  </span><br><span class="line">初始化：</span><br><span class="line"></span><br><span class="line">step = <span class="number">1</span>时，所有边界格子的初始值都为<span class="number">1</span>，四个角的初始值为<span class="number">2</span>（ 含义：边上走<span class="number">1</span>步到达外面时，走法只有<span class="number">1</span>种！四个角走<span class="number">1</span>步到达外面时，走法有<span class="number">2</span>种）即：</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            memo[i][<span class="number">0</span>][<span class="number">1</span>] += <span class="number">1</span>; <span class="comment">// 左边界  （注意：这里一定必须是加号，因为有可能一个格子同时是左边界和右边界！）</span></span><br><span class="line">            memo[i][n-<span class="number">1</span>][<span class="number">1</span>] += <span class="number">1</span>; <span class="comment">// 右边界</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">            memo[<span class="number">0</span>][j][<span class="number">1</span>] += <span class="number">1</span>; <span class="comment">// 上边界</span></span><br><span class="line">            memo[m-<span class="number">1</span>][j][<span class="number">1</span>] += <span class="number">1</span>; <span class="comment">// 下边界</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">结果 ： </span><br><span class="line">因为限制至多走N步，因此结果应该为 sum(memo[i_in][j_in][<span class="number">1</span>~N])</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"> 代码：</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> N, <span class="keyword">int</span> i_in, <span class="keyword">int</span> j_in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i_in &lt; <span class="number">0</span> || i_in &gt;= m || j_in &lt; <span class="number">0</span> || j_in &gt;= n || N == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> M=<span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">int</span>[][][] memo = <span class="keyword">new</span> <span class="keyword">int</span>[m][n][N + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            memo[i][<span class="number">0</span>][<span class="number">1</span>] += <span class="number">1</span>; <span class="comment">// 左边界</span></span><br><span class="line">            memo[i][n-<span class="number">1</span>][<span class="number">1</span>] += <span class="number">1</span>; <span class="comment">// 右边界</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">            memo[<span class="number">0</span>][j][<span class="number">1</span>] += <span class="number">1</span>; <span class="comment">// 上边界</span></span><br><span class="line">            memo[m-<span class="number">1</span>][j][<span class="number">1</span>] += <span class="number">1</span>; <span class="comment">// 下边界</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 状态转移</span></span><br><span class="line">        <span class="keyword">int</span>[] di = &#123;<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>&#125;; <span class="keyword">int</span>[] dj = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> step = <span class="number">2</span>; step &lt;= N; ++step)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m ; ++i)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n ; ++j)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)&#123;</span><br><span class="line">                        <span class="keyword">int</span> i_new = i + di[k], j_new = j + dj[k];</span><br><span class="line">                        <span class="keyword">if</span>(i_new &lt; <span class="number">0</span> || j_new &lt; <span class="number">0</span> || i_new &gt;= m || j_new &gt;= n)&#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        memo[i][j][step] += memo[i_new][j_new][step - <span class="number">1</span>];</span><br><span class="line">                        memo[i][j][step] %= M;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// 计算结果</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> step = <span class="number">0</span>; step &lt;= N; ++step)&#123;</span><br><span class="line">            sum = (sum + memo[i_in][j_in][step]) % M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="例题4，Climbing-Stairs"><a href="#例题4，Climbing-Stairs" class="headerlink" title="例题4，Climbing Stairs"></a>例题4，Climbing Stairs</h3><p>有一个楼梯，一步只能跨1/2步。问从0走到n层有多少层方案。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">f[i] -&gt; i位置有多少种</span><br><span class="line"></span><br><span class="line">f[i] = f[i-<span class="number">1</span>] + f[i-<span class="number">2</span>] <span class="comment">//要么从i-1来的，要么从i-2来的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//斐波那契数列！</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( n &lt;= <span class="number">2</span> ) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="comment">//f[i] : 有i个台阶时的方案个数</span></span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        f[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n ; ++i )&#123;</span><br><span class="line">            f[i] = f[i-<span class="number">1</span>] + f[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题5，Jump-Game"><a href="#例题5，Jump-Game" class="headerlink" title="例题5，Jump Game"></a>例题5，Jump Game</h3><p>给一个数组A,<code>A[i]</code>表示在这里时最多可以跳<code>A[i]</code>步。只能向前跳。从数组A的第0位置出发，能不能跳到末尾。</p>
<p>这道题有两种解法，一种是DP，一种是贪心。DP会超时，但是思路非常好。</p>
<p>先介绍DP，这个复杂度是$O(n^2)$:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* f[i] -&gt; 从0到i是否可达</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 1,2,...,j,...i</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 如果j可达，且从j可以跳到i，则i可达，即：看看存不存在一个j，j满足以下两个条件：</span></span><br><span class="line"><span class="comment">*  1. j可达 --&gt; f[j] == true</span></span><br><span class="line"><span class="comment">*  2. 从j出发够得到i --&gt; i - j &lt;= A[j]</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( nums.length == <span class="number">0</span> ) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] f = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        f[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">1</span> ; i &lt; nums.length ; ++i )&#123;</span><br><span class="line">            <span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; i ; ++j )&#123;</span><br><span class="line">                <span class="keyword">if</span>( f[j] &amp;&amp; i - j &lt;= nums[j] )&#123; <span class="comment">// j可达，且从j可以跳到i</span></span><br><span class="line">                    f[i] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[nums.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>再介绍贪心的思路，这个复杂度是$O(n)$</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">维护两个东西：</span></span><br><span class="line"><span class="comment">	1. 到目前为止能跳到的最远距离（全局）</span></span><br><span class="line"><span class="comment">	2. 从当前一步出发能跳到的最远距离（局部）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">全局最优 global = Math.max(global, local)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">局部最优 local = A[i]+i</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// think it as merging n intervals</span></span><br><span class="line">  <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> global = A[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= global &amp;&amp; A[i] + i &gt;= global) &#123;</span><br><span class="line">      global = A[i] + i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> global &gt;= A.length - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题6，Jump-Game-II"><a href="#例题6，Jump-Game-II" class="headerlink" title="例题6，Jump Game II"></a>例题6，Jump Game II</h3><p>给一个数组A,<code>A[i]</code>表示在这里时最多可以跳<code>A[i]</code>步。只能向前跳。从数组A的第0位置出发，问最少的跳的次数。</p>
<p>这道题还是有两个思路，一个DP，一个贪心。我们先介绍一下DP，虽然DP会超时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">f[i] : 从起点出发，跳到i最少需要几步</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">          |---&gt;i-j&lt;---|</span></span><br><span class="line"><span class="comment">1,3,.....,|j,.......,i|</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果j可达i（即i - j &lt;= nums[j]），则 f[i] = min ( f[j] + 1 )</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>( nums.length == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//状态：f[i] -&gt; 从0到i最少的跳跃次数</span></span><br><span class="line">  <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">  <span class="comment">//初始化</span></span><br><span class="line">  f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i,j;</span><br><span class="line">  <span class="keyword">for</span>( i = <span class="number">1</span> ; i &lt; nums.length ; ++i )&#123;</span><br><span class="line">    f[i] = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; i ; ++j )&#123;</span><br><span class="line">      <span class="keyword">if</span>( i - j &lt;= nums[j] )&#123;</span><br><span class="line">        f[i] = Math.min(f[i],f[j]+<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f[nums.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种思路，贪心：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">要记录</span></span><br><span class="line"><span class="comment">最远能覆盖到的地方 -&gt; curr</span></span><br><span class="line"><span class="comment">已经覆盖的地方 -&gt; last</span></span><br><span class="line"><span class="comment">当前所使用跳数 -&gt; ret</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">扫描以确定当前最远能覆盖的节点，放入curr。</span></span><br><span class="line"><span class="comment">然后继续扫描，直到当前的路程超过了上一次算出的覆盖范围，那么更新覆盖范围，同时更新条数，因为我们是经过了多一跳才能继续前进的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">比如就是我们题目中的[2,3,1,1,4]。初始状态是这样的：cur表示最远能覆盖到的地方，用框里表示。last表示已经覆盖的地方。它们都指在第一个元素上。</span></span><br><span class="line"><span class="comment">==============================================================</span></span><br><span class="line"><span class="comment">cur</span></span><br><span class="line"><span class="comment">-↓-</span></span><br><span class="line"><span class="comment"> 2 |	3	1	1	4</span></span><br><span class="line"><span class="comment">-↑-</span></span><br><span class="line"><span class="comment">last</span></span><br><span class="line"><span class="comment">==============================================================</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">第一元素告诉cur，最远可以走两步，于是：</span></span><br><span class="line"><span class="comment">            cur</span></span><br><span class="line"><span class="comment">-------------↓-</span></span><br><span class="line"><span class="comment"> 2     3     1 |	1	4</span></span><br><span class="line"><span class="comment">-↑-------------</span></span><br><span class="line"><span class="comment">last</span></span><br><span class="line"><span class="comment">==============================================================</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">下一循环中，i指向1（即上面的3）。发现i小于last能到的范围，于是更新last，步数ret+1，同时也要更新cur，因为我们发现更远的距离</span></span><br><span class="line"><span class="comment">      i=1               cur</span></span><br><span class="line"><span class="comment">-------↓-----------------↓-</span></span><br><span class="line"><span class="comment"> 2     3     1     1	4 |</span></span><br><span class="line"><span class="comment">-------------↑-------------</span></span><br><span class="line"><span class="comment">           last</span></span><br><span class="line"><span class="comment">==============================================================</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">接下来i继续前进，发现i还在当前的实例范围内，无需更新last和步数ret，只需要更新curr</span></span><br><span class="line"><span class="comment">            i=2         cur</span></span><br><span class="line"><span class="comment">-------------↓-----------↓-</span></span><br><span class="line"><span class="comment"> 2     3     1     1	4 |</span></span><br><span class="line"><span class="comment">-------------↑-------------</span></span><br><span class="line"><span class="comment">          last = 2</span></span><br><span class="line"><span class="comment">==============================================================</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">i继续前进，接下来发现超过当前势力范围，更新last和步数。cur已然最大了。</span></span><br><span class="line"><span class="comment">                  i=3   cur</span></span><br><span class="line"><span class="comment">-------------------↓-----↓-</span></span><br><span class="line"><span class="comment"> 2     3     1     1	4 |</span></span><br><span class="line"><span class="comment">-------------------------↑-</span></span><br><span class="line"><span class="comment">                     last = 4</span></span><br><span class="line"><span class="comment">==============================================================</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">最后，i到最后一个元素，依然在last的势力范围内，遍历完成，返回ret。</span></span><br><span class="line"><span class="comment">                     i=cur=4</span></span><br><span class="line"><span class="comment">-------------------------↓-</span></span><br><span class="line"><span class="comment"> 2     3     1     1	4 |</span></span><br><span class="line"><span class="comment">-------------------------↑-</span></span><br><span class="line"><span class="comment">                     last = 4</span></span><br><span class="line"><span class="comment">==============================================================</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">          <span class="comment">//需要进行下次跳跃，则更新last和当执行的跳数ret</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; last) &#123;</span><br><span class="line">                last = curr;</span><br><span class="line">                ++ret;</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">//最远能覆盖到的地方</span></span><br><span class="line">            curr = max(curr, i+A[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Russian-Doll-Envelopes"><a href="#Russian-Doll-Envelopes" class="headerlink" title="Russian Doll Envelopes"></a>Russian Doll Envelopes</h3><p>俄罗斯套娃信封。给一堆信封pair - [w,h] 。要求如果信封A的宽高都小于B的话，那么A就可以放入B。求这堆信封最多能套多少层。</p>
<p><strong>思路一，DP</strong></p>
<p>这里的DP的注意要点在于，需要想清楚比较的是什么。一开始我就没想明白。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Comparator cmp = <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(o1[<span class="number">0</span>] == o2[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="comment">// 如果宽度相同，【高度大的在前面】,这样可以避免重复搜索。</span></span><br><span class="line">                <span class="comment">// 其实完全按照宽度排也可以</span></span><br><span class="line">                <span class="keyword">return</span> o2[<span class="number">1</span>] - o1[<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 按照宽度从小到大排</span></span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">0</span>] - o2[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="keyword">int</span>[][] envelopes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(envelopes, cmp);</span><br><span class="line">        <span class="keyword">int</span>[] v = <span class="keyword">new</span> <span class="keyword">int</span>[envelopes.length];</span><br><span class="line">        Arrays.fill(v, <span class="number">1</span>);<span class="comment">// 还有包含自己的信封</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; envelopes.length; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(envelopes[i][<span class="number">0</span>] &gt; envelopes[j][<span class="number">0</span>] &amp;&amp;</span><br><span class="line">                        envelopes[i][<span class="number">1</span>] &gt; envelopes[j][<span class="number">1</span>])&#123;</span><br><span class="line">                    v[i] = Math.max(v[j] + <span class="number">1</span>, v[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max, v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>思路二，二分优化</strong></p>
<p>首先我们考虑一个简单的情况：</p>
<pre><code>所有信封的长和宽并不重复。
这样我们可以：先对长进行排序，然后对 宽 用二分法求 最长递增子序列（LIS）即可。
时间复杂度为：O(nlogn) 用 DP 解法的话就要 O(N^2)了。
</code></pre>
<p>接下来，我们来考虑该题的情况，即：存在长或者宽相等的情况。在这种情况下，<br>一个信封是无法被装入另一个 长/宽 相等的一个信封中的。因此我们这边使用了一个技巧：<br>    仍然先对信封的长进行 从小到大 的排序，当长度相等的时候，对宽度进行 从大到小 的排序。<br>    这边都宽度进行 从大到小 的排序是为了使得：当长度相等时，宽度最大的信封是排在最前面的。<br>    这样就避免了会将长度相等，但是宽度更小的信封装入一个宽度更大的信封中的情况。<br>    比如： [[5,4],[5,5],[6,7],[2,3]], 如果长度相等时，宽度仍然按照 从小到大 的排序的话，结果为：[[2,3],[5,4],[5,5],[6,7]]<br>    就会出现：[5,4] =&gt; [5,5],即将 宽4长5 的信封装入 宽5长5 的信封中的情况，而这是错误的。<br>    但是如果长度相等时，将宽度按照 从大到小 的顺序排列的话，结果为：[[2,3],[5,5],[5,4],[6,7]].<br>    这样就能保证：所有宽度大于前面信封宽度的信封的长度必定是大于之前信封长度的。（比较绕，但是意思相信大家已经理解了）<br>    最后只需要对 信封的宽度 求LIS即可。这边使用了二分查找最小结尾数组的方法。较为巧妙，可以达到 O(nlogn) 的时间复杂度。<br>只需要这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="keyword">int</span>[][] envelopes)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Write your code here</span></span><br><span class="line">    <span class="keyword">if</span>(envelopes == <span class="keyword">null</span> || envelopes.length == <span class="number">0</span> </span><br><span class="line">        || envelopes[<span class="number">0</span>] == <span class="keyword">null</span> || envelopes[<span class="number">0</span>].length != <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Arrays.sort(envelopes, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr1[<span class="number">0</span>] == arr2[<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">return</span> arr2[<span class="number">1</span>] - arr1[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> arr1[<span class="number">0</span>] - arr2[<span class="number">0</span>];</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[envelopes.length];</span><br><span class="line">    <span class="comment">// dp[i] : 长度为i+1的 LIS的最小h是dp[i]</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] envelope : envelopes)&#123;</span><br><span class="line">        <span class="keyword">int</span> index = Arrays.binarySearch(dp, <span class="number">0</span>, len, envelope[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(index &lt; <span class="number">0</span>)</span><br><span class="line">                index = -index - <span class="number">1</span>;</span><br><span class="line">        dp[index] = envelope[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (index == len)</span><br><span class="line">            len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="例题7，Longest-Increasing-Subsequence"><a href="#例题7，Longest-Increasing-Subsequence" class="headerlink" title="例题7，Longest Increasing Subsequence"></a>例题7，Longest Increasing Subsequence</h3><p>求最长严格递增的子序列（子序列：可以跳着选）</p>
<p>例如给<code>[5,4,1,2,3]</code>,最长的LIS就是<code>1,2,3</code></p>
<p>可以用DP——$n^2$，也可以用二分——$nlogn$。我们先介绍一下DP</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line">理解为：</span><br><span class="line">  <span class="number">5</span></span><br><span class="line">|---| <span class="number">4</span></span><br><span class="line">|   |---|         <span class="number">3</span></span><br><span class="line">|   |   |     <span class="number">2</span> |---|</span><br><span class="line">|   |   | <span class="number">1</span> |---|   |</span><br><span class="line">|   |   |---|   |   | </span><br><span class="line">  <span class="number">5</span>   <span class="number">4</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   的楼梯，目的是从某个木桩出发，从低到高，看能踩多少个木桩</span><br><span class="line"></span><br><span class="line">f[i] : （从任意某个木桩）跳到第i个木桩，最多能踩过多少个桩</span><br><span class="line"></span><br><span class="line">方程 ：f[i] = max&#123; f[j] + <span class="number">1</span> &#125; , j 必须满足 j &lt; i &amp;&amp; nums[j] &lt;= nums[i]</span><br><span class="line"></span><br><span class="line">初始化：f[i] = <span class="number">1</span> <span class="comment">//每个格子对于自己来说都可达</span></span><br><span class="line"></span><br><span class="line">答案： Max(f[<span class="number">0</span>],f[<span class="number">1</span>],...,[n-<span class="number">1</span>])</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//f[i] -&gt; 跳到当前i时，最多可以跳的次数</span></span><br><span class="line">  <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">  <span class="comment">//初始化</span></span><br><span class="line">  <span class="keyword">int</span> i,j;</span><br><span class="line">  <span class="comment">// 这个其实可以放到最后再+1</span></span><br><span class="line">  <span class="comment">//        for( i = 0 ; i &lt; nums.length ; ++i)&#123;</span></span><br><span class="line">  <span class="comment">//            f[i] = 1;</span></span><br><span class="line">  <span class="comment">//        &#125;</span></span><br><span class="line">  <span class="comment">//开始</span></span><br><span class="line">  <span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; nums.length ; ++i )&#123;</span><br><span class="line">    <span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; i ; ++j )&#123;</span><br><span class="line">      <span class="keyword">if</span>( nums[j] &lt; nums[i] ) &#123;</span><br><span class="line">        f[i] = Math.max(f[i],f[j]+<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//结果 j = max&#123;f[i]&#125;</span></span><br><span class="line">  j = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; f.length ; ++i )&#123;</span><br><span class="line">    j = Math.max(j,f[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> j+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们看看二分这个骚操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">tail[i] -&gt; 长度为i+<span class="number">1</span>的LIS的【最小】末尾是tail[i]</span><br><span class="line">以nums = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>]为例：</span><br><span class="line"></span><br><span class="line">len = <span class="number">1</span>   :      [<span class="number">4</span>], [<span class="number">5</span>], [<span class="number">6</span>], [<span class="number">3</span>]   =&gt; tails[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line">len = <span class="number">2</span>   :      [<span class="number">4</span>, <span class="number">5</span>], [<span class="number">5</span>, <span class="number">6</span>]       =&gt; tails[<span class="number">1</span>] = <span class="number">5</span></span><br><span class="line">len = <span class="number">3</span>   :      [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]            =&gt; tails[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">此时如果后面又来了一个x</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>) 如果x大于所有tails，那就把这个x放在这个里面，并把长度+<span class="number">1</span></span><br><span class="line">(<span class="number">2</span>) 如果tails[i-<span class="number">1</span>] &lt; x &lt;= tails[i], 更新 tails[i]</span><br><span class="line"></span><br><span class="line">size -&gt; 当前最长序列长度</span><br><span class="line">序[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">以[<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">7</span>]为例：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span> --&gt; x = <span class="number">2</span>, tail = [<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]  -&gt; size = <span class="number">1</span></span><br><span class="line">[<span class="number">2</span>]   --&gt; 子序列 <span class="number">2</span></span><br><span class="line">  </span><br><span class="line">i = <span class="number">1</span> --&gt; x = <span class="number">1</span>, tail = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]  -&gt; size = <span class="number">1</span></span><br><span class="line">[<span class="number">2</span>,<span class="number">1</span>] --&gt; 子序列[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">2</span>   --&gt; x = <span class="number">5</span>, tail = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]  -&gt; size = <span class="number">2</span></span><br><span class="line">[<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>] --&gt; 子序列[<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">3</span>    --&gt; x = <span class="number">3</span>, tail = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]  -&gt; size = <span class="number">2</span></span><br><span class="line">[<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>] --&gt; 子序列[<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">4</span>       --&gt; x = <span class="number">6</span>, tail = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]  -&gt; size = <span class="number">3</span></span><br><span class="line">[<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>] --&gt; 子序列[<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">5</span>         --&gt; x = <span class="number">4</span>, tail = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]  -&gt; size = <span class="number">3</span></span><br><span class="line">[<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>] --&gt; 子序列[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">6</span>           --&gt; x = <span class="number">8</span>, tail = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]  -&gt; size = <span class="number">4</span></span><br><span class="line">[<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">8</span>] --&gt; 子序列[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">7</span>             --&gt; x = <span class="number">9</span>, tail = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]  -&gt; size = <span class="number">4</span></span><br><span class="line">[<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>] --&gt; 子序列[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">8</span>               --&gt; x = <span class="number">7</span>, tail = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]  -&gt; size = <span class="number">4</span></span><br><span class="line">[<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">7</span>] --&gt; 子序列[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] tails = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = size;</span><br><span class="line">        <span class="comment">//用二分在tails中寻找一个位置，将x安顿一下</span></span><br><span class="line">        <span class="keyword">while</span> (i != j) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (i + j) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (tails[m] &lt; x)</span><br><span class="line">                i = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j = m;</span><br><span class="line">        &#125;</span><br><span class="line">        tails[i] = x;</span><br><span class="line">        <span class="keyword">if</span> (i == size) ++size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Number-of-Longest-Increasing-Subsequence"><a href="#Number-of-Longest-Increasing-Subsequence" class="headerlink" title="Number of Longest Increasing Subsequence"></a>Number of Longest Increasing Subsequence</h3><p>求一个数组的最长递增子序列的个数</p>
<p>这个题对我来说有点难</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNumberOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">int</span>[] counter = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length]; <span class="comment">// 以nums[i]为结尾的，最长递增子序列的个数</span></span><br><span class="line">    Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">    Arrays.fill(counter,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxLengthNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &gt;= nums[i]) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(dp[j] + <span class="number">1</span> == dp[i])&#123;</span><br><span class="line">                counter[i] += counter[j];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dp[j] + <span class="number">1</span> &gt; dp[i])&#123;</span><br><span class="line">                dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                counter[i] = counter[j];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[i] &gt; maxLength)&#123;</span><br><span class="line">            maxLength = dp[i];</span><br><span class="line">            maxLengthNum = counter[i];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dp[i] == maxLength)&#123;</span><br><span class="line">            maxLengthNum += counter[i]; <span class="comment">// 这里是精髓啊</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> maxLengthNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Increasing-Subsequences"><a href="#Increasing-Subsequences" class="headerlink" title="Increasing Subsequences"></a>Increasing Subsequences</h3><p>求一个数组的所有递增子序列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">一开始的思路就是用递归</span><br><span class="line"></span><br><span class="line">定义&lt;List&lt;List&gt;&gt;result[i]为包含nums[i]的所有递增子序列</span><br><span class="line">    &lt;List&lt;List&gt;&gt;result[i+<span class="number">1</span>]为包含nums[i+<span class="number">1</span>]的所有递增子序列，那么</span><br><span class="line"></span><br><span class="line">对于&lt;List&lt;List&gt;&gt;result[i+<span class="number">1</span>]中的每个成员&lt;List&gt;element来说：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 如果 nums[i] &lt;= element.head , 那么 nums[i] + element 可以作为一个result[i]中的结果</span><br><span class="line"><span class="number">2.</span> element 本身也可以作为result[i]中的结果</span><br><span class="line"><span class="number">3.</span> nums[i]也可以作为result[i]中的结果</span><br><span class="line"></span><br><span class="line">需要注意的是，当生成到result[<span class="number">0</span>]时，我们只需要的是长度大于<span class="number">1</span>的结果。因此需要判断一下，如果以上三种情况的某种情况长度小于等于<span class="number">1</span>，那么就不加入result[i]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">然而这样下去的后果是，如果遇到重复元素，就会生成重复的结果。例如我输入nums = [<span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">7</span>]。那会得到：[[<span class="number">4</span>, <span class="number">7</span>], [<span class="number">4</span>, <span class="number">6</span>], [<span class="number">4</span>, <span class="number">7</span>], [<span class="number">7</span>, <span class="number">7</span>], [<span class="number">4</span>, <span class="number">7</span>, <span class="number">7</span>], [<span class="number">6</span>, <span class="number">7</span>], [<span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>]]</span><br><span class="line"></span><br><span class="line">生成了两个[<span class="number">4</span>,<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">这个问题想了一下午都没有解决。</span><br><span class="line"></span><br><span class="line">看了网上的解法，跟我的不是一个套路。哎。来日重刷此题！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">======来日</span><br><span class="line"></span><br><span class="line">已在回溯里面解决此题。</span><br></pre></td></tr></table></figure>



<h3 id="Arithmetic-Slices"><a href="#Arithmetic-Slices" class="headerlink" title="Arithmetic Slices"></a>Arithmetic Slices</h3><p>给一个序列。求这个序列有多少个等差数列（至少三个元素才算等差数列）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// times[i] : 长度为i的等差序列可以构成多少个等差序列</span></span><br><span class="line"><span class="keyword">int</span>[] times;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getTimes</span><span class="params">( <span class="keyword">int</span> i )</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>( i &lt; <span class="number">2</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>( times[i] &gt; <span class="number">0</span> )&#123;</span><br><span class="line">    <span class="keyword">return</span> times[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// function</span></span><br><span class="line">  times[i] = getTimes(i-<span class="number">1</span>) + i - <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> times[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = A.length;</span><br><span class="line">  <span class="keyword">if</span>( n &lt; <span class="number">3</span> )<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  times = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">  times[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> last = A[<span class="number">1</span>] - A[<span class="number">0</span>],now;</span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">0</span> ;</span><br><span class="line">  <span class="keyword">int</span> sameCount = <span class="number">2</span> ;</span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">2</span> ; i &lt; n ; ++i )&#123;</span><br><span class="line">    now = A[i] - A[i-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>( now == last )&#123;</span><br><span class="line">      ++sameCount;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>( sameCount &gt;= <span class="number">3</span> )&#123;result += getTimes(sameCount);&#125;</span><br><span class="line">      sameCount = <span class="number">2</span>;</span><br><span class="line">      last = now;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>( sameCount &gt;= <span class="number">3</span> )&#123;result += getTimes(sameCount);&#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Perfect-Squares"><a href="#Perfect-Squares" class="headerlink" title="Perfect Squares"></a>Perfect Squares</h3><p>给一个数字，求它被拆成平方和的最少平方和个数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">状态 f[i] : 数字i被拆成平方和的最少个数</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>,.....,j*j,.....i</span><br><span class="line"></span><br><span class="line">方程：</span><br><span class="line">f[i] = min ( f[i-j^<span class="number">2</span>] + <span class="number">1</span> )</span><br><span class="line"></span><br><span class="line">代码：</span><br><span class="line"><span class="comment">// nums[i] : 数字i被拆成平方和的最少个数</span></span><br><span class="line"><span class="keyword">int</span>[] nums;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>( number &lt;= <span class="number">1</span> )&#123;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>( nums[number] &gt; <span class="number">0</span> )&#123;</span><br><span class="line">    <span class="keyword">return</span> nums[number];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// a = n - i^2</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  nums[number] = number;</span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; number ; ++i )&#123;</span><br><span class="line">    a = number - i*i;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; <span class="number">0</span> )&#123; <span class="keyword">break</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>( a == <span class="number">0</span> )&#123;</span><br><span class="line">      nums[number] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 方程</span></span><br><span class="line">      nums[number] = Math.min(nums[number], <span class="number">1</span> + dp(a));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums[number];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  nums = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">  nums[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  nums[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> dp(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Min-Cost-Climbing-Stairs"><a href="#Min-Cost-Climbing-Stairs" class="headerlink" title="Min Cost Climbing Stairs"></a>Min Cost Climbing Stairs</h3><p>给一个数组，<code>cost[i]</code> 代表从第i格跳到下一步的花费。每次可以跳1或两格。求从开始（可以从0或1起跳）跳到最后的最小花费。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] dp;</span><br><span class="line"><span class="comment">// dp[i] 从第i格跳到最后需要耗费的最小cost</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] cost, <span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(idx &gt;= cost.length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(dp[idx] &gt; <span class="number">0</span>)<span class="keyword">return</span> dp[idx];</span><br><span class="line">    dp[idx] = Math.min(helper(cost, idx + <span class="number">1</span>),</span><br><span class="line">            helper(cost,idx + <span class="number">2</span>)) + cost[idx];</span><br><span class="line">    <span class="keyword">return</span> dp[idx];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">    dp = <span class="keyword">new</span> <span class="keyword">int</span>[cost.length];</span><br><span class="line">    <span class="keyword">return</span> Math.min(helper(cost,<span class="number">0</span>),helper(cost,<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Decode-Ways"><a href="#Decode-Ways" class="headerlink" title="Decode Ways"></a>Decode Ways</h3><p>给一串数字的字符串，其中1表示<code>A</code>, 2表示<code>B</code>… 求字符串可能的编码方式种类</p>
<p>思路：动态规划</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">dp[i + <span class="number">1</span>] : 字符串[<span class="number">0</span>,i]可能的编码方式</span><br><span class="line">初始化：</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// 空字符串，是个特例</span></span><br><span class="line">dp[<span class="number">1</span>] = s.charAt(<span class="number">0</span>) &lt;= <span class="string">&#x27;9&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span> ; <span class="comment">// 如果首位小于10，则首位可以被单独编码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>,<span class="number">1</span>,....,i-<span class="number">1</span>,i,i+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">情况<span class="number">1</span>：只要字符[i+<span class="number">1</span>]不等于`<span class="number">0</span>`，那字符[i+<span class="number">1</span>]能够独自编码</span><br><span class="line">情况<span class="number">2</span>：只要字符[i,i+<span class="number">1</span>]小于<span class="string">&#x27;26&#x27;</span>且大于<span class="string">&#x27;09&#x27;</span>，那字符[i,i+<span class="number">1</span>]就能编码</span><br><span class="line"></span><br><span class="line">转移方程：</span><br><span class="line"></span><br><span class="line">dp[i+<span class="number">1</span>] = dp[i] + dp[i-<span class="number">1</span>];</span><br><span class="line">            ↑        ↑</span><br><span class="line">          情况<span class="number">1</span>成立  情况<span class="number">2</span>成立时</span><br><span class="line">          </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = s.charAt(<span class="number">0</span>) &lt;= <span class="string">&#x27;9&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); ++i)&#123;</span><br><span class="line">            <span class="comment">// 情况1</span></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                dp[i + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i + <span class="number">1</span>] = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 情况2</span></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>) &gt; <span class="string">&#x27;0&#x27;</span> &amp;&amp; (s.charAt(i-<span class="number">1</span>) &lt; <span class="string">&#x27;2&#x27;</span> || (s.charAt(i-<span class="number">1</span>)==<span class="string">&#x27;2&#x27;</span>&amp;&amp;s.charAt(i) &lt;= <span class="string">&#x27;6&#x27;</span>)))&#123;</span><br><span class="line">                dp[i + <span class="number">1</span>] += dp[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i+<span class="number">1</span>] == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Decode-Ways-II"><a href="#Decode-Ways-II" class="headerlink" title="Decode Ways II"></a>Decode Ways II</h3><p>接上题，如果其中有字符<code>*</code>表示<code>1-9</code>。同求字符串可能的编码方式种类</p>
<p>思路：接上题的思路，只需要讨论<code>*</code>即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span> s.length();</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span>[] dp = <span class="keyword">new</span> <span class="keyword">long</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(<span class="number">0</span>) == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            dp[<span class="number">1</span>] = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[<span class="number">1</span>] = s.charAt(<span class="number">0</span>) &lt;= <span class="string">&#x27;9&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); ++i)&#123;</span><br><span class="line">            <span class="comment">// 情况1</span></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                dp[i + <span class="number">1</span>] = <span class="number">9</span>*dp[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                dp[i + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">// 123456789</span></span><br><span class="line">                dp[i + <span class="number">1</span>] = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 情况2</span></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    dp[i + <span class="number">1</span>] += <span class="number">15</span>*dp[i-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>)==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    dp[i + <span class="number">1</span>] += <span class="number">9</span>*dp[i-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>) == <span class="string">&#x27;2&#x27;</span>)&#123;</span><br><span class="line">                    dp[i + <span class="number">1</span>] += <span class="number">6</span>*dp[i-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s.charAt(i) != <span class="string">&#x27;0&#x27;</span> &amp;&amp; s.charAt(i) &gt; <span class="string">&#x27;6&#x27;</span>)&#123;</span><br><span class="line">                        dp[i + <span class="number">1</span>] += dp[i-<span class="number">1</span>];</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123; <span class="comment">//  if(s.charAt(i) &lt;= &#x27;6&#x27;)</span></span><br><span class="line">                        dp[i + <span class="number">1</span>] += <span class="number">2</span>*dp[i-<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span>  <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>) &gt; <span class="string">&#x27;0&#x27;</span> &amp;&amp; (s.charAt(i-<span class="number">1</span>) &lt; <span class="string">&#x27;2&#x27;</span> || (s.charAt(i-<span class="number">1</span>)==<span class="string">&#x27;2&#x27;</span>&amp;&amp;s.charAt(i) &lt;= <span class="string">&#x27;6&#x27;</span>)))&#123;</span><br><span class="line">                    dp[i + <span class="number">1</span>] += dp[i-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i+<span class="number">1</span>] == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            dp[i+<span class="number">1</span>] = dp[i+<span class="number">1</span>]%<span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(dp[s.length()]%<span class="number">1000000007</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unique-Binary-Search-Trees"><a href="#Unique-Binary-Search-Trees" class="headerlink" title="Unique Binary Search Trees"></a>Unique Binary Search Trees</h3><p>求n个节点能组成多少种二叉树。</p>
<p><strong>思路一，记忆化搜索</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] memo;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> remain)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(remain &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(memo[remain] &gt; <span class="number">0</span>) <span class="keyword">return</span> memo[remain];</span><br><span class="line">    <span class="keyword">if</span>(remain &lt;= <span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; remain; ++i) &#123;</span><br><span class="line">        sum += helper(remain - i - <span class="number">1</span>)*helper(i);</span><br><span class="line">    &#125;</span><br><span class="line">    memo[remain] = sum;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    memo = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> helper(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思路2，DP</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">memo[i] : i个元素能组成多少种二叉树</span><br><span class="line"></span><br><span class="line">初始化： memo[<span class="number">0</span>] = <span class="number">1</span>, memo[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">递推公式：</span><br><span class="line"></span><br><span class="line">memo[i] = Math.sum( memo[i - q - <span class="number">1</span>] * memo[q] ) , 其中 q = [<span class="number">0</span>,i)</span><br><span class="line"></span><br><span class="line">含义： i个节点的树 = 左子树为i-q-<span class="number">1</span>个节点 * 右子树为q个节点                                                          </span><br><span class="line">                                                          </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[]memo = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        memo[<span class="number">0</span>] = <span class="number">1</span>; memo[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> q = <span class="number">0</span>; q &lt; i; ++q)&#123;</span><br><span class="line">                memo[i] += memo[i-q-<span class="number">1</span>] * memo[q];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Integer-Break"><a href="#Integer-Break" class="headerlink" title="Integer Break"></a>Integer Break</h3><p>给一个数字n，将它分解为n = a + b + …. 的形式，且<code>a*b*...</code> 的乘积最大。求这个最大乘积。</p>
<p>一开始的思路就是递归，但事实上，递归有缺点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">int</span>[] memo;</span><br><span class="line"> <span class="keyword">int</span> n;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> product)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(m &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">         max = Math.max(max, product);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 如果截止到现在n-m 的拆开乘积没有以前大，那就没有必须要继续了</span></span><br><span class="line">     <span class="keyword">if</span>(product &lt; memo[m])</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     memo[m] = product; <span class="comment">// 对于同一个m，会计算多次！</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m &amp;&amp; i &lt; n; ++i)&#123;</span><br><span class="line">         helper(m - i, product*i);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">this</span>.n = n;</span><br><span class="line">     memo = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">     helper(n, <span class="number">1</span>);</span><br><span class="line">     <span class="keyword">return</span> max;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>其实递推公式更快些，因为不会出现重复计算：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">if</span>(n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">     <span class="keyword">int</span>[] memo = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">     memo[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">     memo[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">         memo[i] = i;</span><br><span class="line">         <span class="comment">// 求i的maxProduct</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; i; ++k)&#123;</span><br><span class="line">             memo[i] = Math.max(memo[i], k * memo[i-k]);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> memo[n];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>通过这道题，我发现其实有时记忆化搜索并没有递推好使。可能是我记忆化搜索的定义有点问题！应该是求剩余m的最大乘积，然后记下来。</p>
<h3 id="Partition-Equal-Subset-Sum"><a href="#Partition-Equal-Subset-Sum" class="headerlink" title="Partition Equal Subset Sum"></a>Partition Equal Subset Sum</h3><p>给一个数组。判断这个数组能否被分为两个和相等的数组。</p>
<p>思路：既然数组的两个不相交的部分和相等，那么任意其中一部分的和都等于sum/2（其中sum为数组和）。那么只需要寻找数组的子集中是否存在和为sum/2的子集即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] memo;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> idx, <span class="keyword">int</span> targetSum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(targetSum == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(targetSum &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(idx &gt;= nums.length) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(memo[idx][targetSum] != <span class="number">0</span>) <span class="keyword">return</span> memo[idx][targetSum];</span><br><span class="line">    <span class="comment">//System.out.println(idx + &quot;\t&quot; + targetSum);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = idx; i &lt; nums.length; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(helper(nums, i + <span class="number">1</span>, targetSum - nums[i]) == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    memo[idx][targetSum] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) sum += num;</span><br><span class="line">    <span class="keyword">if</span>(sum % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    memo = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length][sum/<span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 求某一个子集的和等于sum/2即可</span></span><br><span class="line">    <span class="keyword">return</span> helper(nums, <span class="number">0</span>, sum/<span class="number">2</span>) == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>状态转移法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) sum += num;</span><br><span class="line">    <span class="keyword">if</span>(sum % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 求某一个子集的和等于sum/2即可</span></span><br><span class="line">    sum /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[][] memo = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length][sum + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; sum)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= i; ++k)&#123;</span><br><span class="line">            memo[k][nums[i]] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// memo[i][j] : [i,n)中是否存在和为j的子集</span></span><br><span class="line">    <span class="comment">// memo[i][j] = memo[i+1][j] || memo[i][j-nums[i]]</span></span><br><span class="line">    <span class="comment">// 1. 如果[i+1,n)有和为j的子集，那么[i,n)一定包含和为j的子集</span></span><br><span class="line">    <span class="comment">// 2. 否则，那么除非[i+1,n)包含和为j - nums[i]的子集</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sum; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>( i + <span class="number">1</span> &lt; nums.length)memo[i][j] = memo[i+<span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(i + <span class="number">1</span> &lt; nums.length &amp;&amp; !memo[i][j] &amp;&amp; j-nums[i] &gt; <span class="number">0</span>)memo[i][j] = memo[i+<span class="number">1</span>][j-nums[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo[<span class="number">0</span>][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Partition-to-K-Equal-Sum-Subsets"><a href="#Partition-to-K-Equal-Sum-Subsets" class="headerlink" title="Partition to K Equal Sum Subsets"></a>Partition to K Equal Sum Subsets</h3><p>上题的follow up : 给一个数组，判断这个数组能否被分成k个和相等的子集。</p>
<p>思路：dfs + 回溯 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span>[] visited;</span><br><span class="line"><span class="keyword">int</span> targetOriginal;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> idx, <span class="keyword">int</span> k, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, k - <span class="number">1</span>, targetOriginal);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(target &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">// 回溯</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = idx; i &lt; nums.length; ++i)&#123; <span class="comment">// 注意这个从idx开始。因为在同一个k中，我们没有必要再次遍历之前的东西</span></span><br><span class="line">        <span class="keyword">if</span>(visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        visited[i] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(helper(nums, i + <span class="number">1</span>,k, target - nums[i]))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        visited[i] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) sum += num;</span><br><span class="line">    <span class="keyword">if</span>(sum % k != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">    targetOriginal = sum/k;</span><br><span class="line">    <span class="keyword">return</span> helper(nums, <span class="number">0</span>, k, targetOriginal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Largest-Divisible-Subset"><a href="#Largest-Divisible-Subset" class="headerlink" title="Largest Divisible Subset"></a>Largest Divisible Subset</h3><p>给一个数组，求数组的一个最长集合：集合中每个元素都能互相整除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">largestDivisibleSubset</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        List&lt;Integer&gt;[] memoList = <span class="keyword">new</span> List[nums.length];</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            memoList[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            memoList[i].add(nums[i]);</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> longestJdx = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] % nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// i能被比它大的数整除</span></span><br><span class="line">                    <span class="keyword">if</span>(dp[j] + <span class="number">1</span> &gt; dp[i])&#123;</span><br><span class="line">                        dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                        longestJdx = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(longestJdx &gt; i)&#123;</span><br><span class="line">                memoList[i].addAll(memoList[longestJdx]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; max)&#123;</span><br><span class="line">                result = memoList[i];</span><br><span class="line">                max = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="单序列型动态规划"><a href="#单序列型动态规划" class="headerlink" title="单序列型动态规划"></a>单序列型动态规划</h2><p><strong>状态</strong>：<code>f[i]</code>表示<strong>前i个</strong>位置/数字/字符，第i个…</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   前i个位置</span><br><span class="line">|-------------|</span><br><span class="line">|<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,...,i|...,n</span><br><span class="line">|-------------|</span><br></pre></td></tr></table></figure>

<p><strong>方程</strong>：<code>f[i] = f[j]</code>…,j是i之前的一个位置</p>
<p><strong>初始化</strong>：<code>f[0]</code>…</p>
<p><strong>答案</strong>：<code>f[n]</code>…</p>
<p>一般answer是<code>f[n]</code>而不是<code>f[n-1]</code>：因为对于n个字符，包含前0个字符（空串）、前1个字符、…、前n个字符</p>
<p>因此<code>f[]</code>一般都要开<code>n+1</code>个</p>
<h3 id="例题1，Word-Break"><a href="#例题1，Word-Break" class="headerlink" title="例题1，Word Break"></a>例题1，Word Break</h3><p>给一个词<code>lintcode</code>，和一个字典<code>dict=[&quot;lint&quot;,&quot;code&quot;]</code>，这个词能不能被词拆分成词典中的词→<code>lint code</code></p>
<p>暴力方法：递归搜索复杂度→$2^n$</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">状态：f[i]表示前i个字符能不能被切成dict中的词</span><br><span class="line">  </span><br><span class="line">^表示字符串开始</span><br><span class="line"></span><br><span class="line">idx → <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span></span><br><span class="line">f   → <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> ← <span class="number">1</span>=<span class="keyword">true</span>,<span class="number">0</span>=<span class="keyword">false</span></span><br><span class="line">s   → ^ l i n t c o d e</span><br><span class="line"></span><br><span class="line">计算步骤：</span><br><span class="line">i = <span class="number">4</span>,lint: </span><br><span class="line">lin + t -&gt; ×</span><br><span class="line">li  + nt -&gt; ×</span><br><span class="line">l   + <span class="keyword">int</span> -&gt; ×</span><br><span class="line"><span class="string">&#x27;&#x27;</span>  + lint -&gt; √</span><br><span class="line"></span><br><span class="line">i = <span class="number">8</span>,lintcode：</span><br><span class="line">lintcod + e</span><br><span class="line">lintco + de</span><br><span class="line">lintc + ode</span><br><span class="line">lint + code -&gt; √</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">|=======前i个位置=======|</span><br><span class="line">  </span><br><span class="line">|------------|---------|</span><br><span class="line">|<span class="number">1</span>,<span class="number">2</span>,......,j|j+<span class="number">1</span>,...,i|</span><br><span class="line">|------------|---------|</span><br><span class="line"> 在j位置切一刀，如果<span class="number">1</span>~j能被完美切分，那<span class="number">1</span>~i就取决于j+<span class="number">1</span>~j能不能被完美切分</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++i )&#123;</span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i ; ++j )&#123;</span><br><span class="line">  <span class="comment">// s[j~i]的操作是O(n)的！</span></span><br><span class="line">  <span class="comment">// in dict操作也是O(n)的！因为是单词的hash表，要依次比较的哇</span></span><br><span class="line">  <span class="keyword">if</span>(f[j] &amp;&amp; s[j~i] in dict )&#123;</span><br><span class="line">  		f[i] = <span class="keyword">true</span>;</span><br><span class="line">  		<span class="keyword">break</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>时间复杂度：$O(n^3)$</p>
<p><strong>优化</strong></p>
<p>利用单词平均长度（单词不会很长）– L ,从后往前哇！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">4</span>,lint: </span><br><span class="line"><span class="string">&#x27;&#x27;</span>  + lint -&gt; √</span><br><span class="line"></span><br><span class="line">i = <span class="number">8</span>,lintcode：</span><br><span class="line">l + intcode</span><br><span class="line">li + ntcode</span><br><span class="line">lin + tcode</span><br><span class="line">lint + code -&gt; √</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++i )&#123;</span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">int</span> j = i-<span class="number">1</span>; j &gt;= <span class="number">0</span> ; --j )&#123;</span><br><span class="line">  <span class="keyword">if</span>(f[j] &amp;&amp; s[j~i] in dict )&#123;</span><br><span class="line">  		f[i] = <span class="keyword">true</span>;</span><br><span class="line">  		<span class="keyword">break</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n：词长度</span><br><span class="line">m：词典单词个数</span><br><span class="line">L：单词平均长度</span><br></pre></td></tr></table></figure>

<p>时间复杂度：$O(n\times L^2 + m)$</p>
<p>最终我采用的方案是：用trie给dict建树，搜索时从后往前搜索</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        Node[] children;</span><br><span class="line">        <span class="keyword">boolean</span> hasWord;</span><br><span class="line">        Node()&#123;</span><br><span class="line">            children = <span class="keyword">new</span> Node[<span class="number">26</span>];</span><br><span class="line">            hasWord = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span></span>&#123;</span><br><span class="line">  Node root;</span><br><span class="line">  Trie()&#123;</span><br><span class="line">    root = <span class="keyword">new</span> Node();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加节点</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    Node r = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">char</span> c : s.toCharArray() )&#123;</span><br><span class="line">      index = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">null</span> == r.children[index])&#123;</span><br><span class="line">        r.children[index] = <span class="keyword">new</span> Node();</span><br><span class="line">      &#125;</span><br><span class="line">      r = r.children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    r.hasWord = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//优化后的搜索</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">char</span>[] s,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    Node r = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">int</span> index,count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start ; i &lt; end ; ++i )&#123;</span><br><span class="line">      index = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">      <span class="keyword">if</span>( <span class="keyword">null</span> == r.children[index] )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        r = r.children[index];</span><br><span class="line">        ++count;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> res = count == end - start &amp;&amp; r.hasWord;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">  <span class="keyword">int</span> n = c.length;</span><br><span class="line">  <span class="comment">// 为wordDict建立trie树</span></span><br><span class="line">  Trie trie = <span class="keyword">new</span> Trie();</span><br><span class="line">  <span class="keyword">for</span>( String w : wordDict )&#123;</span><br><span class="line">    trie.add(w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//状态f[i]:单词0~i是否能被break</span></span><br><span class="line">  <span class="keyword">boolean</span>[] f = <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">  <span class="comment">//初始化</span></span><br><span class="line">  f[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">//dp</span></span><br><span class="line">  <span class="keyword">int</span> i,j;</span><br><span class="line">  <span class="comment">//O(N*L*L)</span></span><br><span class="line">  <span class="keyword">for</span>( i = <span class="number">1</span> ; i &lt;= n ; ++i )&#123; <span class="comment">// O(N) </span></span><br><span class="line">    <span class="keyword">for</span>( j = i ; j &gt;= <span class="number">0</span> ; --j )&#123;<span class="comment">//从后往前搜索,O(L)</span></span><br><span class="line">      <span class="keyword">if</span>( f[j] &amp;&amp; trie.search(c,j,i) )&#123;<span class="comment">//O(L)</span></span><br><span class="line">        f[i] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="例题2，Palindrome-Partitioning-II"><a href="#例题2，Palindrome-Partitioning-II" class="headerlink" title="例题2，Palindrome Partitioning II"></a>例题2，Palindrome Partitioning II</h3><p>一个str最少被切割几次可以切割为都是回文串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">f[i]:前i个字母，最少被切割几次可以切割为都是回文串</span><br><span class="line"></span><br><span class="line">|=======前i个位置=======|</span><br><span class="line">  </span><br><span class="line">|------------|---------|</span><br><span class="line">|<span class="number">1</span>,<span class="number">2</span>,......,j|j+<span class="number">1</span>,...,i|</span><br><span class="line">|------------|---------|</span><br><span class="line"></span><br><span class="line"> 找到一个j，使得<span class="number">1</span>~j是回文串，且j+<span class="number">1</span>~i能被分割为回文串。则f[i] = f[j] + <span class="number">1</span></span><br><span class="line">  </span><br><span class="line"> 遍历j，使得f[i] = min( f[j] + <span class="number">1</span> ) </span><br><span class="line">  </span><br><span class="line">f[<span class="number">0</span>]  = -<span class="number">1</span> <span class="comment">// 原因，f[0]代表空串，为了抵消空串和真正串的1</span></span><br><span class="line"><span class="comment">// 例如&quot;aba&quot;,被切成&quot;aba&quot;+&quot;&quot;，即f[aba] = 1 + f[0]，但它应该等于0.所以我们定义f[0] = -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= s.length ; ++i )&#123;</span><br><span class="line">  f[i] = Integer.MAX_VALUE; <span class="comment">//其实也可以是i-1</span></span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; i ; ++j )&#123;</span><br><span class="line">    <span class="keyword">if</span>( s[j~i] is Palindrome )&#123;</span><br><span class="line">      f[i] = Math.min( f[i], f[j] + <span class="number">1</span> )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">代码：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] ifPalindrome;</span><br><span class="line">    <span class="keyword">int</span>[] min;</span><br><span class="line">    <span class="comment">//判断i~j是否是回文串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Palindrome</span><span class="params">(<span class="keyword">char</span>[] c,<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( ifPalindrome[i][j] &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> ifPalindrome[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( i == j )&#123;</span><br><span class="line">            ifPalindrome[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( c[i] == c[j] )&#123;</span><br><span class="line">            <span class="keyword">if</span>( j - i &lt; <span class="number">3</span> )&#123;</span><br><span class="line">                ifPalindrome[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ifPalindrome[i][j] = ifPalindrome[i+<span class="number">1</span>][j-<span class="number">1</span>] ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ifPalindrome[i][j] = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ifPalindrome[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dp递归</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cut</span><span class="params">(<span class="keyword">char</span>[] c,<span class="keyword">int</span> idx, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( idx &gt;= n ) &#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>( min[idx] &gt; <span class="number">0</span> )&#123; <span class="keyword">return</span> min[idx];&#125;</span><br><span class="line">        <span class="comment">/** idx ....,j,....,n</span></span><br><span class="line"><span class="comment">         * 如果idx~j是回文，则从j切一刀，[i~n] = 1 + [j~n]**/</span></span><br><span class="line">        min[idx] = n;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = idx ; j &lt; n ; ++j )&#123;</span><br><span class="line">            <span class="keyword">if</span>( Palindrome(c,idx,j) == <span class="number">1</span> )&#123;</span><br><span class="line">                min[idx] = Math.min( <span class="number">1</span> + cut( c, j+<span class="number">1</span>, n ), min[idx] );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//主函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCut</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span>( n &lt;= <span class="number">1</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        min = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        ifPalindrome = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> res =  cut(c,<span class="number">0</span>,n);</span><br><span class="line">        <span class="keyword">return</span> res-<span class="number">1</span>; <span class="comment">// 因为到末尾的时候也切了一刀，这一刀没有必要！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>另一种思路</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[i] : 前i个字符，最少可以被切为几个回文串</span><br></pre></td></tr></table></figure>

<p><strong>优化</strong>：判断i~j是否是回文串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">i,i+<span class="number">1.</span>........,j-<span class="number">1</span>,j 是回文串，则</span><br><span class="line">i,i+<span class="number">1</span>,........,j-<span class="number">1</span>   是回文串</span><br><span class="line"></span><br><span class="line">这是一种区间型DP，或者说是一种递推</span><br></pre></td></tr></table></figure>

<h3 id="Palindromic-Substrings"><a href="#Palindromic-Substrings" class="headerlink" title="Palindromic Substrings"></a>Palindromic Substrings</h3><p>输出一个字符串所有的回文子串的个数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;aaa&quot;</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Six palindromic strings: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;.</span><br></pre></td></tr></table></figure>

<p>我的思路非常暴力：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> str -&gt; <span class="keyword">char</span>[] c</span><br><span class="line"><span class="number">2.</span> 定义<span class="keyword">int</span>[][] ifPalindromic -&gt; ifPalindromic[i][j] = <span class="number">1</span>-&gt;是回文串，<span class="number">2</span>-&gt;不是</span><br><span class="line"><span class="number">3.</span> <span class="keyword">if</span> c[i] == c[j]&#123; <span class="comment">// i~j可能是回文串</span></span><br><span class="line">	ifPalindromic = Palindromic[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">4.</span> <span class="keyword">else</span>:</span><br><span class="line">	<span class="comment">//考察i~j-1和i+1~j</span></span><br><span class="line">   ifPalindromic[i+<span class="number">1</span>][j] = Palindromic(c,i+<span class="number">1</span>,j);</span><br><span class="line">   ifPalindromic[i][j-<span class="number">1</span>] = Palindromic(c,i,j-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">代码：</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] ifPalindromic;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//计数器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断start~end是不是回文串</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">Palindromic</span><span class="params">(<span class="keyword">char</span>[] c, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>( start &gt;= end )<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>( ifPalindromic[start][end] &gt; <span class="number">0</span> )<span class="keyword">return</span> ifPalindromic[start][end];</span><br><span class="line">  <span class="keyword">if</span>( c[start] == c[end] )&#123;</span><br><span class="line">    ifPalindromic[start][end] = Palindromic(c,start+<span class="number">1</span>,end-<span class="number">1</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ifPalindromic[start][end] = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(start+<span class="number">1</span>&lt;end)ifPalindromic[start+<span class="number">1</span>][end] = Palindromic(c,start+<span class="number">1</span>,end);</span><br><span class="line">  <span class="keyword">if</span>(start&lt;end-<span class="number">1</span>)ifPalindromic[start][end-<span class="number">1</span>] = Palindromic(c,start,end-<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span>( ifPalindromic[start][end] == <span class="number">1</span> )&#123;</span><br><span class="line">    ++count;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ifPalindromic[start][end];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">  <span class="keyword">int</span> n = c.length;</span><br><span class="line">  <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">  ifPalindromic = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">  <span class="comment">// 1 -&gt; true</span></span><br><span class="line">  <span class="comment">// 2 -&gt; false</span></span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++i )&#123;</span><br><span class="line">    ifPalindromic[i][i] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Palindromic(c,<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> count+n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面这种思路用自底向上的方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">若    ,i+<span class="number">1</span>,...,j-<span class="number">1</span>,     是回文串 , 且c[i] == c[j]</span><br><span class="line">则   i,...........,j    是回文串</span><br><span class="line"></span><br><span class="line">计算过程为</span><br><span class="line"></span><br><span class="line">i是从大到小的</span><br><span class="line">j是从i到n的</span><br><span class="line"></span><br><span class="line">因为[i+<span class="number">1</span>][...]已经算过了</span><br><span class="line">因此[i][j] = ...[i+<span class="number">1</span>][j-<span class="number">1</span>]肯定能算出来</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">            dp[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt; <span class="number">3</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j]) ++res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>其实还有一种更暴力，更简单的解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123; <span class="comment">// i是回文串的中点</span></span><br><span class="line">    extendPalindrome(s, i, i); <span class="comment">//奇数长度</span></span><br><span class="line">    extendPalindrome(s, i, i + <span class="number">1</span>); <span class="comment">//偶数长度</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">extendPalindrome</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (left &gt;=<span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">    count++; left--; right++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="House-Robber"><a href="#House-Robber" class="headerlink" title="House Robber"></a>House Robber</h3><p>给一个数组<code>int[] nums</code>，表示每个商店的价值。要抢劫，但抢劫时必须至少隔一个商铺抢。问能抢到的最大价值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( nums.length == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//状态f[i]：前i家最大价值</span></span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        f[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//DP</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; nums.length ; ++i )&#123;</span><br><span class="line">            f[i+<span class="number">1</span>] = Math.max(f[i],f[i-<span class="number">1</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[nums.length];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="House-Robber-II"><a href="#House-Robber-II" class="headerlink" title="House Robber II"></a>House Robber II</h3><p>给一个数组<code>int[] nums</code>，表示每个商店的价值。商店是成环的，即首尾相接。要抢劫，但抢劫时必须至少隔一个商铺抢。问能抢到的最大价值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">其实成环的商店如果去掉首/尾某个的话，就不成环了，就变成了上一题。</span><br><span class="line">  <span class="number">1</span> <span class="number">3</span> 	</span><br><span class="line"><span class="number">5</span>     <span class="number">4</span></span><br><span class="line">  <span class="number">2</span> <span class="number">6</span></span><br><span class="line">  </span><br><span class="line">例如这个环，</span><br><span class="line">假设肯定不抢<span class="number">1</span>：变成了[<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">假设肯定不抢<span class="number">5</span>：变成了[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<h3 id="House-Robber-III"><a href="#House-Robber-III" class="headerlink" title="House Robber III"></a>House Robber III</h3><p>商店变成了一个二叉树</p>
<p><strong>思路一，hash表</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;TreeNode, <span class="keyword">int</span>[]&gt; memo = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// key : 节点</span></span><br><span class="line">    <span class="comment">// value[0] = 不抢的max，value[1] = 抢的max</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">boolean</span> robed)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!memo.containsKey(root))&#123;</span><br><span class="line">            memo.put(root, <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>]);</span><br><span class="line">            memo.get(root)[<span class="number">0</span>] = dfs(root.left, <span class="keyword">false</span>) + dfs(root.right, <span class="keyword">false</span>);</span><br><span class="line">            memo.get(root)[<span class="number">1</span>] = root.val + dfs(root.left, <span class="keyword">true</span>) + dfs(root.right, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(robed)&#123; <span class="comment">// 上一轮抢了,这一轮只能不抢</span></span><br><span class="line">            <span class="keyword">return</span> memo.get(root)[<span class="number">0</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//上一轮没抢，这次随意</span></span><br><span class="line">            <span class="keyword">return</span> Math.max(memo.get(root)[<span class="number">0</span>], memo.get(root)[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dfs(root, <span class="keyword">true</span>), dfs(root, <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>思路2，优化</strong></p>
<p>其实只需要用到本状态和上一状态，并不需要hash表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] result = help(root); <span class="comment">//return int[]&#123;with root, without root&#125;</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(result[<span class="number">0</span>], result[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] help(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] left = help(root.left);</span><br><span class="line">    <span class="keyword">int</span>[] right = help(root.right);</span><br><span class="line">    <span class="comment">//with root</span></span><br><span class="line">    <span class="keyword">int</span> with = root.val + left[<span class="number">1</span>] + right[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> without = left[<span class="number">0</span>] + right[<span class="number">0</span>];</span><br><span class="line">    with = Math.max(with, without);</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;with, without&#125;;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Maximal-Square"><a href="#Maximal-Square" class="headerlink" title="Maximal Square"></a>Maximal Square</h3><p>给一个0/1矩阵。找到最大全1方阵，返回方阵元素个数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0  </span><br><span class="line"></span><br><span class="line">-&gt; return 4</span><br></pre></td></tr></table></figure>

<p>这道题我使用了一种较笨的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">count[i][j] : 当前格子的左上角有多少行/列全<span class="number">1</span>方阵</span><br><span class="line"></span><br><span class="line">[i,j]</span><br><span class="line">x x x x          x</span><br><span class="line">x x x x          x</span><br><span class="line">x x x x          x</span><br><span class="line">x x x c[i-<span class="number">1</span>,j-<span class="number">1</span>] x</span><br><span class="line">x x x x          <span class="number">1</span> &lt;- [i,j]</span><br><span class="line"></span><br><span class="line">如果 c[i-<span class="number">1</span>,j-<span class="number">1</span>] == <span class="number">1</span>，那必须是以下这样时，c[i,j] = <span class="number">1</span> + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">x x x x x</span><br><span class="line">x x x x x</span><br><span class="line">x x x x x</span><br><span class="line">x x x <span class="number">1</span> <span class="number">1</span></span><br><span class="line">x x x <span class="number">1</span> <span class="number">1</span> &lt;- [i,j]</span><br><span class="line"></span><br><span class="line">如果 c[i-<span class="number">1</span>,j-<span class="number">1</span>] == <span class="number">2</span>，那必须是以下这样时，c[i,j] = <span class="number">1</span> + <span class="number">2</span> = <span class="number">3</span></span><br><span class="line">x x x x x</span><br><span class="line">x x x x x</span><br><span class="line">x x x x <span class="number">1</span></span><br><span class="line">x x x <span class="number">1</span> <span class="number">1</span></span><br><span class="line">x x <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> &lt;- [i,j]</span><br><span class="line"></span><br><span class="line">或者这样，c[i,j] = <span class="number">1</span> + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">x x x x x</span><br><span class="line">x x x x x</span><br><span class="line">x x x x <span class="number">0</span></span><br><span class="line">x x x <span class="number">1</span> <span class="number">1</span></span><br><span class="line">x x <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> &lt;- [i,j]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span> )<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] counter = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; matrix.length ; ++i )&#123;</span><br><span class="line">            counter[i][<span class="number">0</span>] = (<span class="keyword">int</span>) matrix[i][<span class="number">0</span>] - <span class="number">48</span>;</span><br><span class="line">            max = Math.max(max,counter[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; matrix[<span class="number">0</span>].length ; ++j )&#123;</span><br><span class="line">            counter[<span class="number">0</span>][j] = (<span class="keyword">int</span>) matrix[<span class="number">0</span>][j] - <span class="number">48</span>;</span><br><span class="line">            max = Math.max(max,counter[<span class="number">0</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k,q;</span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">1</span> ; i &lt; matrix.length ; ++i )&#123;</span><br><span class="line">            <span class="keyword">for</span>( j = <span class="number">1</span>; j &lt; matrix[i].length ; ++j )&#123;</span><br><span class="line">                <span class="keyword">if</span>( matrix[i][j] == <span class="string">&#x27;0&#x27;</span> ) <span class="keyword">continue</span>;</span><br><span class="line">                counter[i][j] = <span class="number">1</span>;</span><br><span class="line">                k = counter[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span>( q = <span class="number">1</span> ; q &lt;= k ; ++q )&#123;</span><br><span class="line">                    <span class="keyword">if</span>( matrix[i-q][j] != <span class="string">&#x27;1&#x27;</span> || matrix[i][j-q] !=<span class="string">&#x27;1&#x27;</span> )&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        counter[i][j] += <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                max = Math.max(max, counter[i][j]);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max*max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>事实上，有一种非常非常机智的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                size[i][j] = min(size[i - <span class="number">1</span>][j - <span class="number">1</span>], min(size[i - <span class="number">1</span>][j], size[i][j - <span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">                maxsize = max(maxsize, size[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>还有一种更机智的方法。由于<code>f[i][j]</code>只和前3个结果相关</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f[i - <span class="number">1</span>][j - <span class="number">1</span>]    f[i][j - <span class="number">1</span>]</span><br><span class="line">f[i - <span class="number">1</span>][j]        f[i][j]　　</span><br></pre></td></tr></table></figure>

<p>故只需要保留一个2行的数组！！！<br>列上不能优化，因为2重循环的时候 下列的时候依赖于上列的结果，上列的结果需要保存到计算下列的时候用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> ans;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">2</span>;  </span><br><span class="line">    <span class="keyword">int</span> m = matrix[<span class="number">0</span>].length;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 状态  </span></span><br><span class="line">    <span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];   <span class="comment">// 2行，m列</span></span><br><span class="line">    <span class="comment">// 初始化  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  </span><br><span class="line">        f[i][<span class="number">0</span>] = matrix[i][<span class="number">0</span>];  </span><br><span class="line">        ans = Math.max(f[i][<span class="number">0</span>], ans);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;  </span><br><span class="line">        f[<span class="number">0</span>][i] = matrix[<span class="number">0</span>][i];  </span><br><span class="line">        ans = Math.max(f[<span class="number">0</span>][i], ans);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 方程  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; matrix.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; j++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">1</span>) &#123;  </span><br><span class="line">                f[i%<span class="number">2</span>][j] = Math.min(Math.min(f[(i-<span class="number">1</span>)%<span class="number">2</span>][j-<span class="number">1</span>], f[i%<span class="number">2</span>][j-<span class="number">1</span>]), f[(i-<span class="number">1</span>)%<span class="number">2</span>][j]) + <span class="number">1</span>;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                f[i%<span class="number">2</span>][j] = <span class="number">0</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            ans = Math.max(ans, f[i%<span class="number">2</span>][j]);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 结果  </span></span><br><span class="line">    <span class="keyword">return</span> ans * ans;  </span><br></pre></td></tr></table></figure>

<h3 id="Paint-House"><a href="#Paint-House" class="headerlink" title="Paint House"></a>Paint House</h3><p>给一个二维数组<code>cost[][]</code>，大小为n×3。其中<code>cost[i][q]</code>表示第i个房子涂上第q种颜色时的造价。一共有3种颜色。要求两个相邻房子不可以同色。求涂色最小造价</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">0</span>,<span class="number">1</span>,...,|i-<span class="number">1</span>| i |,.....</span><br><span class="line">        |   | g |</span><br><span class="line">        | r | b |</span><br><span class="line">        ---------</span><br><span class="line">        | g | r |</span><br><span class="line">        |   | b |</span><br><span class="line">        ---------</span><br><span class="line">        | b | r |</span><br><span class="line">        |   | g |</span><br><span class="line"></span><br><span class="line">如上图所示，涂第i个房子的时候，取决于第i-<span class="number">1</span>个房子是什么颜色</span><br><span class="line"></span><br><span class="line">而第<span class="number">0</span>~i个房子的总最小造价，一定是第i个房子涂r/g/b颜色时的最小值</span><br><span class="line"></span><br><span class="line">那我们可以假设我们已知第i-<span class="number">1</span>个房子涂r/g/b时最小造价，就可以推出第i个房子涂r/g/b时最小造价</span><br><span class="line"></span><br><span class="line">total[i][q] = Math.min(</span><br><span class="line">  				total[i-<span class="number">1</span>][<span class="number">0</span>] + cost[i][<span class="number">1</span>],</span><br><span class="line">  				total[i-<span class="number">1</span>][<span class="number">0</span>] + cost[i][<span class="number">2</span>],</span><br><span class="line">  </span><br><span class="line">  				total[i-<span class="number">1</span>][<span class="number">1</span>] + cost[i][<span class="number">2</span>],</span><br><span class="line">  				total[i-<span class="number">1</span>][<span class="number">1</span>] + cost[i][<span class="number">0</span>],</span><br><span class="line">  </span><br><span class="line">  				total[i-<span class="number">1</span>][<span class="number">2</span>] + cost[i][<span class="number">0</span>],</span><br><span class="line">  				total[i-<span class="number">1</span>][<span class="number">2</span>] + cost[i][<span class="number">1</span>]</span><br><span class="line">					)</span><br><span class="line">  </span><br><span class="line">将上面这个式子换一种形式：</span><br><span class="line">total[i][q] = Math.min(</span><br><span class="line">  Math.min(</span><br><span class="line">    total[i-<span class="number">1</span>][<span class="number">1</span>] + cost[i][<span class="number">0</span>], --&gt; 第i个房子颜色为<span class="number">0</span>的min</span><br><span class="line">  	total[i-<span class="number">1</span>][<span class="number">2</span>] + cost[i][<span class="number">0</span>]), </span><br><span class="line"></span><br><span class="line">  Math.min(</span><br><span class="line">    total[i-<span class="number">1</span>][<span class="number">0</span>] + cost[i][<span class="number">1</span>], --&gt; 第i个房子颜色为<span class="number">1</span>的min</span><br><span class="line">  	total[i-<span class="number">1</span>][<span class="number">2</span>] + cost[i][<span class="number">1</span>]), --&gt;</span><br><span class="line"></span><br><span class="line">  Math.min(</span><br><span class="line">    total[i-<span class="number">1</span>][<span class="number">0</span>] + cost[i][<span class="number">2</span>], --&gt; 第i个房子颜色为<span class="number">2</span>的min</span><br><span class="line">  	total[i-<span class="number">1</span>][<span class="number">1</span>] + cost[i][<span class="number">2</span>])  --&gt;</span><br><span class="line">					)</span><br><span class="line"></span><br><span class="line">  实现：</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span>[][] costs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>( costs.length == <span class="number">0</span> || costs[<span class="number">0</span>].length == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//状态total[i][q]表示第i个房子在涂第q种颜色时，前i个房子的的最小cost</span></span><br><span class="line">  <span class="comment">// 0 -&gt; red</span></span><br><span class="line">  <span class="comment">// 1 -&gt; blue</span></span><br><span class="line">  <span class="comment">// 2 -&gt; green</span></span><br><span class="line">  <span class="keyword">int</span> n = costs.length;</span><br><span class="line">  <span class="keyword">int</span>[][] total = <span class="keyword">new</span> <span class="keyword">int</span>[n][costs[<span class="number">0</span>].length];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> q = <span class="number">0</span> ; q &lt; <span class="number">3</span> ; ++q )&#123;</span><br><span class="line">    total[<span class="number">0</span>][q] = costs[<span class="number">0</span>][q];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++i )&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> q = <span class="number">0</span> ; q &lt; <span class="number">3</span> ; ++q )&#123;</span><br><span class="line">      total[i][q] = Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//dp</span></span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++i )&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> q = <span class="number">0</span> ; q &lt; <span class="number">3</span> ; ++q )&#123;</span><br><span class="line">      total[i][q] = Math.min(total[i][q],costs[i][q] + total[i-<span class="number">1</span>][(q+<span class="number">1</span>)%<span class="number">3</span>]);</span><br><span class="line">      total[i][q] = Math.min(total[i][q],costs[i][q] + total[i-<span class="number">1</span>][(q+<span class="number">2</span>)%<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  n -= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> res = Math.min(total[n][<span class="number">0</span>],total[n][<span class="number">1</span>]);</span><br><span class="line">  res =Math.min(res,total[n][<span class="number">2</span>]);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个空间复杂度是$O(n)$,时间复杂度是$O(n)$。其实还有优化方法，将空间复杂度降为$O(1)$：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span>[][] costs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(costs==<span class="keyword">null</span>||costs.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;costs.length; i++)&#123;</span><br><span class="line">        costs[i][<span class="number">0</span>] += Math.min(costs[i-<span class="number">1</span>][<span class="number">1</span>],costs[i-<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">        costs[i][<span class="number">1</span>] += Math.min(costs[i-<span class="number">1</span>][<span class="number">0</span>],costs[i-<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">        costs[i][<span class="number">2</span>] += Math.min(costs[i-<span class="number">1</span>][<span class="number">1</span>],costs[i-<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = costs.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.min(Math.min(costs[n][<span class="number">0</span>], costs[n][<span class="number">1</span>]), costs[n][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Target-Sum"><a href="#Target-Sum" class="headerlink" title="Target Sum"></a>Target Sum</h3><p>给一个数组和一个target。求数组的每个元素的正、负和等于target的个数。</p>
<p><strong>思路一，递归memo</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] dp;</span><br><span class="line">	<span class="comment">// dp[idx][sum + 1000] : 前idx个数字的和为sum时，最终和为S的个数</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> idx, <span class="keyword">int</span> S, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(idx == nums.length)&#123;</span><br><span class="line">           <span class="keyword">if</span>(S == sum) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(dp[idx][<span class="number">1000</span>+sum] &gt; <span class="number">0</span>) <span class="keyword">return</span> dp[idx][<span class="number">1000</span>+sum];</span><br><span class="line">       dp[idx][<span class="number">1000</span>+sum] = helper(nums, idx + <span class="number">1</span>, S, sum + nums[idx]) +</span><br><span class="line">               helper(nums, idx + <span class="number">1</span>, S, sum - nums[idx]);</span><br><span class="line">       <span class="keyword">return</span> dp[idx][<span class="number">1000</span>+sum];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">       dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length][<span class="number">2001</span>];</span><br><span class="line">       <span class="keyword">return</span> helper(nums, <span class="number">0</span>, S, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>思路2，非递归memo</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果S过大或过小，大于所有数字的和，或小于所有数字的最小和，那就gg</span></span><br><span class="line">    <span class="keyword">int</span> allSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> e : nums) allSum += e;</span><br><span class="line">    <span class="keyword">if</span>(S &gt; allSum || S &lt; -allSum)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>][<span class="number">2001</span>];</span><br><span class="line">    <span class="comment">// dp[idx][sum + 1000] : 前idx个数字(不含)的和为sum时，最终和为S的个数</span></span><br><span class="line">    <span class="comment">//初始化,0个数字时</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1000</span> + <span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//dp</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> idx = <span class="number">1</span>; idx &lt;= nums.length; ++idx )&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> sum = <span class="number">0</span>; sum &lt;<span class="number">2001</span>; ++sum)&#123; <span class="comment">// 这个循环我没想出来！</span></span><br><span class="line">            <span class="keyword">if</span>(dp[idx-<span class="number">1</span>][sum] != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                sum + nums[idx-<span class="number">1</span>] &lt; <span class="number">2001</span> &amp;&amp;</span><br><span class="line">                sum - nums[idx-<span class="number">1</span>] &lt; <span class="number">2001</span>) &#123;</span><br><span class="line">                dp[idx][sum + nums[idx-<span class="number">1</span>]] += dp[idx - <span class="number">1</span>][sum];</span><br><span class="line">                dp[idx][sum - nums[idx-<span class="number">1</span>]] += dp[idx - <span class="number">1</span>][sum];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nums.length][<span class="number">1000</span> + S];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优化思路2</strong></p>
<p>由于只会用到前一状态的dp。因此可以简化维度：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果S过大，大于所有数字的和，那就gg</span></span><br><span class="line">        <span class="keyword">int</span> allSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e : nums) allSum += e;</span><br><span class="line">        <span class="keyword">if</span>(S &gt; allSum || S &lt; -allSum)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] last = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2001</span>];</span><br><span class="line">        <span class="comment">//初始化,0个数字时</span></span><br><span class="line">        last[<span class="number">1000</span> + <span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//dp</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idx = <span class="number">1</span>; idx &lt;= nums.length; ++idx )&#123;</span><br><span class="line">            <span class="keyword">int</span>[] curr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2001</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> sum = <span class="number">0</span>; sum &lt;<span class="number">2001</span>; ++sum)&#123;</span><br><span class="line">                <span class="keyword">if</span>(last[sum] != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    sum + nums[idx-<span class="number">1</span>] &lt; <span class="number">2001</span> &amp;&amp;</span><br><span class="line">                    sum - nums[idx-<span class="number">1</span>] &lt; <span class="number">2001</span>) &#123;</span><br><span class="line">                    curr[sum + nums[idx-<span class="number">1</span>]] += last[sum];</span><br><span class="line">                    curr[sum - nums[idx-<span class="number">1</span>]] += last[sum];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            last = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last[<span class="number">1000</span> + S];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="硬币组合问题"><a href="#硬币组合问题" class="headerlink" title="硬币组合问题"></a>硬币组合问题</h3><p>有数量不限的硬币，币值为25分、10分、5分和1分，请编写代码计算n分有几种表示法。</p>
<p>给定一个int <strong>n</strong>，请返回n分有几种表示法。保证n小于等于100000，为了防止溢出，请将答案Mod 1000000007。</p>
<p>我一开始的思路复杂度非常高。</p>
<p>看看这个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">链接：https:<span class="comment">//www.nowcoder.com/questionTerminal/c0503ca0a12d4256af33fce2712d7b24</span></span><br><span class="line">来源：牛客网</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维dp</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[A.length][n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// dp[i][j] : 前i个硬币构成j分钱的种类数目</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化，一分钱硬币构成每一个都是1种</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = j - A[i];</span><br><span class="line">            <span class="keyword">if</span> (t &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 注意这里是i-1</span></span><br><span class="line">                <span class="comment">// dp[i-1][j]: j分钱使用前i-1种的表示方法 -- 意思是本次不用第i枚硬币</span></span><br><span class="line">                <span class="comment">// dp[i][t]:   j - A[i] 分钱使用前i种硬币的表示方法 -- 意思是本次使用第i枚硬币至少一次（而dp[i][t]中已经包含了两次的）</span></span><br><span class="line">                dp[i][j] = (dp[i - <span class="number">1</span>][j] + dp[i][t]) % <span class="number">1000000007</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> dp[A.length - <span class="number">1</span>][n];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//一维dp</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>], i, A[] = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, dp[<span class="number">0</span>] = <span class="number">1</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = A[i]; j &lt;= n; j++) &#123;</span><br><span class="line">            dp[j] = (dp[j] + dp[j - A[i]]) % <span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="双序列动态规划"><a href="#双序列动态规划" class="headerlink" title="双序列动态规划"></a>双序列动态规划</h2><p>给了两个串，研究两个串之间的关系</p>
<p><strong>状态</strong>：<code>f[i][j]</code>代表第一个sequence的前i个数字/字符，配上第二个sequence的前j个…</p>
<p><strong>方程</strong>：<code>f[i][j]</code>=研究第i和第j之间的匹配关系</p>
<p><strong>初始化</strong>：<code>f[i][0]</code>和<code>f[0][i]</code></p>
<p><strong>答案</strong>：<code>f[n][m]</code></p>
<p>n = s1.length()</p>
<p>m = s2.length()</p>
<h3 id="例题1，Longest-Common-Subsequence"><a href="#例题1，Longest-Common-Subsequence" class="headerlink" title="例题1，Longest Common Subsequence"></a>例题1，Longest Common Subsequence</h3><p>最长公共子序列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">子问题的概念</span><br><span class="line"></span><br><span class="line">例如刚才的longest increasing subsequence问题，先求leet，再求leetcode</span><br><span class="line"></span><br><span class="line">这个问题，可以这么考虑：</span><br><span class="line"></span><br><span class="line">s1 = abcd</span><br><span class="line">s2 = acde</span><br><span class="line"></span><br><span class="line">ab</span><br><span class="line">ac</span><br><span class="line"></span><br><span class="line">ab</span><br><span class="line">acd</span><br><span class="line"></span><br><span class="line">ab</span><br><span class="line">acde</span><br><span class="line"></span><br><span class="line">abc</span><br><span class="line">acd</span><br><span class="line"></span><br><span class="line">abc</span><br><span class="line">acde</span><br><span class="line"></span><br><span class="line">abcd</span><br><span class="line">acde</span><br><span class="line"></span><br><span class="line">最后要求的是f[abcd][acde] = ?  --&gt; f[<span class="number">4</span>][<span class="number">4</span>] = ?</span><br><span class="line">    </span><br><span class="line">   i</span><br><span class="line">   ↓</span><br><span class="line">abcd...</span><br><span class="line">acde...</span><br><span class="line">   ↑</span><br><span class="line">   j</span><br><span class="line">   </span><br><span class="line">想要计算f[i][j] -&gt; 字符串<span class="number">0</span>~i配上字符串<span class="number">0</span>~j的LCS是多少？</span><br><span class="line"></span><br><span class="line">如果最后一个字符一样，和另一种不一样，是两种情况。</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 如果不一样，当然不能都扔了。考虑扔掉一个试试。即考虑f[i][j-<span class="number">1</span>]或f[i-<span class="number">1</span>][j]。即：</span><br><span class="line">  <span class="keyword">if</span> a[i-<span class="number">1</span>]!=b[j-<span class="number">1</span>]</span><br><span class="line">      f[i][j] = Math.max(</span><br><span class="line">    	f[i-<span class="number">1</span>][j],<span class="comment">//i不在LCS里</span></span><br><span class="line">    	f[i][j-<span class="number">1</span>],<span class="comment">//j不在LCS里</span></span><br><span class="line">  		f[i-<span class="number">1</span>][j-<span class="number">1</span>])<span class="comment">//都不在 (其实这个已经包含在前两个里)</span></span><br><span class="line"><span class="number">2.</span> 如果一样：就把两个都去掉试试(其实也可以去掉一个试试)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">      f[i][j] = Math.max(</span><br><span class="line">      	f[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>,<span class="comment">//都不在</span></span><br><span class="line">        f[i][j-<span class="number">1</span>],<span class="comment">//j不在LCS里(其实这个已经在第一个里了，这是一种贪心的思路)</span></span><br><span class="line">        f[i-<span class="number">1</span>][j]<span class="comment">//i不在LCS里(其实这个已经在第一个里了)</span></span><br><span class="line">      	)</span><br><span class="line"><span class="keyword">return</span> f[n][m]</span><br></pre></td></tr></table></figure>

<h3 id="例题2，Edit-Distance"><a href="#例题2，Edit-Distance" class="headerlink" title="例题2，Edit Distance"></a>例题2，Edit Distance</h3><p>将第一个字符串最少改动，变成第二个字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&quot;mart&quot;</span>;</span><br><span class="line">s2 = <span class="string">&quot;karma&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">f[i][j] ： s1的前i个字符配上s2的前j个字符的LCS长度</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> 最后一个字符不等：</span><br><span class="line">	f[i][j] = Math.min(</span><br><span class="line">      <span class="comment">//直接把不等的这一位替换 -&gt; 将s1[i]替换为s2[j]</span></span><br><span class="line">      <span class="comment">// s1 =  mart -&gt;  mar|a</span></span><br><span class="line">      <span class="comment">// s2 = karma -&gt; karm|a</span></span><br><span class="line">      f[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>, <span class="comment">//+1指替换这个字符的操作</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//给s1添加一个s2[j]，并将s2错一位 -&gt; 在s1的i位置插入s2[j]</span></span><br><span class="line">      <span class="comment">// s1 =  mart -&gt; mart |a</span></span><br><span class="line">      <span class="comment">// s2 = karma -&gt; karm |a</span></span><br><span class="line">      f[i][j-<span class="number">1</span>] + <span class="number">1</span> ,</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 将s1错一位  -&gt; 删除s1[i]</span></span><br><span class="line">      <span class="comment">// s1 =  mart -&gt;   mar |t</span></span><br><span class="line">      <span class="comment">// s2 = karma -&gt; karma</span></span><br><span class="line">      f[i-<span class="number">1</span>][j] + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">      f[i][j] = Math.min(</span><br><span class="line">      <span class="comment">//将相等的这一位保留</span></span><br><span class="line">      <span class="comment">// s1 =  mart -&gt;  mar|t</span></span><br><span class="line">      <span class="comment">// s2 =  kart -&gt;  kar|t</span></span><br><span class="line">      f[i][j] = f[i-<span class="number">1</span>][j-<span class="number">1</span>],</span><br><span class="line">        </span><br><span class="line">      <span class="comment">//将相等的一位放弃，并在之后插入一个与之一样的(其实已经包含在第一种)</span></span><br><span class="line">      <span class="comment">// s1 =  mart -&gt;  martt</span></span><br><span class="line">      <span class="comment">// s2 =  kart -&gt;   kart</span></span><br><span class="line">      f[i][j] = f[i][j-<span class="number">1</span>] + <span class="number">1</span>,</span><br><span class="line">        </span><br><span class="line">      <span class="comment">//将相等的一位删除(其实已经包含在第一种)</span></span><br><span class="line">      <span class="comment">// s1 =  mart -&gt;   mar</span></span><br><span class="line">      <span class="comment">// s2 =  kart -&gt;  kart</span></span><br><span class="line">      f[i][j] = f[i-<span class="number">1</span>][j] + <span class="number">1</span></span><br><span class="line">      )</span><br><span class="line">      </span><br><span class="line">初始化：</span><br><span class="line"></span><br><span class="line">f[i][<span class="number">0</span>] = <span class="number">0</span>, f[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">     </span><br><span class="line">        </span><br><span class="line">答案：</span><br><span class="line">f[n][m]</span><br><span class="line"></span><br><span class="line">代码</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] c1 = word1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] c2 = word2.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n1 = c1.length;</span><br><span class="line">        <span class="keyword">int</span> n2 = c2.length;</span><br><span class="line">        <span class="comment">//min[i][j] ： s1的前i个字符配上s2的前j个字符的最少改动次数</span></span><br><span class="line">        ++n1;</span><br><span class="line">        ++n2;</span><br><span class="line">        <span class="keyword">int</span>[][] min = <span class="keyword">new</span> <span class="keyword">int</span>[n1][n2];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        min[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n1 ; ++i )&#123;</span><br><span class="line">            min[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; n2; ++j )&#123;</span><br><span class="line">            min[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//dp</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n1 ; ++i )&#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; n2 ; ++j )&#123;</span><br><span class="line">                min[i][j] = n2;</span><br><span class="line">                <span class="keyword">if</span>( c1[i-<span class="number">1</span>] == c2[j-<span class="number">1</span>] )&#123;</span><br><span class="line">                    <span class="comment">//s1 = &quot;...t&quot;</span></span><br><span class="line">                    <span class="comment">//s2 = &quot;...t&quot;</span></span><br><span class="line">                    min[i][j] = Math.min( min[i-<span class="number">1</span>][j-<span class="number">1</span>] , <span class="comment">//相等</span></span><br><span class="line">                                Math.min(min[i][j-<span class="number">1</span>] + <span class="number">1</span>, <span class="comment">// 在s1[i]后添加s2[j]</span></span><br><span class="line">                                         min[i-<span class="number">1</span>][j] + <span class="number">1</span>) );  <span class="comment">// 删s1[i]</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// s1 = &quot;....a&quot;</span></span><br><span class="line">                    <span class="comment">// s2 = &quot;....b&quot;</span></span><br><span class="line">                    min[i][j] = Math.min(min[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>, <span class="comment">// 用s2[j]替换s1[i]</span></span><br><span class="line">                                Math.min(min[i][j-<span class="number">1</span>] + <span class="number">1</span>,  <span class="comment">// 在s1后添加s[j]</span></span><br><span class="line">                                         min[i-<span class="number">1</span>][j] + <span class="number">1</span>));   <span class="comment">// 删s1[i]</span></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min[n1-<span class="number">1</span>][n2-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题3，Distinct-Subsequences"><a href="#例题3，Distinct-Subsequences" class="headerlink" title="例题3，Distinct Subsequences"></a>例题3，Distinct Subsequences</h3><p>从S=”rabbbit”挑出T = “rabbit”有几种挑法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">状态：f[i][j]</span><br><span class="line">	S的“前i”个字符中选取T的前j个字符，有多少种方案</span><br><span class="line"></span><br><span class="line">方程：</span><br><span class="line"></span><br><span class="line">最后一位相等：</span><br><span class="line">S = rabb  ---- i</span><br><span class="line">T =  rab  ---- j</span><br><span class="line">f[i][j] = 有几种方案 ：</span><br><span class="line"><span class="number">1.</span> f[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>  <span class="comment">// 匹配上i和j</span></span><br><span class="line">  S = rab | b</span><br><span class="line">  T =  ra | b</span><br><span class="line"><span class="number">2.</span> f[i-<span class="number">1</span>][j]   <span class="comment">//不要i</span></span><br><span class="line">  S = rab | b</span><br><span class="line">  T = rab</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">最后一位不等：</span><br><span class="line">S = rabbbi  ---- i</span><br><span class="line">T = rab     ---- j</span><br><span class="line">直接扔掉S最后一位f[i][j] = f[i-<span class="number">1</span>][j]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">初始化：</span><br><span class="line"></span><br><span class="line">f[i][<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// 空串</span></span><br><span class="line">f[<span class="number">0</span>][j] = <span class="number">0</span>,j&gt;<span class="number">0</span></span><br><span class="line"></span><br><span class="line">答案：f[n][m]</span><br><span class="line"></span><br><span class="line">代码：</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] cS = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] cT = t.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> nS = cS.length + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> nT = cT.length + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>( nS == <span class="number">1</span> &amp;&amp; nT &gt; <span class="number">1</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>( nT == <span class="number">1</span> ) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// num[i][j] S的前i个字符，和T的前j个字符，T被S组成的可能的数目</span></span><br><span class="line">        <span class="keyword">int</span>[][] num = <span class="keyword">new</span> <span class="keyword">int</span>[nS][nT];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        num[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; nS; ++i )&#123;</span><br><span class="line">            num[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; nT ; ++j )&#123;</span><br><span class="line">            num[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dp</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; nS ; ++i )&#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; nT ; ++j )&#123;</span><br><span class="line">                <span class="keyword">if</span>( cS[i-<span class="number">1</span>] == cT[j-<span class="number">1</span>] )&#123;</span><br><span class="line">                    num[i][j] = num[i-<span class="number">1</span>][j-<span class="number">1</span>]+ num[i-<span class="number">1</span>][j]; <span class="comment">// 相等</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    num[i][j] = num[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num[nS-<span class="number">1</span>][nT-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="例题4，Interleaving-String"><a href="#例题4，Interleaving-String" class="headerlink" title="例题4，Interleaving String"></a>例题4，Interleaving String</h3><p>可行性问题</p>
<p>给了三个字符串s1,s2,s3.判断s3是否是由s1和s2交替组成（按顺序，且可交替着挑）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&quot;aabcc&quot;</span>,s2 = <span class="string">&quot;dbbca&quot;</span></span><br><span class="line">s3 = <span class="string">&quot;aadbbcbcac&quot;</span> - &gt; <span class="keyword">true</span></span><br><span class="line">s3 = <span class="string">&quot;aadbbbaccc&quot;</span> -&gt; <span class="keyword">false</span></span><br><span class="line">  </span><br><span class="line">直观想法</span><br><span class="line">f[i][j][k] -- s1的前i个和s2的前j个 能不能交替组成s3的前k个</span><br><span class="line">k=i+j</span><br><span class="line"></span><br><span class="line">即f[i][j][i+j]  --&gt; f[i][j]</span><br><span class="line"></span><br><span class="line">倒过来看</span><br><span class="line"></span><br><span class="line">s1 = ab......i</span><br><span class="line">s2 = db......j</span><br><span class="line">s3 = aa......k</span><br><span class="line"></span><br><span class="line">f[i][j] = </span><br><span class="line"></span><br><span class="line">如果s1[i]不等于s3[i+j]：</span><br><span class="line"></span><br><span class="line"> f[i-<span class="number">1</span>][j] &amp;&amp; s1[i-<span class="number">1</span>] == s3[i+j-<span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line">  或者</span><br><span class="line">  </span><br><span class="line">如果s2[j]不等于s3[i+j]:</span><br><span class="line">  </span><br><span class="line"> f[i][j-<span class="number">1</span>] &amp;&amp; s2[j-<span class="number">1</span>] == s3[i+j-<span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line">否则的话，就不行了！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">初始化：</span><br><span class="line"></span><br><span class="line">f[i][<span class="number">0</span>] = ( s[<span class="number">0.</span>...i-<span class="number">1</span>] == s3[<span class="number">0.</span>..i-<span class="number">1</span>] ) <span class="comment">// 前i段只用s1</span></span><br><span class="line">f[<span class="number">0</span>][j] = ( s2[<span class="number">0.</span>..j-<span class="number">1</span>] == s3[<span class="number">0.</span>..j-<span class="number">1</span>] ) <span class="comment">// 前j段只用s2</span></span><br><span class="line"></span><br><span class="line">答案：</span><br><span class="line"></span><br><span class="line">f[n][m]</span><br><span class="line"></span><br><span class="line">n = s1.size</span><br><span class="line">m = s2.size</span><br><span class="line"></span><br><span class="line">代码：</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] c1 = s1.toCharArray(), c2 = s2.toCharArray(), c3 = s3.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n1 = c1.length, n2 = c2.length, n3 = c3.length;</span><br><span class="line">        <span class="keyword">if</span>( n3 != n1 + n2 ) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        ++n1;++n2;++n3;</span><br><span class="line">        <span class="comment">//dp[i][j] : c1[0~i]和c2[0~j]能否交替组成c3[i+j]</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n1][n2];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n1 ; ++i )&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = c1[i-<span class="number">1</span>] == c3[i-<span class="number">1</span>] &amp;&amp; dp[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; n2 ; ++j )&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = c2[j-<span class="number">1</span>] == c3[j-<span class="number">1</span>] &amp;&amp; dp[<span class="number">0</span>][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//dp</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n1 ; ++i )&#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n2; ++j )&#123;</span><br><span class="line">                <span class="keyword">if</span>( c1[i-<span class="number">1</span>] == c3[i + j - <span class="number">1</span>] )&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>( c2[j-<span class="number">1</span>] == c3[i + j - <span class="number">1</span>] )&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j-<span class="number">1</span>] || dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n1-<span class="number">1</span>][n2-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Dungeon-Game"><a href="#Dungeon-Game" class="headerlink" title="Dungeon Game"></a>Dungeon Game</h3><p>英雄救美：给一个矩阵<code>int[][] dungegon</code>，每个格子正数代表能量加成，负数代表减弱能量。英雄要从左上走到右下，要求每一时刻英雄的能量不低于1.问英雄初始时最少需要多少能量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[] direct, <span class="keyword">int</span>[][] dungeon,<span class="keyword">int</span>[][] init)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> initNow;</span><br><span class="line">  <span class="keyword">if</span>(dungeon[i][j] &gt; init[i+direct[<span class="number">0</span>]][j+direct[<span class="number">1</span>]])&#123;</span><br><span class="line">    <span class="comment">// 此处能量加成，进入此处前至少具有1的能量</span></span><br><span class="line">    initNow = <span class="number">1</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 此处减弱能量，进入此处前必须满足下一步的能量，且至少具有1的能量</span></span><br><span class="line">    initNow = init[i+direct[<span class="number">0</span>]][j+direct[<span class="number">1</span>]] - dungeon[i][j];</span><br><span class="line">    initNow = Math.max(initNow,<span class="number">1</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> initNow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="keyword">int</span>[][] dungeon)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(dungeon.length == <span class="number">0</span> || dungeon[<span class="number">0</span>].length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> n = dungeon.length;<span class="keyword">int</span> m = dungeon[<span class="number">0</span>].length;</span><br><span class="line">  <span class="comment">// init[i][j] : 进入[i,j]前最少需要的能量</span></span><br><span class="line">  <span class="keyword">int</span>[][] init = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  <span class="keyword">if</span>(dungeon[n-<span class="number">1</span>][m-<span class="number">1</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    init[n-<span class="number">1</span>][m-<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    init[n-<span class="number">1</span>][m-<span class="number">1</span>] = -dungeon[n-<span class="number">1</span>][m-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span>[] right = &#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span>[] down = &#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span> ; i &gt;= <span class="number">0</span> ; --i)&#123;</span><br><span class="line">    init[i][m-<span class="number">1</span>] = go(i,m-<span class="number">1</span>,down,dungeon,init);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = m - <span class="number">2</span> ; j &gt;= <span class="number">0</span> ; --j)&#123;</span><br><span class="line">    init[n-<span class="number">1</span>][j] = go(n-<span class="number">1</span>,j,right,dungeon,init);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// dp</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span> ; i &gt;= <span class="number">0</span> ; --i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = m - <span class="number">2</span> ; j &gt;= <span class="number">0</span> ; --j)&#123;</span><br><span class="line">      <span class="keyword">int</span> rightInit = go(i,j,right,dungeon,init);</span><br><span class="line">      <span class="keyword">int</span> downInit = go(i,j,down,dungeon,init);</span><br><span class="line">      init[i][j] = Math.min(rightInit,downInit);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> init[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Maximum-Length-of-Repeated-Subarray"><a href="#Maximum-Length-of-Repeated-Subarray" class="headerlink" title="Maximum Length of Repeated Subarray"></a>Maximum Length of Repeated Subarray</h3><p>求两个数字的最大连续子数组长度</p>
<p>思路：动态规划</p>
<p>一开始想多了，用了一种非常绕弯的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] dp;</span><br><span class="line"><span class="comment">// dp[i][j] :从A[i]和B[j]开始的最大子数组长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= A.length || j &gt;= B.length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(dp[i][j] &gt; <span class="number">0</span>) <span class="keyword">return</span> dp[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(A[i] == B[j])</span><br><span class="line">        dp[i][j] =  <span class="number">1</span> + helper(A, B, i + <span class="number">1</span>, j + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        dp[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.length == <span class="number">0</span> || B.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    dp = <span class="keyword">new</span> <span class="keyword">int</span>[A.length][B.length];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> globalMAX = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B.length; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] == B[j])&#123;</span><br><span class="line">                globalMAX = Math.max(globalMAX, helper(A, B, i ,j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> globalMAX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，我写的实在是太绕了。我们看一下正确的DP打开方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.length == <span class="number">0</span> || B.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[A.length][B.length];</span><br><span class="line">        <span class="comment">// dp[i][j]是以A[i]和B[j]结尾的最大子数组长度</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = A[<span class="number">0</span>] == B[<span class="number">0</span>] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; ++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = A[i] == B[<span class="number">0</span>] ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// 初始化边界</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; B.length; ++j)&#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = A[<span class="number">0</span>] == B[j] ? <span class="number">1</span> : <span class="number">0</span>;<span class="comment">// 初始化边界</span></span><br><span class="line">                <span class="keyword">if</span> (A[i] == B[j]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    max = Math.max(dp[i][j], max);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>然而这并不是最快的。</p>
<p>我们看一下骚操作：</p>
<p>其实就是把<code>dp[][]</code>压缩到了一维。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//给定两个数组，找出两者公共的最长子串  </span></span><br><span class="line">        <span class="comment">//要求：两个子串的长度均小于1000，元素的范围0-99  </span></span><br><span class="line">          </span><br><span class="line">        <span class="comment">//参考：动态规划问题DP,采用一个长度为m+1的一维数组来记录各个位置最长匹配的长度  </span></span><br><span class="line">        <span class="keyword">int</span> n=A.length,m=B.length;  </span><br><span class="line">        <span class="keyword">int</span> [] dp=<span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>];  </span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;  </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;<span class="number">0</span>;j--)&#123;  </span><br><span class="line">                <span class="keyword">if</span>(A[i-<span class="number">1</span>]==B[j-<span class="number">1</span>])&#123;  </span><br><span class="line">                    <span class="comment">//存在相同的,更新动态数组  </span></span><br><span class="line">                    dp[j]=dp[j-<span class="number">1</span>]+<span class="number">1</span>;  </span><br><span class="line">                    max=Math.max(max,dp[j]);  </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">                    <span class="comment">//不存在相同，置0  </span></span><br><span class="line">                    dp[j]=<span class="number">0</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> max;  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure>

<h3 id="Wiggle-Subsequence"><a href="#Wiggle-Subsequence" class="headerlink" title="Wiggle Subsequence"></a>Wiggle Subsequence</h3><p>定义Wiggle子序列为：相邻两数的差一定是正负交替的。比如数组<code>[1,7,4,9,2,5]</code> 的相邻两数差是<code> (6,-3,5,-7,3)</code> ,它是正负交替的。因此它是wiggle数组。</p>
<p>给一个数组，求它的最长的wiggle subsequence的长度。</p>
<p><strong>思路一，DP</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 计算每个数字右边第一个比它大的值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] asPeek = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span>[] asValley = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        Arrays.fill(asPeek, <span class="number">1</span>);</span><br><span class="line">        Arrays.fill(asValley, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] == nums[j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                    asPeek[i] = Math.max(<span class="number">1</span> + asValley[j], asPeek[i]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    asValley[i] = Math.max(<span class="number">1</span> + asPeek[j], asValley[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxLength = Math.max(asPeek[i], maxLength);</span><br><span class="line">            maxLength = Math.max(asValley[i], maxLength);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>用DP其实多余了。其实有更快的方式：</p>
<p><strong>思路二，贪心</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> p=<span class="number">1</span>, q=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(nums[i]&gt;nums[i-<span class="number">1</span>]) p=q+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]&lt;nums[i-<span class="number">1</span>]) q=p+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Math.min(nums.length, Math.max(p, q));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Freedom-Trail"><a href="#Freedom-Trail" class="headerlink" title="Freedom Trail"></a>Freedom Trail</h3><p>给一个环形字符串<code>ring</code>，代表一个表盘。再给一个字符串key。当ring的十二点钟方向与key的某个字符一样时，可以按下button，表示匹配了这个字符。匹配完事儿之后可以将ring顺时针或逆时针旋转。其中将旋转一个字符记一次操作，且按下button记一次操作。求能够将key匹配完毕时的最少操作次数。</p>
<p><img src="https://leetcode.com/static/images/problemset/ring.jpg" alt="img"></p>
<p>分析：</p>
<ol>
<li>按下button的操作次数恒等于key的长度。</li>
<li>顺时针旋转与逆时针旋转具有等效性，即顺时针旋转k步，等于逆时针旋转ring.length - k 步</li>
</ol>
<p><strong>思路一，暴解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// helper()函数：返回ring的[ring_idx, ring.lengh + ring_idx] 与key的[key_idx, n] 匹配时的最少旋转次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中，ring.lengh + ring_idx代表旋转至ring.length,然后从头开始的意思</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(String ring, String key, <span class="keyword">int</span> ring_idx, <span class="keyword">int</span> key_idx)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">  <span class="keyword">if</span>(key_idx == key.length())&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> min_rotated = Integer.MAX_VALUE;<span class="comment">//本轮结果</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">int</span> i = ring_idx; i &lt; ring.length() + ring_idx; ++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ring.charAt(i % ring.length()) == key.charAt(key_idx))&#123;</span><br><span class="line">      <span class="comment">// 如果ring[i] == key[key_idx]，那么顺时针的旋转次数roated_curr 就是 i - ring_idx</span></span><br><span class="line">      <span class="keyword">int</span> roated_curr = i - ring_idx;</span><br><span class="line">      <span class="comment">// 逆时针的旋转次数 =  ring.length() - roated_curr</span></span><br><span class="line">      <span class="comment">// 两个取最小</span></span><br><span class="line">      roated_curr = Math.min(roated_curr, ring.length() - roated_curr);</span><br><span class="line">      <span class="comment">// 把剩下的工作交给helper(i,key_idx + 1)来做</span></span><br><span class="line">      <span class="comment">// 并从所有的i里挑一个旋转次数最小的，作为本轮的结果，并返回</span></span><br><span class="line">      min_rotated = Math.min(min_rotated, roated_curr + helper(ring, key, i% ring.length(), key_idx + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> min_rotated;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRotateSteps</span><span class="params">(String ring, String key)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> helper(ring, key, <span class="number">0</span>, <span class="number">0</span>) + key.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>暴解肯定是超时的。</p>
<p><strong>思路2，记忆化搜索</strong></p>
<p>同一个<code>[ring_idx, key_idx]</code> 是调用了多次helper()函数的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] memo;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(String ring, String key, <span class="keyword">int</span> ring_idx, <span class="keyword">int</span> key_idx)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(key_idx == key.length())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(memo[ring_idx][key_idx] &gt; <span class="number">0</span>) <span class="keyword">return</span> memo[ring_idx][key_idx];</span><br><span class="line">    <span class="keyword">int</span> roated_curr =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> min_rotated = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = ring_idx; i &lt; ring.length() + ring_idx; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ring.charAt(i % ring.length()) == key.charAt(key_idx))&#123;</span><br><span class="line">            roated_curr = i - ring_idx;</span><br><span class="line">            roated_curr = Math.min(roated_curr, ring.length() - roated_curr);</span><br><span class="line">            min_rotated = Math.min(min_rotated, roated_curr + helper(ring, key, i% ring.length(), key_idx + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    memo[ring_idx][key_idx] = min_rotated;</span><br><span class="line">    <span class="keyword">return</span> min_rotated;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRotateSteps</span><span class="params">(String ring, String key)</span> </span>&#123;</span><br><span class="line">    min = Integer.MAX_VALUE;</span><br><span class="line">    memo = <span class="keyword">new</span> <span class="keyword">int</span>[ring.length()][key.length()];</span><br><span class="line">    <span class="keyword">return</span> helper(ring, key, <span class="number">0</span>, <span class="number">0</span>) + key.length(); <span class="comment">// 最后记得加上press button的次数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思路3，DP递推</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">n = ring.length</span><br><span class="line">m = key.length</span><br><span class="line"></span><br><span class="line">状态：</span><br><span class="line"></span><br><span class="line">memo[i][j] : ring的[i,n] 与 key的[j,m] 匹配上的最少旋转次数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">转移方程：</span><br><span class="line"></span><br><span class="line">memo[i][j] = Math.min(memo[q][j+<span class="number">1</span>] + (i到q所需的旋转次数)) , q = i,i+<span class="number">1</span>,...,n+i，且ring[q%n] == key[j]  <span class="comment">// 转移方程一开始搞错了！气死了</span></span><br><span class="line"></span><br><span class="line">初始化：</span><br><span class="line">j = m - <span class="number">1</span>时，memo[i][j] = Math.min(i到q所需的旋转次数) </span><br><span class="line"></span><br><span class="line">返回值 memo[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRotateSteps</span><span class="params">(String ring, String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = ring.length();</span><br><span class="line">        <span class="keyword">int</span> m = key.length();</span><br><span class="line">        <span class="keyword">int</span>[][] memo = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min= Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                min = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> q = i; q &lt; i + n; ++q) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ring.charAt(q % n) != key.charAt(j)) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">int</span> rotate = q - i;</span><br><span class="line">                    rotate = Math.min(rotate, n - rotate);</span><br><span class="line">                    <span class="keyword">int</span> min_curr = j &lt; m - <span class="number">1</span> ? memo[q % n][j + <span class="number">1</span>] + rotate : rotate;</span><br><span class="line">                    <span class="keyword">if</span> (min &gt; min_curr) &#123;min = min_curr;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">                memo[i][j] = min;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[<span class="number">0</span>][<span class="number">0</span>] + key.length();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="滚动数组"><a href="#滚动数组" class="headerlink" title="滚动数组"></a>滚动数组</h2><p>动态规划四要素：</p>
<ul>
<li>状态</li>
<li>方程</li>
<li>初始化</li>
<li>答案</li>
</ul>
<p>滚动数组优化是什么？</p>
<p>就是将<code>f[i] = max(f[i-1], f[i-2] + A[i])</code> 转化为：</p>
<p><code>f[i%2] = max(f[i - 1] % 2) ,f[(i-2) % 2]</code></p>
<h3 id="例题1，House-Robber"><a href="#例题1，House-Robber" class="headerlink" title="例题1，House Robber"></a>例题1，House Robber</h3><p>例如给一个数组[3,8,4]。每个元素代表这个房子里的钱。一个强盗想抢钱，但绝对不可以同时抢相邻两个房子里的钱。要怎么抢才能抢到的总钱数最多？</p>
<p><strong>方法一，序列型DP</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">f[i] : 前i个房子的最大价值是f[i]</span><br><span class="line"></span><br><span class="line">转移方程：</span><br><span class="line"></span><br><span class="line">第i个房子有两个状态，抢和不抢</span><br><span class="line"></span><br><span class="line">不抢i : = f[i-<span class="number">1</span>]</span><br><span class="line">抢i   : = f[i-<span class="number">2</span>] + A[i]</span><br><span class="line"></span><br><span class="line">因此转移方程： f[i] = max(f[i-<span class="number">1</span>], f[i-<span class="number">2</span>] + A[i])</span><br><span class="line">  </span><br><span class="line">初始化： f[<span class="number">0</span>] = <span class="number">0</span>, f[<span class="number">1</span>] = A[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">答案：f[n]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">houseRobber</span><span class="params">(<span class="keyword">int</span>[] A)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> n = A.length;</span><br><span class="line">   <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="comment">//定义状态</span></span><br><span class="line">   <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">   f[<span class="number">0</span>] = <span class="number">0</span>; f[<span class="number">1</span>] = A[<span class="number">0</span>];</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">      f[i] = Math.max(f[i-<span class="number">1</span>], f[i-<span class="number">2</span>] + A[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> f[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二，滚动数组优化</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">因为f[i] 只与f[i-<span class="number">1</span>] 和 f[i-<span class="number">2</span>] 有关，因此只需要记录前两个值！！！</span><br><span class="line"></span><br><span class="line">因此可以将f[] 缩小为长度为<span class="number">2</span>的数组即可</span><br><span class="line"></span><br><span class="line">因此转移方程： f[i%<span class="number">2</span>] = max(f[(i-<span class="number">1</span>)%<span class="number">2</span>], f[(i-<span class="number">2</span>)%<span class="number">2</span>] + A[i])</span><br><span class="line">  </span><br><span class="line">核心：滚动啊滚动！不需要再次更新状态啊！</span><br></pre></td></tr></table></figure>

<h3 id="例题2，House-Robber-II"><a href="#例题2，House-Robber-II" class="headerlink" title="例题2，House Robber II"></a>例题2，House Robber II</h3><p>给一个数组[3,6,4] 。这个数组是首位相接的。在这个环上怎么抢才能抢的最多？</p>
<p><strong>方法一，拆分数组</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于首位相接，因此首位只可以选择其中一个，或者两个都不选！这样就转化成了house robber <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>方法二，copy一份</strong></p>
<p>copy一份变成[3,6,4,3,6,4] 。。但是时间复杂度比较高</p>
<h3 id="例题3，Maximal-Square"><a href="#例题3，Maximal-Square" class="headerlink" title="例题3，Maximal Square"></a>例题3，Maximal Square</h3><p>二维滚动数组问题。</p>
<p>给一个数组 。找到一个最大的全为1的正方形。 </p>
<p><strong>普通枚举</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] = &#123;&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;，&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举起点</span></span><br><span class="line"><span class="keyword">for</span>(x = <span class="number">0</span> -&gt; n)&#123;</span><br><span class="line">  <span class="keyword">for</span>(y = <span class="number">0</span> -&gt; n)&#123; </span><br><span class="line">    <span class="comment">//枚举边长</span></span><br><span class="line">    <span class="keyword">for</span>(a = <span class="number">1</span> -&gt; n)&#123;</span><br><span class="line">      <span class="comment">//检验此正方形[x,y,a]是否满足要求</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度$O(n^5)$ 。太大了</p>
<p><strong>优化：记忆化搜索</strong></p>
<p>对于一个有效点（值为1）<code>[i,j]</code> ，如果要计算它的左上角最长能延伸的长度，需要考虑三点：</p>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2018-03-08-13-48-34.png"> </p>
<ul>
<li>以[i-1, j-1]  为右下角的最大的矩形是多少</li>
<li>以[i,j-1] 为右边界的最大矩形是多少</li>
<li>以[i-1, j]  为下边界的最大矩形是多少</li>
</ul>
<p>那么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">因此令</span><br><span class="line">f[i][j]表示以[i,j] 为右下角的正方形的最大边长</span><br><span class="line">left[i][j] : 以[i,j]为右边界的最大矩形</span><br><span class="line">up[i][j] : 以[i,j]为下边界的最大矩形</span><br><span class="line"></span><br><span class="line">转移方程：</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(maxtrix[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">	f[i][j] = max(f[i-<span class="number">1</span>][j-<span class="number">1</span>], up[i-<span class="number">1</span>][j], left[i][j-<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	f[i][j] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">上面的方法除了维护f之外，还需要维护up和left数组，其实可以直接用f来代替up和left。</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(matrix[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">  f[i][j] = max(f[i-<span class="number">1</span>],[j-<span class="number">1</span>],f[i-<span class="number">1</span>][j],f[i][j-<span class="number">1</span>])+<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">  f[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">初始化：</span><br><span class="line"></span><br><span class="line">f[i][<span class="number">0</span>] = matrix[i][<span class="number">0</span>]</span><br><span class="line">f[<span class="number">0</span>][j] = matrix[<span class="number">0</span>][j]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">答案：</span><br><span class="line"></span><br><span class="line">max(f[i][j])</span><br></pre></td></tr></table></figure>

<p><strong>滚动数组优化</strong></p>
<p>对于每一个元素(i,j)，只与它前一行和前一列的元素有关，与其前两行的元素无关，因此可以对其行进行滚动数组优化。因此转移方程变为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(matrix[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">  f[i%<span class="number">2</span>][j] = max(f[(i-<span class="number">1</span>)%<span class="number">2</span>],[j-<span class="number">1</span>],f[(i-<span class="number">1</span>)%<span class="number">2</span>][j],f[i%<span class="number">2</span>][j-<span class="number">1</span>])+<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">  f[i%<span class="number">2</span>][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><p>Unique Paths</p>
<p>Minimum Path Sum</p>
<p>Edit Distance</p>
<h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><h3 id="例题1，Stone-Game"><a href="#例题1，Stone-Game" class="headerlink" title="例题1，Stone Game"></a>例题1，Stone Game</h3><p>给一些石头[3,4,5,6]。每次能合并相邻两个石子，并且花销为两个石子的val和。求把所有石头合并后的总共最小花销是多少。</p>
<p>错误方法，简单贪心 ：如果每次都挑最小的两个？这样不是最优的</p>
<p>一个正确打开方式：搜索所有可能情况：</p>
<p>先探究所有第一次合并的所有可能情况：</p>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2018-03-17-15-50-34.png"> </p>
<p>再探究所有可能情况。自上而下找到所有的最小花费。</p>
<p><strong>换一种思路，自大往小考虑</strong></p>
<ul>
<li>对于<code>[3,4,5,6]</code>来说，要找到一个<code>[0,3]</code>区间的最小花费问题；</li>
<li>拆分问题：也就是<code>[0,i) 和 [i, 3] </code> 这两个区间的合并问题；子区间有三种情况：<ul>
<li>只有1个元素，不需要合并了，耗费为0</li>
<li>只有2个元素，直接合并即可</li>
<li>有k个元素，继续拆分即可</li>
</ul>
</li>
</ul>
<p>这种倒着搜索的时间复杂度其实跟正着搜索是一样的。但是这里面有区间的重复，也就是可以用记忆化搜索！太机智了！</p>
<p>转移方程：</p>
<ul>
<li><code>dp[low][high] = dp[low][i] + dp[i+1][high] + sum[low][high]</code> : 合并左边花销 + 合并右边花销 + 本次合并花销</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">stoneGame</span><span class="params">(<span class="keyword">int</span>[] A)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A == <span class="keyword">null</span> || A.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = A.length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// initialize </span></span><br><span class="line">    <span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="keyword">int</span>[][] visit = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="comment">// 只剩一个元素时，不需要合并</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;f[i][i] = <span class="number">0</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// preparation</span></span><br><span class="line">    <span class="comment">// 先提前吧两两sum计算好</span></span><br><span class="line">    <span class="keyword">int</span>[][] sum = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        sum[i][i] = A[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">            sum[i][j] = sum[i][j-<span class="number">1</span>] + A[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> search(<span class="number">0</span>, n - <span class="number">1</span>, f, visit, sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回[l,r]的最小耗费</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span>[][] f, <span class="keyword">int</span>[][] visit, <span class="keyword">int</span>[][] sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(visit[l][r] == <span class="number">1</span>) <span class="keyword">return</span> f[l][r];</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> f[l][r];</span><br><span class="line">    </span><br><span class="line">    f[l][r] = Integer.MAX_VALUE;</span><br><span class="line">    <span class="comment">// 遍历所有的切分位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = l; k &lt; r; ++k)&#123;</span><br><span class="line">        f[l][r] = Math.min(f[l][r], search(l, k, f, visit, sum) + search(k+<span class="number">1</span>, r, f, vist, sum) + sum[l][r]);</span><br><span class="line">    &#125;</span><br><span class="line">    visit[l][r] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> f[l][r];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题2，Burst-Ballon"><a href="#例题2，Burst-Ballon" class="headerlink" title="例题2，Burst Ballon"></a>例题2，Burst Ballon</h3><p>给一个数组[4,1,5,10] 代表每个气球的分值。打爆第i个气球时得到的分数为：当前未打爆的相邻两边的两个气球和自己的价值乘积。求最终能得到的最大价值</p>
<p>震惊，这道题居然和stone game差不多。我们从后往前分析：</p>
<ul>
<li>定义：dp[0,n]代表把这个区间的气球全部打爆能获得的最大价值</li>
<li>那么倒数第二次被打爆的气球就有可能是(0,n)区间的任意一个，天了噜，太巧妙了</li>
<li>状态转移：<code>dp[i][j] = max(dp[i][k-1] + dp[k+1][j] + midValue)</code> 。<br>由于dp[i,j] 代表区间[i,j]全部打爆后的最大价值而k是最后一个打爆的，因此<code>midValue = arr[i-1] * arr[k] * arr[j+1]</code></li>
<li>初始化：<code>dp[i][i] = arr[i]</code></li>
</ul>
<h3 id="Shopping-Offers"><a href="#Shopping-Offers" class="headerlink" title="Shopping Offers"></a>Shopping Offers</h3><p>给一些商品的价格和需要购买的商品总数。有些商品优惠组合可以优惠购买套装。求以最少的价格刚好购买所需的商品。</p>
<p>思路：dfs。</p>
<p>注意的点：HashMap还可以有List</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;List&lt;Integer&gt;, Integer&gt; memo = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// 注意这个点 </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(List&lt;Integer&gt; price, List&lt;List&lt;Integer&gt;&gt; special, List&lt;Integer&gt; needs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(memo.containsKey(needs)) <span class="keyword">return</span> memo.get(needs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假如不用offer,用现金买了剩下的全部，花费为buyAllCost</span></span><br><span class="line">    <span class="keyword">int</span> buyAllCost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; needs.size(); ++i)&#123;</span><br><span class="line">        buyAllCost += needs.get(i) * price.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//假如用offer买</span></span><br><span class="line">    <span class="keyword">int</span> buyOffter = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(List&lt;Integer&gt; sp : special)&#123;</span><br><span class="line">        List&lt;Integer&gt; needsCopy = <span class="keyword">new</span> ArrayList&lt;&gt;(needs);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; needsCopy.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sp.get(i) &gt; needsCopy.get(i))<span class="keyword">break</span>;</span><br><span class="line">            needsCopy.set(i,needsCopy.get(i) - sp.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == needsCopy.size()) &#123;</span><br><span class="line">            buyOffter = Math.min(buyOffter,sp.get(sp.size()-<span class="number">1</span>) + helper(price, special, needsCopy));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    memo.put(needs, Math.min(buyAllCost, buyOffter));</span><br><span class="line">    <span class="keyword">return</span> Math.min(buyAllCost, buyOffter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="博弈DP"><a href="#博弈DP" class="headerlink" title="博弈DP"></a>博弈DP</h2><h3 id="例题1，Coins-in-a-line-Nim-Game"><a href="#例题1，Coins-in-a-line-Nim-Game" class="headerlink" title="例题1，Coins in a line == Nim Game"></a>例题1，Coins in a line == Nim Game</h3><p>直线上有一排硬币。两个人轮流取，每次只能取一个或者两个。最后一个取到棋子的人获胜。问第一个取棋子的人是否有可能获胜？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">画搜索树，以<span class="number">4</span>个coin为例</span><br><span class="line">先手层：              4T</span><br><span class="line">                 <span class="number">1</span>↙     ↘<span class="number">2</span></span><br><span class="line">后手层：        <span class="number">3F</span>           2T</span><br><span class="line">            <span class="number">1</span>↙   ↘<span class="number">2</span>    <span class="number">1</span>↙   ↘<span class="number">2</span></span><br><span class="line">先手层：     2T     1T   1T      <span class="number">0F</span></span><br><span class="line">  </span><br><span class="line">搜索树中的TorF表示当前选择coin的选手的输赢</span><br><span class="line">因为两个选手都会选择对自己最为有利的方式选取硬币，因此假设两个选手在开始的时候就已经绘制了这样的搜索树，以<span class="number">4</span>枚硬币的情况为例，先手可以选择<span class="number">1</span>个或者<span class="number">2</span>个:</span><br><span class="line"><span class="number">1.</span> 选<span class="number">1</span>个，还剩<span class="number">3</span>个，此时后手无论选择<span class="number">1</span>个还是<span class="number">2</span>个，先手都可以赢</span><br><span class="line"><span class="number">2.</span> 选<span class="number">2</span>个，还剩<span class="number">2</span>个，此时后手选<span class="number">2</span>个先手就会输掉比赛</span><br><span class="line">所以先手选择对自己最为有利的方式，选择<span class="number">1</span>个，赢得比赛。</span><br><span class="line">由此可见，当前有n个coin的情况下， 该选手是否能够赢得比赛与在剩余n-<span class="number">1</span>和n-<span class="number">2</span>枚硬币的情况下对手是否能够赢得比赛有关。</span><br><span class="line">以f(i)表示在剩余i枚硬币情况下当前选手是否能够获胜，</span><br><span class="line">则当下层节点中至少有一个为<span class="keyword">false</span>时，本层即可获胜</span><br><span class="line">状态转移方程为: f(i) = !f(i-<span class="number">1</span>)||!f(i-<span class="number">2</span>)</span><br><span class="line">初始化：f(<span class="number">1</span>)=f(<span class="number">2</span>)=<span class="keyword">true</span></span><br><span class="line">答案：f(i)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> 【超memory】代码：</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] canWin = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// canWin[i] : 还剩i个时是否可以赢得比赛</span></span><br><span class="line">        canWin[<span class="number">0</span>] = <span class="keyword">false</span>;</span><br><span class="line">        canWin[<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">        canWin[<span class="number">2</span>] = <span class="keyword">true</span>;</span><br><span class="line">        canWin[<span class="number">3</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            canWin[i] = !canWin[i-<span class="number">1</span>] || !canWin[i-<span class="number">2</span>] || !canWin[i-<span class="number">3</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> canWin[n];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">既然超了memory，那我们用滚动数组优化。【可惜优化后还是超时】</span><br><span class="line"></span><br><span class="line">震惊！！！！</span><br><span class="line"></span><br><span class="line">一句话！！！！就行了！！！</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> !(n % <span class="number">4</span> == <span class="number">0</span>);  <span class="comment">// 呵呵呵呵呵呵呵呵</span></span><br></pre></td></tr></table></figure>

<h3 id="例题2，coins-in-a-line-II"><a href="#例题2，coins-in-a-line-II" class="headerlink" title="例题2，coins in a line II"></a>例题2，<a target="_blank" rel="noopener" href="http://www.lintcode.com/en/problem/coins-in-a-line-ii/">coins in a line II</a></h3><p>给定硬币序列，硬币具有价值，两个人轮流选取硬币，每次只能从最左边选1个或者2个获得相应的价值，最终获得价值多的人获胜，问先手能够获胜</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">f[i]:表示还剩i个硬币，当前取硬币的人最后最多取硬币的价值</span><br><span class="line">如果f[i]&gt;所有硬币价值的一半则可以获胜</span><br><span class="line">以[<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>]为例</span><br><span class="line">先手层：    	 [<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>]</span><br><span class="line">		       <span class="number">1</span>↙	    ↘<span class="number">2</span></span><br><span class="line">后手层：     [<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>]     [<span class="number">2</span>,<span class="number">10</span>]</span><br><span class="line">		   <span class="number">1</span>↙	 ↘<span class="number">2</span>     <span class="number">1</span>↙   ↘<span class="number">2</span></span><br><span class="line">先手层：  [<span class="number">2</span>,<span class="number">10</span>]   [<span class="number">10</span>] [<span class="number">10</span>]    []</span><br><span class="line">两个人在选取硬币的时候，会选择给对方留下尽可能少的价值</span><br><span class="line">转移方程为：f[i] = sum[i]- min(f[i-<span class="number">1</span>],f[i-<span class="number">2</span>])</span><br><span class="line">初始化：</span><br><span class="line">f[<span class="number">1</span>] = coins[i-<span class="number">1</span>]</span><br><span class="line">f[<span class="number">2</span>] = coins[i-<span class="number">1</span>]+coins[i-<span class="number">2</span>]</span><br><span class="line">答案：</span><br><span class="line"><span class="keyword">if</span> dp[n] &gt; sum[coins]/<span class="number">2</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">firstWillWin</span><span class="params">(<span class="keyword">int</span>[] values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(values.length &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 为了方便，定义从右边开始取</span></span><br><span class="line">        <span class="comment">// 反过来</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = values.length - <span class="number">1</span>; i &lt; j; ++i, --j)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = values[i];</span><br><span class="line">            values[i] = values[j];</span><br><span class="line">            values[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[values.length + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// f[i] 表示当前有i枚硬币，且当前取硬币的人最后最多能取得硬币的价值</span></span><br><span class="line">        <span class="comment">/**如果此刻他取了1枚硬币，能获得最大价值是f[i], 那么另一个人能获得的最大价值就是f[i-1], 且f[i] + f[i-1] = sum[i]</span></span><br><span class="line"><span class="comment">         如果此刻他取了2枚硬币，能获得最大价值是f[i], 那么另一个人能获得的最大价值就是f[i-2], 且f[i] + f[i-1] = sum[i]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         为了让另一个人获得的最大价值更小，那么就取两者最小值：**/</span></span><br><span class="line">        <span class="comment">// f[i] = sum[i] - min(f[i-1], f[i-2])</span></span><br><span class="line"></span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        f[<span class="number">1</span>] = values[<span class="number">0</span>];</span><br><span class="line">        f[<span class="number">2</span>] = values[<span class="number">0</span>] + values[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] sum = <span class="keyword">new</span> <span class="keyword">int</span>[values.length + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= values.length; ++i)&#123;</span><br><span class="line">            sum[i] = sum[i-<span class="number">1</span>] + values[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= values.length; ++i)&#123;</span><br><span class="line">            f[i] = sum[i] - Math.min(f[i-<span class="number">1</span>], f[i-<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(Arrays.toString(f));</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[values.length] &gt; f[values.length - <span class="number">1</span>] || f[values.length] &gt; f[values.length - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Predict-the-Winner"><a href="#Predict-the-Winner" class="headerlink" title="Predict the Winner"></a>Predict the Winner</h3><p>给一个数组，代表每个石子的价值。两个人轮流取石子，每次只能从一边拿一个石子。最终拿到最多石子的人获胜。求先手是否可能获得胜利？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span>[] sum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    sum[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">        sum[i] = sum[i-<span class="number">1</span>] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length][nums.length];</span><br><span class="line">    <span class="comment">// dp[i][j] :[i,j] 之间的石子，先手能获得的最大大小</span></span><br><span class="line">    <span class="comment">// dp[i][j] = Math.max(dp[i][j-1] + nums[j], dp[i+1][j] + nums[i])</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        dp[i][i+<span class="number">1</span>] = Math.max(nums[i], nums[i+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">2</span>; j &lt; nums.length; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                dp[i][j] = Math.max(sum[j-<span class="number">1</span>] - dp[i][j-<span class="number">1</span>] + nums[j], sum[j] - sum[i] - dp[i+<span class="number">1</span>][j] + nums[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = Math.max(sum[j-<span class="number">1</span>] - sum[i-<span class="number">1</span>] - dp[i][j-<span class="number">1</span>] + nums[j], sum[j] - sum[i] - dp[i+<span class="number">1</span>][j] + nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//System.out.println(nums.length + &quot;\t&quot; + dp[0][nums.length - 1]);</span></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][nums.length - <span class="number">1</span>] &gt;= dp[<span class="number">1</span>][nums.length - <span class="number">1</span>] || dp[<span class="number">0</span>][nums.length - <span class="number">1</span>] &gt;= dp[<span class="number">0</span>][nums.length - <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Can-I-win"><a href="#Can-I-win" class="headerlink" title="Can I win"></a>Can I win</h3><p>1~n个石头。两个人轮流取，可以从剩下的石头里随便拿。直到两人的石头相加大于desiredTotal时，最后一个取石头的人获胜。请问先手有没有可能获胜？</p>
<p>这道题的状态在于随便拿，因此之前的dp方式不可靠了。因此只能直接用暴力的回溯法，判断对方有没有可能赢，如果对方有可能赢，那自己肯定输。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canIWin</span><span class="params">(<span class="keyword">int</span> maxChoosableInteger, <span class="keyword">int</span> desiredTotal)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 把所有球都取了之后依然小于desiredTotal</span></span><br><span class="line">    <span class="keyword">int</span> sum = (<span class="number">1</span>+maxChoosableInteger)*maxChoosableInteger/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(sum &lt; desiredTotal) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(desiredTotal &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[maxChoosableInteger + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> helper(desiredTotal);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">boolean</span>[] visited;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HashMap&lt;String, Boolean&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 目标为desiredTotal时，且状态为visited时，自己有没有可能输</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> desiredTotal)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(desiredTotal &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    String curr = arr2str();</span><br><span class="line">    <span class="keyword">if</span>(map.containsKey(curr))&#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(curr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; visited.length; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        visited[i] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 如果对方不可能赢，那么自己才有可能输</span></span><br><span class="line">        <span class="keyword">if</span>(!helper(desiredTotal - i))&#123; <span class="comment">// 关键点在这里</span></span><br><span class="line">            map.put(curr, <span class="keyword">true</span>);</span><br><span class="line">            visited[i] = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(curr, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">String <span class="title">arr2str</span><span class="params">()</span></span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">boolean</span> e : visited)&#123;</span><br><span class="line">        sb.append(e ? <span class="string">&quot;1&quot;</span> : <span class="string">&quot;0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="背包DP"><a href="#背包DP" class="headerlink" title="背包DP"></a>背包DP</h2><p>特点：</p>
<ol>
<li>用值作为dp维度</li>
<li>dp过程就是填写矩阵</li>
<li>可以滚动数组优化</li>
</ol>
<h3 id="例题1，Back-pack"><a href="#例题1，Back-pack" class="headerlink" title="例题1，Back pack"></a>例题1，Back pack</h3><p>有一些物品[2,3,5,7]，每个数字代表每个物品的体积。有一个书包，书包大小为11。求能放的最重的物品。</p>
<p>建立一个矩阵：<code>boolean f[i][s]</code> : 前i个物品，取出后是否能组成和为s！</p>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2018-03-17-16-39-22.png"> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPack</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m + <span class="number">1</span>][A.length + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// dp[s][i] 前i个物品，能否刚好组成s重量</span></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// dp[0][i] 前i个背包可以组成0</span></span><br><span class="line">    Arrays.fill(dp[<span class="number">0</span>], <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// dp[s][0] 前0个背包，不可以组成s</span></span><br><span class="line">    <span class="comment">// Arrays.fill(dp[s][0], false);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; dp.length; ++s)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp[s].length; ++i)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 一定不用A[i] : 前i-1个物品就可以组成</span></span><br><span class="line">            <span class="comment">//   一定用A[i] : 前i-1个物品组不成，但是前i-1个物品可以组成s-A[i]</span></span><br><span class="line">            dp[s][i] = dp[s][i-<span class="number">1</span>] || (s &gt;= A[i-<span class="number">1</span>] &amp;&amp; dp[s-A[i-<span class="number">1</span>]][i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s = dp.length - <span class="number">1</span>; s &gt;= <span class="number">0</span>; --s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[s][A.length]) <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="马甲变换——Partition-Equal-Subset-Sum"><a href="#马甲变换——Partition-Equal-Subset-Sum" class="headerlink" title="马甲变换——Partition Equal Subset Sum"></a>马甲变换——Partition Equal Subset Sum</h3><p>给一个数组，判断这个数组是否可以分割成两个和相等的子数组。</p>
<p>可以转化为背包问题：数组总和为36，一半为18背包容量为18，用数组中的数字尽量将背包装满</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> e : nums) sum += e;</span><br><span class="line">    <span class="keyword">if</span>(sum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    sum /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[sum + <span class="number">1</span>][nums.length + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// dp[s][i] : 前i个数字能否存在和为s的情况</span></span><br><span class="line">    <span class="comment">// 因为如果dp[sum][n] == true, 那么说明前n个数字中存在和为sum的组合。而总数组和为sum*2，那么就一定可以</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    Arrays.fill(dp[<span class="number">0</span>], <span class="keyword">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s = nums[i-<span class="number">1</span>]; s &lt; dp.length; ++s)&#123;</span><br><span class="line">            <span class="comment">// 一定包含第i个数字               一定不含第i个数字</span></span><br><span class="line">            dp[s][i] = dp[s-nums[i-<span class="number">1</span>]][i-<span class="number">1</span>] || dp[s][i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[sum][nums.length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优化</strong></p>
<p>由于只需要用到i-1的状态。因此我们可以减少一个维度：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e : nums) sum += e;</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        sum /= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[sum + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// dp[s][i] : 前i个数字能否存在和为s的情况</span></span><br><span class="line">        <span class="comment">// 因为如果dp[sum][n] == true, 那么说明前n个数字中存在和为sum的组合。而总数组和为sum*2，那么就一定可以</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> s = sum; s &gt;= nums[i-<span class="number">1</span>]; --s)&#123; <span class="comment">// 注意这里是从大到小；因为我们会用到比s小的状态，因此比s小的状态此刻是不可以更新的！</span></span><br><span class="line">                dp[s] = dp[s] || dp[s-nums[i-<span class="number">1</span>]];  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[sum];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="Back-pack-II"><a href="#Back-pack-II" class="headerlink" title="Back pack II"></a>Back pack II</h3><p>给出n个物品的体积A[i]和其价值V[i]，将他们装入一个大小为m的背包，最多能装入的总价值有多大？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPackII</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] A, <span class="keyword">int</span>[] V)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][A.length + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// dp[s][i] : 容量为s的背包，最多能放的最大价值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; dp.length; ++s)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp[s].length; ++i)&#123;</span><br><span class="line">            <span class="comment">// 一定把第i个物品放进去</span></span><br><span class="line">            <span class="keyword">if</span>(s &gt;= A[i-<span class="number">1</span>]) dp[s][i] = dp[s-A[i-<span class="number">1</span>]][i-<span class="number">1</span>] + V[i-<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 一定不放第i个物品</span></span><br><span class="line">            dp[s][i] = Math.max(dp[s][i], dp[s][i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][A.length];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Coin-Change"><a href="#Coin-Change" class="headerlink" title="Coin Change"></a>Coin Change</h3><p>给一些硬币[1,2,5]。再给一个总钱数11。求用硬币组成钱数的最少硬币数字（硬币可以多次拿）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(coins.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>][coins.length + <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; dp.length; ++s)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp[s].length; ++i)&#123;</span><br><span class="line">            <span class="comment">// 完全不用第i个硬币</span></span><br><span class="line">            dp[s][i] = dp[s][i-<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 用1个第i个硬币</span></span><br><span class="line">            <span class="keyword">if</span>(s &gt; coins[i-<span class="number">1</span>] &amp;&amp; dp[s - coins[i-<span class="number">1</span>]][i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                dp[s][i] = Math.min(dp[s][i] == <span class="number">0</span> ? Integer.MAX_VALUE : </span><br><span class="line">                                    dp[s][i],dp[s - coins[i-<span class="number">1</span>]][i] + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s == coins[i-<span class="number">1</span>])&#123;</span><br><span class="line">                dp[s][i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//System.out.println(s + &quot;\t&quot; + i + &quot;\t&quot; + dp[s][i]);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[amount][coins.length] == <span class="number">0</span> ? -<span class="number">1</span> : dp[amount][coins.length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Coin-Change-2"><a href="#Coin-Change-2" class="headerlink" title="Coin Change 2"></a>Coin Change 2</h3><p>给一些硬币，再给一个总钱数。求用硬币组成钱的组成个数</p>
<p><strong>方法一</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(coins.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>][coins.length + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// dp[s][i] : s元钱，由前i种硬币的组合个数</span></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.length; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(coins[i] &lt; dp.length)dp[coins[i]][i+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dp</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; dp.length; ++s)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp[s].length; ++i)&#123;</span><br><span class="line">            <span class="comment">// 完全不用第i枚</span></span><br><span class="line">            dp[s][i] += dp[s][i-<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 用一次第i枚</span></span><br><span class="line">            <span class="keyword">if</span>(s &gt;= coins[i-<span class="number">1</span>])dp[s][i] += dp[s - coins[i-<span class="number">1</span>]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount][coins.length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优化</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span>(coins.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">       </span><br><span class="line">       dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// dp[s] : s元钱的组合个数</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= coins.length; ++i)&#123; <span class="comment">// 注意这个顺序！非常巧妙</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> s = coins[i-<span class="number">1</span>]; s &lt; dp.length; ++s)&#123;</span><br><span class="line">               dp[s] += dp[s - coins[i-<span class="number">1</span>]];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[amount];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="例题3，-K-Sum"><a href="#例题3，-K-Sum" class="headerlink" title="例题3， K Sum"></a>例题3， K Sum</h3><p>给一个数组，从中选出k个数字，使得和为target。求有多少种方案？</p>
<p>转化为：背包问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kSum</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>][K + <span class="number">1</span>][A.length + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// dp[s][k][i] : 容量为s的包，用前i个数字当中的k个，刚好装满的方案个数</span></span><br><span class="line">    </span><br><span class="line">    Arrays.fill(dp[<span class="number">0</span>][<span class="number">0</span>], <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= target; ++s)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= K; ++k)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= A.length; ++i)&#123;</span><br><span class="line">                <span class="comment">// 一定使用A[i]</span></span><br><span class="line">                <span class="keyword">if</span>(s &gt;= A[i-<span class="number">1</span>])dp[s][k][i] += dp[s - A[i-<span class="number">1</span>]][k-<span class="number">1</span>][i-<span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 一定不适用A[i]</span></span><br><span class="line">                dp[s][k][i] += dp[s][k][i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target][K][A.length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Ones-and-Zeroes"><a href="#Ones-and-Zeroes" class="headerlink" title="Ones and Zeroes"></a>Ones and Zeroes</h3><p>给一个数组，每个元素是一个01字符串。求从数组中最多拿出多少个元素，能组成m个0和n个1；</p>
<p>这道题第一遍没做出来。第二次看的时候，才发现这是背包问题的变种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(String[] strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] count = <span class="keyword">new</span> <span class="keyword">int</span>[strs.length][<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// count[i][0] : 第i个字符有多少个0</span></span><br><span class="line">    <span class="comment">// count[i][1] : 第i个字符有多少个1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; ++i)&#123;</span><br><span class="line">        count[i] = counter(strs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>][strs.length + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// dp[zero][one][i] : 前i个str组成zero个0，one个1的最少个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> zero = <span class="number">0</span>;  zero &lt;= m; ++zero)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> one = <span class="number">0</span>; one &lt;= n; ++one)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= strs.length; ++i)&#123;</span><br><span class="line">                <span class="comment">// 要么不用第i个元素</span></span><br><span class="line">                dp[zero][one][i] = dp[zero][one][i-<span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 要么一定用第i个元素</span></span><br><span class="line">                <span class="keyword">if</span>(zero &gt;= count[i-<span class="number">1</span>][<span class="number">0</span>] &amp;&amp; one &gt;= count[i-<span class="number">1</span>][<span class="number">1</span>])&#123;</span><br><span class="line">                    dp[zero][one][i] = Math.max(dp[zero][one][i],</span><br><span class="line">                       <span class="number">1</span> + dp[zero - count[i-<span class="number">1</span>][<span class="number">0</span>]][one - count[i-<span class="number">1</span>][<span class="number">1</span>]][i-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>  dp[m][n][strs.length];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] counter(String str)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(i) == <span class="string">&#x27;0&#x27;</span>)&#123;++count[<span class="number">0</span>];&#125;</span><br><span class="line">        <span class="keyword">else</span> ++count[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>空间优化</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(String[] strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] count = <span class="keyword">new</span> <span class="keyword">int</span>[strs.length][<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// count[i][0] : 第i个字符有多少个0</span></span><br><span class="line">    <span class="comment">// count[i][1] : 第i个字符有多少个1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; ++i)&#123;</span><br><span class="line">        count[i] = counter(strs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// dp[zero][one][i] : 前i个str组成zero个0，one个1的最少个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= strs.length; ++i)&#123; <span class="comment">// 注意顺序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> zero = m;  zero &gt;= <span class="number">0</span>; --zero)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> one = n; one &gt;= <span class="number">0</span>; --one)&#123;</span><br><span class="line">                <span class="keyword">if</span>(zero &gt;= count[i-<span class="number">1</span>][<span class="number">0</span>] &amp;&amp; one &gt;= count[i-<span class="number">1</span>][<span class="number">1</span>])&#123;</span><br><span class="line">                    dp[zero][one] = Math.max(dp[zero][one],</span><br><span class="line">                       <span class="number">1</span> + dp[zero - count[i-<span class="number">1</span>][<span class="number">0</span>]][one - count[i-<span class="number">1</span>][<span class="number">1</span>]]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>  dp[m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] counter(String str)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(i) == <span class="string">&#x27;0&#x27;</span>)&#123;++count[<span class="number">0</span>];&#125;</span><br><span class="line">        <span class="keyword">else</span> ++count[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="相关Leetcode题"><a href="#相关Leetcode题" class="headerlink" title="相关Leetcode题"></a>相关Leetcode题</h1><h2 id="Ugly-Number"><a href="#Ugly-Number" class="headerlink" title="Ugly Number"></a>Ugly Number</h2><p>给一个数num，判断它是不是ugly数——它的质因数只能说是2、3、5。</p>
<p>这道题一开始想复杂了，居然先列出了所有比num小的$2^i3^j5^k$的数。以至于代码变成了这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] k2;</span><br><span class="line">    <span class="keyword">int</span>[] k3;</span><br><span class="line">    <span class="keyword">int</span>[] k5;</span><br><span class="line">    <span class="keyword">int</span> k2_num;</span><br><span class="line">    <span class="keyword">int</span> k3_num;</span><br><span class="line">    <span class="keyword">int</span> k5_num;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] setK(<span class="keyword">int</span> k_num,<span class="keyword">double</span> loge)&#123;</span><br><span class="line">        <span class="keyword">int</span> size = (<span class="keyword">int</span>)(loge/Math.log(k_num))+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(k_num==<span class="number">2</span>)&#123;</span><br><span class="line">            k2_num = size;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k_num==<span class="number">3</span>)&#123;</span><br><span class="line">            k3_num = size;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k_num==<span class="number">5</span>)&#123;</span><br><span class="line">            k5_num = size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] k = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        k[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">1</span>; i &lt; k.length ; ++i )&#123;</span><br><span class="line">            k[i] = k[i-<span class="number">1</span>]*k_num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i2,i3,i5;</span><br><span class="line">        <span class="keyword">long</span> re1,re2;</span><br><span class="line">        <span class="keyword">for</span>( i2 = <span class="number">0</span> ; i2 &lt; k2_num ; ++i2 )&#123;</span><br><span class="line">            <span class="keyword">for</span>( i3 = <span class="number">0</span> ; i3 &lt; k3_num ; ++i3 )&#123;</span><br><span class="line">                re1 = k2[i2] * k3[i3];</span><br><span class="line">                <span class="keyword">if</span>( re1 &gt; num )<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>( i5 = <span class="number">0</span> ; i5 &lt; k5_num ; ++i5 )&#123;</span><br><span class="line">                    re2 = re1 * k5[i5];</span><br><span class="line">                    <span class="keyword">if</span>( re2 &gt; num )<span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(re2 == num)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span> )<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">double</span> loge = Math.log(num);</span><br><span class="line">        k2 = setK(<span class="number">2</span>,loge);</span><br><span class="line">        k3 = setK(<span class="number">3</span>,loge);</span><br><span class="line">        k5 = setK(<span class="number">5</span>,loge);</span><br><span class="line">        <span class="keyword">return</span> dp(num);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是！其实我只需要判断它能不能被2、3、5整除！！！！！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(num%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> isUgly(num/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(num%<span class="number">3</span>==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> isUgly(num/<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span>(num%<span class="number">5</span>==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> isUgly(num/<span class="number">5</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h2 id="Burst-Balloons"><a href="#Burst-Balloons" class="headerlink" title="Burst Balloons"></a>Burst Balloons</h2><p>这题太恶心了。</p>
<p>给一个数组，代表气球的分值。如果打破第i号气球，那么会获得<code>nums[last]*nums[i]*nums[next]</code> 的分值。其中last和next分别是i相邻、还没有打破的气球。例如Given <code>[3, 1, 5, 8]</code>，Return <code>167</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> nums = [3,1,5,8] --&gt; [3,5,8] --&gt;   [3,8]   --&gt;  [8]  --&gt; []</span><br><span class="line">coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167</span><br></pre></td></tr></table></figure>

<p>要求能够获得的最大分值</p>
<p>思路：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a671b48c3d43">参考</a></p>
<p>具体就是一种思路的转变。<br>假设[i…j]中以k，作为分割点。先破k。<br>那么 [i, k] and [k, j] 并不是互相独立的。因为他们之间还可以交集。<br>但是，如果假设，k是最后一个破裂的，那么， [i, k] and [k, j] 就是互相独立的了。</p>
<p>真的就是一个假设的转变，and everything changes.<br>记住这种reverse想法在DP中的应用。</p>
<p>这题简直让我爆炸</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] numsIn)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先把原来的数组拷贝到一个新数组里，边界补1</span></span><br><span class="line">      <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[numsIn.length + <span class="number">2</span>];</span><br><span class="line">      nums[<span class="number">0</span>] = <span class="number">1</span>; nums[nums.length - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsIn.length; ++i)&#123;</span><br><span class="line">          nums[i+<span class="number">1</span>] = numsIn[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> n = nums.length;</span><br><span class="line">      <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="comment">// dp[low][high] = （low,high)之间的最大爆炸分值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> gap = <span class="number">2</span>; gap &lt; n; ++gap)&#123;</span><br><span class="line">            <span class="comment">// 中间相隔gap个球</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> low = <span class="number">0</span>; low &lt; n - gap; ++low)&#123;</span><br><span class="line">                <span class="keyword">int</span> high = low + gap;</span><br><span class="line">                <span class="comment">// 从(low,high)之间挑选一个球最后爆炸</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = low + <span class="number">1</span>; i &lt; high; ++i)&#123;</span><br><span class="line">                    dp[low][high] = Math.max(dp[low][high],</span><br><span class="line">            nums[low]*nums[i]*nums[high] + dp[low][i] + dp[i][high]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>














      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/DP/" rel="tag"># DP</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/11/16/Java-abstract%E5%92%8Cinterface/" rel="next" title="Java-abstract和interface">
                <i class="fa fa-chevron-left"></i> Java-abstract和interface
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/11/21/%E7%AE%97%E6%B3%95-DFS/" rel="prev" title="算法-DFS">
                算法-DFS <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="SOHUCS"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">141</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">29</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%90%86%E8%A7%A3%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-text">理解动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%951%EF%BC%8CDFS%E9%81%8D%E5%8E%86"><span class="nav-text">方法1，DFS遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%952%EF%BC%8C%E5%88%86%E6%B2%BB%E6%B3%95"><span class="nav-text">方法2，分治法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%953%EF%BC%8C%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2"><span class="nav-text">方法3，记忆化搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%954%EF%BC%8C%E5%A4%9A%E9%87%8D%E5%BE%AA%E7%8E%AF"><span class="nav-text">方法4，多重循环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B"><span class="nav-text">自顶向下</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A"><span class="nav-text">自底向上</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8DP"><span class="nav-text">什么时候用DP</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%8D%E7%94%A8DP"><span class="nav-text">什么时候不用DP</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DP%E5%9B%9B%E8%A6%81%E7%B4%A0"><span class="nav-text">DP四要素</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81DP"><span class="nav-text">常见DP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9D%90%E6%A0%87%E5%9E%8B%EF%BC%88%E7%9F%A9%E9%98%B5%EF%BC%89DP"><span class="nav-text">坐标型（矩阵）DP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%981%EF%BC%9AMinimum-Path-Sum"><span class="nav-text">例题1：Minimum Path Sum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%982%EF%BC%8CUnique-Paths"><span class="nav-text">例题2，Unique Paths</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%983%EF%BC%8CUnique-Paths-II"><span class="nav-text">例题3，Unique Paths II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Knight-Probability-in-Chessboard"><span class="nav-text">Knight Probability in Chessboard</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Out-of-Boundary-paths"><span class="nav-text">Out of Boundary paths</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%984%EF%BC%8CClimbing-Stairs"><span class="nav-text">例题4，Climbing Stairs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%985%EF%BC%8CJump-Game"><span class="nav-text">例题5，Jump Game</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%986%EF%BC%8CJump-Game-II"><span class="nav-text">例题6，Jump Game II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Russian-Doll-Envelopes"><span class="nav-text">Russian Doll Envelopes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%987%EF%BC%8CLongest-Increasing-Subsequence"><span class="nav-text">例题7，Longest Increasing Subsequence</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Number-of-Longest-Increasing-Subsequence"><span class="nav-text">Number of Longest Increasing Subsequence</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Increasing-Subsequences"><span class="nav-text">Increasing Subsequences</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Arithmetic-Slices"><span class="nav-text">Arithmetic Slices</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Perfect-Squares"><span class="nav-text">Perfect Squares</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Min-Cost-Climbing-Stairs"><span class="nav-text">Min Cost Climbing Stairs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Decode-Ways"><span class="nav-text">Decode Ways</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Decode-Ways-II"><span class="nav-text">Decode Ways II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unique-Binary-Search-Trees"><span class="nav-text">Unique Binary Search Trees</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Integer-Break"><span class="nav-text">Integer Break</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Partition-Equal-Subset-Sum"><span class="nav-text">Partition Equal Subset Sum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Partition-to-K-Equal-Sum-Subsets"><span class="nav-text">Partition to K Equal Sum Subsets</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Largest-Divisible-Subset"><span class="nav-text">Largest Divisible Subset</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E5%BA%8F%E5%88%97%E5%9E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-text">单序列型动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%981%EF%BC%8CWord-Break"><span class="nav-text">例题1，Word Break</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%982%EF%BC%8CPalindrome-Partitioning-II"><span class="nav-text">例题2，Palindrome Partitioning II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Palindromic-Substrings"><span class="nav-text">Palindromic Substrings</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#House-Robber"><span class="nav-text">House Robber</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#House-Robber-II"><span class="nav-text">House Robber II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#House-Robber-III"><span class="nav-text">House Robber III</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Maximal-Square"><span class="nav-text">Maximal Square</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Paint-House"><span class="nav-text">Paint House</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Target-Sum"><span class="nav-text">Target Sum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E5%B8%81%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98"><span class="nav-text">硬币组合问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E5%BA%8F%E5%88%97%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-text">双序列动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%981%EF%BC%8CLongest-Common-Subsequence"><span class="nav-text">例题1，Longest Common Subsequence</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%982%EF%BC%8CEdit-Distance"><span class="nav-text">例题2，Edit Distance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%983%EF%BC%8CDistinct-Subsequences"><span class="nav-text">例题3，Distinct Subsequences</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%984%EF%BC%8CInterleaving-String"><span class="nav-text">例题4，Interleaving String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dungeon-Game"><span class="nav-text">Dungeon Game</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Maximum-Length-of-Repeated-Subarray"><span class="nav-text">Maximum Length of Repeated Subarray</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Wiggle-Subsequence"><span class="nav-text">Wiggle Subsequence</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Freedom-Trail"><span class="nav-text">Freedom Trail</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84"><span class="nav-text">滚动数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%981%EF%BC%8CHouse-Robber"><span class="nav-text">例题1，House Robber</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%982%EF%BC%8CHouse-Robber-II"><span class="nav-text">例题2，House Robber II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%983%EF%BC%8CMaximal-Square"><span class="nav-text">例题3，Maximal Square</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%A0%E9%A2%98"><span class="nav-text">习题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2"><span class="nav-text">记忆化搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%981%EF%BC%8CStone-Game"><span class="nav-text">例题1，Stone Game</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%982%EF%BC%8CBurst-Ballon"><span class="nav-text">例题2，Burst Ballon</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Shopping-Offers"><span class="nav-text">Shopping Offers</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%9A%E5%BC%88DP"><span class="nav-text">博弈DP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%981%EF%BC%8CCoins-in-a-line-Nim-Game"><span class="nav-text">例题1，Coins in a line &#x3D;&#x3D; Nim Game</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%982%EF%BC%8Ccoins-in-a-line-II"><span class="nav-text">例题2，coins in a line II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Predict-the-Winner"><span class="nav-text">Predict the Winner</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Can-I-win"><span class="nav-text">Can I win</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%8C%E5%8C%85DP"><span class="nav-text">背包DP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%981%EF%BC%8CBack-pack"><span class="nav-text">例题1，Back pack</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A9%AC%E7%94%B2%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94Partition-Equal-Subset-Sum"><span class="nav-text">马甲变换——Partition Equal Subset Sum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Back-pack-II"><span class="nav-text">Back pack II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Coin-Change"><span class="nav-text">Coin Change</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Coin-Change-2"><span class="nav-text">Coin Change 2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%983%EF%BC%8C-K-Sum"><span class="nav-text">例题3， K Sum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ones-and-Zeroes"><span class="nav-text">Ones and Zeroes</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3Leetcode%E9%A2%98"><span class="nav-text">相关Leetcode题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Ugly-Number"><span class="nav-text">Ugly Number</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Burst-Balloons"><span class="nav-text">Burst Balloons</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jiayi797</span>
</div>



<div class="theme-info">
  <div class="powered-by">感谢hexo.Next</div>
  <span class="post-count">博客全站共字</span>
</div>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人次
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  




  
    <script type="text/javascript">
    (function(){
      var appid = 'cytmgt7V8';
      var conf = 'f20a47bca89136fdb1ce79762c886a35';
      var width = window.innerWidth || document.documentElement.clientWidth;
      if (width < 960) {
      window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){
        window.changyan.api.config({appid:appid,conf:conf})});
      }
    })();
    </script>
    <script type="text/javascript" src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script>
  



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (search_path.endsWith("json")) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  

</body>
</html>
