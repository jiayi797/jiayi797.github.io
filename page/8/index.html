<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
<!-- Referrer Policy调整致不蒜子单页面统计出错:https://senorui.top/posts/c33f.html -->
<meta name="referrer" content="no-referrer-when-downgrade">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jiayi797.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content=".">
<meta property="og:type" content="website">
<meta property="og:title" content="甲乙小朋友的房子">
<meta property="og:url" content="http://jiayi797.github.io/about/page/8/index.html">
<meta property="og:site_name" content="甲乙小朋友的房子">
<meta property="og:description" content=".">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="jiayi797">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://jiayi797.github.io/about/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>甲乙小朋友的房子</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">甲乙小朋友的房子</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">甲乙小朋友很笨，但甲乙小朋友不会放弃</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2017/11/05/%E7%AE%97%E6%B3%95-%E8%BF%9B%E9%98%B6Ladder/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/11/05/%E7%AE%97%E6%B3%95-%E8%BF%9B%E9%98%B6Ladder/" class="post-title-link" itemprop="url">进阶-ladder</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-11-05 13:45:03" itemprop="dateCreated datePublished" datetime="2017-11-05T13:45:03+08:00">2017-11-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:42:05" itemprop="dateModified" datetime="2018-12-17T15:42:05+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="follow-up-in-code-interview">Follow up in Code Interview</h1>
<p>必做 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">401. 排序矩阵中的从小到大第k个数 中等27 </span><br><span class="line">402. 和大于S的最小子数组 中等27 ——209 Minimum Size Subarray Sum</span><br><span class="line">403. 最长无重复字符的子串 中等23 —— 3 Longest Substring Without Repeating Characters </span><br><span class="line">404. 最多有k个不同字符的最长子字符串 中等27 —— 340，锁，Longest Substring with At Most K Distinct Characters   </span><br><span class="line">405. 两个排序数组和的第K小 困难 ——373 Find K Pairs with Smallest Sums</span><br></pre></td></tr></table></figure> <img src="https://i.loli.net/2017/11/05/59fea80f8d2e9.png" /></p>
<p>选做 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">543. N数组第K大元素 容易</span><br><span class="line">544. 两数和-小于或等于目标值 中等</span><br><span class="line">545. 无序数组K小元素 中等</span><br><span class="line">546. 三角形计数 中等</span><br><span class="line">547. 最小子串覆盖 中等</span><br><span class="line">548. 第k大元素 中等</span><br></pre></td></tr></table></figure> <img src="https://i.loli.net/2017/11/05/59fea9aa85e7f.png" /></p>
<h1 id="高级数据结构-上">高级数据结构-上</h1>
<table>
<thead>
<tr class="header">
<th>lintcode</th>
<th>知识点</th>
<th>leetcode</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>437. 图是否是树</td>
<td>并查集</td>
<td>261 Graph Valid Tree</td>
<td>√</td>
</tr>
<tr class="even">
<td>433. 岛屿的个数</td>
<td>并查集</td>
<td>200 Number of Islands</td>
<td>√</td>
</tr>
<tr class="odd">
<td>442. 岛屿的个数II</td>
<td>并查集</td>
<td>711 Number of Distinct Islands II</td>
<td>√</td>
</tr>
<tr class="even">
<td>443. 单词搜索 II</td>
<td>并查集</td>
<td>212 word search 2</td>
<td>√</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>441. 单词搜索</td>
<td>DFS</td>
<td>79 word search</td>
<td>√</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>l</th>
<th style="text-align: left;">知识点</th>
<th>leetcode</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>438. 单词的添加与查找</td>
<td style="text-align: left;">Trie</td>
<td>211 Add and Search Word - Data structure design</td>
<td>√</td>
</tr>
<tr class="even">
<td>438. 实现 Trie</td>
<td style="text-align: left;">Trie</td>
<td>208 Implement Trie (Prefix Tree)</td>
<td>√</td>
</tr>
<tr class="odd">
<td></td>
<td style="text-align: left;"></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td style="text-align: left;"></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td style="text-align: left;"></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td style="text-align: left;"></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td style="text-align: left;"></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td style="text-align: left;"></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td style="text-align: left;"></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>必做</p>
<p><img src="https://i.loli.net/2017/11/05/59fea9cfdf6f4.png" /></p>
<p>选做 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">477. 被围绕的区域 中等</span><br><span class="line">478. 拼字游戏 困难</span><br><span class="line">479. 单词矩阵 困难</span><br><span class="line">480. 两个排序数组和的第K小 困难</span><br><span class="line">481. 统计前面比自己小的数的个数 困难</span><br><span class="line">482. 区间求和 II 困难</span><br></pre></td></tr></table></figure> <img src="https://i.loli.net/2017/11/05/59fea9ef7e0b2.png" /></p>
<h1 id="高级数据结构-下">高级数据结构-下</h1>
<p>必做 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">575. 表达式展开 中等37 </span><br><span class="line">576. 接雨水 中等41 </span><br><span class="line">577. 用栈实现队列 中等33 </span><br><span class="line">578. 带最小值操作的栈 中等18 </span><br><span class="line">579. 滑动窗口的中位数 困难25 </span><br><span class="line">580. 接雨水 II 困难28 </span><br><span class="line">581. 最大矩形 困难33 </span><br><span class="line">582. 最大树 困难27 </span><br><span class="line">583. 直方图最大矩形覆盖 困难29 </span><br><span class="line">584. 数据流中位数 困难27 </span><br><span class="line">585. 滑动窗口的最大值 超难</span><br></pre></td></tr></table></figure> <img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-11-14-16-51-29.png" /></p>
<p>选做</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">475. 二叉树的最大路径和 II 中等</span><br><span class="line">476. 堆化 中等</span><br><span class="line">477. 用栈实现队列 中等</span><br><span class="line">478. 带最小值操作的栈 中等</span><br><span class="line">479. K步编辑 困难</span><br><span class="line">480. 最大矩形 困难</span><br><span class="line">481. 表达树构造 困难</span><br><span class="line">482. 将表达式转换为逆波兰表达式 困难</span><br><span class="line">483. 将表达式转换为波兰表达式 困难</span><br><span class="line">484. 表达式求值 困难</span><br><span class="line">485. 最大树 困难</span><br><span class="line">486. 直方图最大矩形覆盖 困难</span><br><span class="line">487. 大楼轮廓 超难</span><br></pre></td></tr></table></figure>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-11-14-16-52-38.png" /></p>
<h1 id="binary-search-sweep-line">Binary Search + Sweep Line</h1>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">必做</span><br><span class="line"></span><br><span class="line">141. x的平方根 容易17 </span><br><span class="line">142. 最大平均值子数组 中等32 </span><br><span class="line">143. 对x开根II 中等26 </span><br><span class="line">144. 数飞机 中等17 </span><br><span class="line">145. 两个整数相除 中等49 </span><br><span class="line">146. 寻找峰值 中等34 </span><br><span class="line">147. 第一个错误的代码版本 中等29 </span><br><span class="line">148. 书籍复印 困难37 </span><br><span class="line">149. 找峰值 II 困难23 </span><br><span class="line">150. 木材加工 困难</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2017/11/05/59feaa0e70009.png" /></p>
<p>选做 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">633. 寻找重复的数 中等</span><br><span class="line">634. 包裹黑色像素点的最小矩形 困难</span><br><span class="line">635. 大楼轮廓 超难</span><br></pre></td></tr></table></figure> <img src="https://i.loli.net/2017/11/05/59feaa22bea71.png" /></p>
<h1 id="动态规划-上">动态规划-上</h1>
<p>必做 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">397. 最长上升连续子序列 容易39 </span><br><span class="line">398. 最大子数组 容易29 </span><br><span class="line">399. 最大正方形 中等28 </span><br><span class="line">400. 最长回文子串 中等32 </span><br><span class="line">401. 硬币排成线 II 中等42 </span><br><span class="line">402. 硬币排成线 中等33 </span><br><span class="line">403. 打劫房屋 中等30 </span><br><span class="line">404. 乘积最大子序列 中等30 </span><br><span class="line">405. 最长上升子序列 中等28 </span><br><span class="line">406. 最长上升连续子序列 II 困难</span><br></pre></td></tr></table></figure> <img src="https://i.loli.net/2017/11/05/59feaa404974a.png" /></p>
<p>选做 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">631. 最大矩阵II 中等</span><br><span class="line">632. 最长重复子序列 中等</span><br><span class="line">633. 书籍复印 II 困难</span><br><span class="line">634. 书籍复印 困难</span><br><span class="line">635. 邮局问题 困难</span><br><span class="line">636. 硬币排成线 III 困难</span><br><span class="line">637. 买卖股票的最佳时机 IV 困难</span><br></pre></td></tr></table></figure> <img src="https://i.loli.net/2017/11/05/59feaa51d062f.png" /></p>
<h1 id="动态规划---下">动态规划 - 下</h1>
<h1 id="面试当中的常见算法拓展">面试当中的常见算法拓展</h1>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2017/11/03/%E7%AE%97%E6%B3%95-%E5%A0%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/11/03/%E7%AE%97%E6%B3%95-%E5%A0%86/" class="post-title-link" itemprop="url">算法-堆</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-11-03 13:54:21" itemprop="dateCreated datePublished" datetime="2017-11-03T13:54:21+08:00">2017-11-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-30 19:35:49" itemprop="dateModified" datetime="2022-07-30T19:35:49+08:00">2022-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>堆(heap)又被为优先队列(priority queue)。尽管名为优先队列，但堆并不是队列。回忆一下，在<a target="_blank" rel="noopener" href="http://www.cnblogs.com/vamei/archive/2013/03/15/2961729.html">队列</a>中，我们可以进行的限定操作是dequeue和enqueue。dequeue是按照进入队列的先后顺序来取出元素。而在堆中，我们不是按照元素进入队列的先后顺序取出元素的，而是按照元素的优先级取出元素。</p>
<p>这就好像候机的时候，无论谁先到达候机厅，总是头等舱的乘客先登机，然后是商务舱的乘客，最后是经济舱的乘客。每个乘客都有头等舱、商务舱、经济舱三种个键值(key)中的一个。头等舱-&gt;商务舱-&gt;经济舱依次享有从高到低的优先级。</p>
<p>Linux内核中的调度器(scheduler)会按照各个进程的优先级来安排CPU执行哪一个进程。计算机中通常有多个进程，每个进程有不同的优先级(该优先级的计算会综合多个因素，比如进程所需要耗费的时间，进程已经等待的时间，用户的优先级，用户设定的进程优先程度等等)。内核会找到优先级最高的进程，并执行。如果有优先级更高的进程被提交，那么调度器会转而安排该进程运行。优先级比较低的进程则会等待。“堆”是实现调度器的理想数据结构。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2017/11/03/%E7%AE%97%E6%B3%95-%E5%A0%86/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2017/11/02/%E7%AE%97%E6%B3%95-DP-%E9%92%A2%E6%9D%A1%E5%88%87%E5%89%B2%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/11/02/%E7%AE%97%E6%B3%95-DP-%E9%92%A2%E6%9D%A1%E5%88%87%E5%89%B2%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">算法-DP-钢条切割问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-11-02 14:55:10" itemprop="dateCreated datePublished" datetime="2017-11-02T14:55:10+08:00">2017-11-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:42:04" itemprop="dateModified" datetime="2018-12-17T15:42:04+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在说钢条切割问题之前，我们先说说动态规划。</p>
<p><strong>动态规划</strong>——Dynamic programming(这个词指表格)：通过组合子问题的解求解原问题。</p>
<p><strong>与分治法对比：</strong></p>
<ol type="1">
<li>相同点：都是通过子问题组合求解原问题</li>
<li>不同点：分治法将问题划分为<strong>不相交</strong>的子问题，求解再合并。动态规划应用于<strong>子问题重叠</strong>的情况，即<strong>不同</strong>的子问题具有<strong>公共</strong>的子子问题，此时如果用分治法就会出现重复计算求解。为了避免重复动态规划对子问题只求解一次，将其保存在表格中，从而无需每求解一个子子问题时重复计算。</li>
</ol>
<p><strong>求解步骤</strong></p>
<ol type="1">
<li>刻画最优解的结构特征</li>
<li>递归定义最优解的值</li>
<li>计算最优解的值，通常采用自底向上的方法（可能需要同时维护一些额外信息）</li>
<li>利用计算出的信息构造最优解（不是必须）</li>
</ol>
<h1 id="钢条切割">钢条切割</h1>
<p>Serling公司购买一根长钢管，将其切割成短钢管出售，给定钢管长度和对应的价钱如下表：</p>
<figure>
<img src="https://i.loli.net/2017/10/31/59f7536b8fc8f.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>问题要求根据上面的价格，给出最佳的切割方案，使得收益最大。</p>
<p>以n=4为例，可以将钢条切割成如下图所示的8种情况，其中收益最大的是(c)：</p>
<figure>
<img src="https://ooo.0o0.ooo/2017/10/30/59f73938d2f50.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>这个题的切入点非常重要，也就是——当知道长度为1到i的钢条的切割方案时，可以推导出长度为i+1的钢条如何切割最优。</p>
<p>我们定义长度=i，且长度为i时最优切割方案的收益是<span class="math inline">\(r_i\)</span></p>
<ul>
<li>i=1时， 当然不切割，即<span class="math inline">\(r_1=p_1\)</span></li>
<li>i=2时，有两种方案，要么切一刀，要么不切，即<span class="math inline">\(r_2=max[p_2,r_1+r_1]\)</span></li>
<li>i=3时，我们从下图可以看到，假设我们从它上面随便切一刀，我们会发现无论是左边还是右边都是已知的。即<span class="math inline">\(r_3=max[p_3,r_1+r_2,r_2+r_1]\)</span></li>
<li>i=4时，还是可以看到，无论我们从哪里切一刀，会发现无论是左边还是右边，都是已知的！即<span class="math inline">\(r_4=max[p_4,r_1+r_3,r_2+r_2,r_3+r_1]\)</span></li>
</ul>
<p><img src="https://i.loli.net/2017/11/02/59fb152d32886.png" /></p>
<p>因此，我们可以用<strong>更短的钢条的最优切割收益</strong>来描述它：</p>
<p><span class="math display">\[r_n = max[p_n,r_1+r_{n-1},r_2+r_{n-2},...,r_{n-1}+r_1]\]</span></p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int[] q;</span><br><span class="line">private void solve(int n,int k,int[] p)&#123;</span><br><span class="line">    if(k&gt;n)return;</span><br><span class="line">    //长度k的钢条</span><br><span class="line">    q[k] = p[k];</span><br><span class="line">    //遍历，也就是计算max = [r_1+r_&#123;n-1&#125;,r_2+r_&#123;n-2&#125;,...,r_&#123;n-1&#125;+r_1]</span><br><span class="line">    for(int i=1;i&lt;k;i+=1)&#123;</span><br><span class="line">        q[k] = Math.max(q[i]+ q[k-i], q[k]);</span><br><span class="line">    &#125;</span><br><span class="line">    solve(n,k+1,p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="钢条切割升级版">钢条切割升级版</h1>
<p>《算法导论》练习题15.1-3提出：除了切割下的钢条段具有不同价格<span class="math inline">\(p_i\)</span>外，每次切割还要付出固定成本<span class="math inline">\(c\)</span>。求修改后的钢条切割问题。</p>
<p><img src="https://i.loli.net/2017/11/02/59fb1b5eabefa.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int[] q;</span><br><span class="line"></span><br><span class="line">private void solve(int n,int k,int[] p,int c)&#123;</span><br><span class="line">    if(k&gt;n)return;</span><br><span class="line">    //长度k的钢条</span><br><span class="line">    q[k] = p[k];</span><br><span class="line">    for(int i=1;i&lt;k;i+=1)&#123;</span><br><span class="line">        q[k] = Math.max(q[i]+ q[k-i] - c, q[k]);</span><br><span class="line">    &#125;</span><br><span class="line">    solve(n,k+1,p,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2017/10/31/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/31/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">深度学习算法-卷积网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-31 15:58:36" itemprop="dateCreated datePublished" datetime="2017-10-31T15:58:36+08:00">2017-10-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:42:03" itemprop="dateModified" datetime="2018-12-17T15:42:03+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">深度学习算法</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">卷积网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一般来说，图片是非常大的。至少有<span class="math inline">\(n\times n\times 3\)</span>的像素，即有这么多特征。 对于小尺寸的图片问题，也许我们用深度神经网络的结构可以较为简单的解决一定的问题。但是当应用在大尺寸的图片上，输入规模将变得十分庞大，使用神经网络将会有非常多的参数需要去学习，这个时候神经网络就不再适用。</p>
<p>卷积神经网络在计算机视觉问题上是一个非常好的网络结构。</p>
<h1 id="概述">概述</h1>
<h2 id="图像识别过程">图像识别过程</h2>
<p>当我们给定一个"X"的图案，计算机怎么识别这个图案就是“X”呢？一个可能的办法就是计算机存储一张标准的“X”图案，然后把需要识别的未知图案跟标准"X"图案进行比对，如果二者一致，则判定未知图案即是一个"X"图案。</p>
<p>而且即便未知图案可能有一些平移或稍稍变形，依然能辨别出它是一个X图案。如此，CNN是把未知图案和标准X图案一个局部一个局部的对比，如下图所示：</p>
<p><img src="https://i.loli.net/2017/11/02/59fa7bbb36b29.png" /></p>
<p><strong>而未知图案的局部和标准X图案的局部一个一个比对时的计算过程，便是卷积操作</strong>。卷积计算结果为1表示匹配，否则不匹配。</p>
<h2 id="图像边缘检测">图像边缘检测</h2>
<p>卷积运算是卷积神经网络的基本组成部分。下面以边缘检测的例子来介绍卷积运算。</p>
<p>所谓边缘检测，在下面的图中，分别通过垂直边缘检测和水平边缘检测得到不同的结果：</p>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-12-06-14-38-35.png" /></p>
<p><strong>垂直边缘检测：</strong></p>
<p>假设对于一个 6×6 大小的图片（以数字表示），以及一个 3×3 大小的 <strong>filter</strong>（卷积核） 进行卷积运算，以“∗”符号表示。图片和垂直边缘检测器分别如左和中矩阵所示：</p>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-12-06-14-40-48.png" /></p>
<p><strong>filter</strong> 不断地和其大小相同的部分做【对应元素的乘法运算并求和】，最终得到的数字相当于新图片的一个像素值，如右矩阵所示，最终得到一个 4×4 大小的图片。</p>
<p><strong>边缘检测的原理：</strong></p>
<p>以一个有一条垂直边缘线的简单图片来说明。通过垂直边缘 <strong>filter</strong> 我们得到的最终结果图片可以明显地将边缘和非边缘区分出来：</p>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-12-06-14-41-29.png" /></p>
<p>卷积运算提供了一个方便的方法来检测图像中的边缘，成为卷积神经网络中重要的一部分。</p>
<p><strong>多种边缘检测：</strong></p>
<p>垂直和水平边缘检测</p>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-12-06-15-05-41.png" /></p>
<p>更复杂的<strong>filter</strong></p>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-12-06-15-05-55.png" /></p>
<p>对于复杂的图片，我们可以直接将<strong>filter</strong>中的数字直接看作是需要学习的参数，其可以学习到对于图片检测相比上面filter更好的更复杂的<strong>filter</strong>，如相对于水平和垂直检测器，我们训练的 filter 参数也许可以知道不同角度的边缘。</p>
<p>通过卷积运算，在卷积神经网络中通过反向传播算法，可以学习到相应于目标结果的<strong>filter</strong>，将其应用于整个图片，输出其提取到的所有有用的特征。</p>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-12-06-15-06-48.png" /></p>
<h2 id="卷积网络结构">卷积网络结构</h2>
<p>本节主要来自参考文献<a target="_blank" rel="noopener" href="http://blog.csdn.net/v_july_v/article/details/51812459">CNN笔记：通俗理解卷积神经网络</a></p>
<p><a target="_blank" rel="noopener" href="http://cs231n.github.io/convolutional-networks/#overview">cs231n</a>课程里给出了卷积神经网络各个层级结构，如下图：</p>
<figure>
<img src="http://img.blog.csdn.net/20160702205047459" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>图中CNN要做的事情是：给定一张图片，是车还是马未知，是什么车也未知，现在需要模型判断这张图片里具体是一个什么东西，总之输出一个结果：如果是车，那是什么车。</p>
<p>上图的网络结构为：</p>
<ul>
<li>最左边是数据输入层，对数据做一些处理，比如去均值（把输入数据各个维度都中心化为0，避免数据过多偏差，影响训练效果）、归一化（把所有的数据都归一到同样的范围）、PCA/白化等等。CNN只对训练集做“去均值”这一步。</li>
<li>中间是
<ul>
<li>CONV：卷积计算层，线性乘积求和。</li>
<li>ReLU：激励层，上文2.2节中有提到：ReLU是激活函数的一种。</li>
<li>POOL：池化层，简言之，即取区域平均或最大。</li>
</ul></li>
<li>最右边是
<ul>
<li>FC：全连接层</li>
</ul></li>
</ul>
<p>这几个部分中，卷积计算层是CNN的核心，下文将重点阐述。</p>
<p>接下来，我们详细介绍一下这几个部分。</p>
<h1 id="卷积网络结构-1">卷积网络结构</h1>
<p>卷积网络结构如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输入层  --&gt;  卷积计算层  --&gt; 激励层 --&gt; 池化层  </span><br><span class="line">       --&gt;  卷积计算层  --&gt; 激励层 --&gt; 池化层  </span><br><span class="line">       --&gt; ...</span><br><span class="line">--&gt;全连接层</span><br></pre></td></tr></table></figure>
<p>卷积网络中一个典型层包括三级：卷积计算层、激励层（探测层）和池化层。</p>
<p>通过上一步的卷积运算，然后经过了激活函数，我们将此时的输入会输入池化层。</p>
<p><img src="https://i.loli.net/2017/10/31/59f881a6783fa.png" /></p>
<p><strong>卷积层</strong>：并行计算多个卷积，产生一组线性激活响应；</p>
<p><strong>激励层(探测层)</strong>(detector stage)：每个线性激活响应会通过一个非线性激活函数；</p>
<p><strong>池化层</strong>：我们使用池化(pooling)函数来进一步调整这一层的输出。</p>
<h2 id="卷积计算层">卷积计算层</h2>
<p>卷积计算层最重要的就是卷积运算。接下来我们介绍卷积运算。</p>
<h3 id="卷积运算">卷积运算</h3>
<p>假设我们在用激光传感器追踪宇宙飞船的位置，<span class="math inline">\(t\)</span>时刻位置在<span class="math inline">\(x(t)\)</span>。</p>
<p>为了更好地估计，我们将时间越近的测量给予更高的权重<span class="math inline">\(w(a)\)</span>，其中<span class="math inline">\(a\)</span>表示测量结果距当前的时间间隔，那么：</p>
<p><span class="math display">\[s(t)=\int x(a)w(t-a)da = (x*w)(t)\]</span></p>
<p>tips: <span class="math inline">\(a\)</span>：距离当前时间的间隔； <span class="math inline">\(x(a)\)</span>：<span class="math inline">\(a\)</span>时刻，飞船位置，<span class="math inline">\(x\)</span>也叫输入 <span class="math inline">\(w(t-a)\)</span>：<span class="math inline">\(t-a\)</span>时刻，也就是a秒前，飞船的权重，也是一种概率密度，叫做核函数</p>
<p>离散形式的卷积是： <span class="math display">\[s(t)=(x*w)(t)=\sum_{\alpha=-\infty}^{\infty}x(a)w(t-a)\]</span></p>
<p>二维形式的卷积（我们定义核为K）：</p>
<p><span class="math display">\[S(i,j)=(I*K)(i,j)=\sum_m \sum_n I(m,n)K(i-m,j-n)\]</span></p>
<p>卷积是可交换的，也可写作：</p>
<p><span class="math display">\[S(i,j)=(K*I)(i,j)=\sum_m \sum_n I(i-m,j-n)K(m,n)\]</span></p>
<p>出现上面可交换的原因是：我们将核的相对输入进行了翻转，也相当于一种变量替换；</p>
<p>然而，在许多神经网络中采用的是<strong>互相关函数(cross-correlation)</strong>：</p>
<p><span class="math display">\[S(i,j)=(I*K)(i,j)=\sum_m \sum_n I(i+m,j+n)K(m,n)\]</span></p>
<p>这个是不可交换的。</p>
<p>在数学定义上，矩阵的<strong>卷积</strong>（convolution）操作为首先将卷积核同时在水平和垂直方向上进行翻转，构成一个卷积核的镜像，然后使用该镜像再和前面的矩阵进行移动相乘求和操作。如下面例子所示：</p>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-12-06-15-07-46.png" /></p>
<p>在深度学习中，我们称为的卷积运算实则没有卷积核变换为镜像的这一步操作，因为在权重学习的角度，变换是没有必要的。深度学习的卷积操作在数学上准确度来说称为<strong>互相关</strong>（cross-correlation）。</p>
<p>一般来说，图像领域的卷积用的就是互相关函数。参考文献<a target="_blank" rel="noopener" href="http://blog.csdn.net/v_july_v/article/details/51812459">CNN笔记：通俗理解卷积神经网络</a>对卷积的定义是：对图像（不同的数据窗口数据）和滤波矩阵（一组固定的权重：因为每个神经元的多个权重固定，所以又可以看做一个恒定的滤波器filter）做内积（逐个元素相乘再求和）的操作就是所谓的『卷积』操作，也是卷积神经网络的名字来源。</p>
<hr />
<h3 id="卷积计算层-1">卷积计算层</h3>
<p>举个具体的例子。比如下图中，图中左边部分是原始输入数据，图中中间部分是滤波器filter(有个高大上的名字叫<strong>卷积核</strong>)，图中右边是输出的新的二维数据。</p>
<p><img src="https://i.loli.net/2017/11/02/59fa7db46ec71.png" /></p>
<p>即将下面 两个矩阵对应位置先相乘，后相加：</p>
<p><img src="https://i.loli.net/2017/11/02/59fa7dcd89f03.png" /> <span class="math display">\[*\]</span><img src="https://i.loli.net/2017/11/02/59fa7de2c136e.png" /> <span class="math display">\[=\]</span><img src="https://i.loli.net/2017/11/02/59fa7df2b7759.png" /></p>
<p><img src="https://i.loli.net/2017/11/02/59fa82a30ef95.png" /></p>
<p>在CNN中，滤波器filter（带着一组固定权重的神经元）对局部输入数据进行卷积计算。每计算完一个数据窗口内的局部数据后，数据窗口不断平移滑动，直到计算完所有数据。这个过程中，有这么几个参数：</p>
<h4 id="depth-深度">Depth-深度</h4>
<p>神经元个数，决定输出的depth厚度。同时代表滤波器个数。</p>
<h4 id="stride-步长">Stride-步长</h4>
<p>决定滑动多少步可以到边缘。</p>
<p>以s表示stride的大小，那么在进行卷积运算后，图片的变化为：<span class="math inline">\(n×n –&gt; ⌊\frac{n+2p−f}{s}+1⌋×⌊\frac{n+2p−f}{s}+1⌋\)</span>。</p>
<p>注意，在当padding≠1时，若移动的窗口落在图片外面时，则不要再进行相乘的操作，丢弃边缘的数值信息，所以输出图片的最终维度为<strong>向下取整</strong>。</p>
<h4 id="padding-填充值">Padding-填充值</h4>
<p>在外围边缘补充若干圈0，方便从初始位置以步长为单位可以刚好滑到末尾位置，通俗地讲就是为了总长能被步长整除。</p>
<p>没有Padding的缺点 ：</p>
<ol type="1">
<li>每次卷积操作，图片会缩小； 就前面的例子来说，6×6 大小的图片，经过 3×3 大小的 filter，缩小成了 4×4 大小 。图片：n×n –&gt; (n−f+1)×(n−f+1)</li>
<li>角落和边缘位置的像素进行卷积运算的次数少，可能会丢失有用信息。 其中，n表示图片的长或宽的大小，f表示filter的长或宽的大小。</li>
</ol>
<p>有Padding ：</p>
<ol type="1">
<li>为了解决上面的两个缺点，我们在进行卷积运算前为图片加padding，包围角落和边缘的像素，使得通过filter的卷积运算后，图片大小不变，也不会丢失角落和边沿的信息。</li>
</ol>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-12-06-15-11-15.png" /></p>
<p>以p表示 Padding 的值，则输入n×n大小的图片，最终得到的图片大小为 (n+2p−f+1)×(n+2p−f+1)，为使图片大小保持不变，需根据filter的大小调整p的值。</p>
<p><img src="https://ooo.0o0.ooo/2017/11/02/59fa7f3498ba3.png" /></p>
<h3 id="卷积计算的过程">卷积计算的过程</h3>
<p>对于灰色图像中，卷积核和图像均是二维的。而应用于彩色图像中，因为图片有R、G、B三个颜色通道，所以此时的卷积核应为<strong>三维卷积核</strong>。</p>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-12-06-15-19-44.png" /></p>
<p>单个卷积核应用于图片时，提取图片特定的特征，不同的卷积核提取不同的特征。如两个大小均为3×3×3 的卷积核分别提取图片的垂直边缘和水平边缘。</p>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-12-06-15-20-50.png" /></p>
<p>由图可知，最终提取到彩色图片的垂直特征图和水平特征图，得到有2个通道的4×4大小的特征图片。</p>
<p>这张gif诠释了三维、两个卷积核的卷积过程：</p>
<p>输入图像：三维</p>
<p>卷积核W0和W1：分别都是三维</p>
<p><img src="http://img.blog.csdn.net/20160707204048899" /></p>
<p>可以看到：</p>
<ul>
<li>两个神经元，即depth=2，意味着有两个滤波器。</li>
<li>数据窗口每次移动两个步长取3*3的局部数据，即stride=2。</li>
<li>zero-padding=1。</li>
</ul>
<p>然后分别以两个滤波器filter为轴滑动数组进行卷积计算，得到两组不同的结果。</p>
<p>​ 如果初看上图，可能不一定能立马理解啥意思，但结合上文的内容后，理解这个动图已经不是很困难的事情：</p>
<ul>
<li>蓝色输入（**7*7*3**中，7*7代表图像的像素/长宽，3代表R、G、B 三个颜色通道）</li>
<li>红色是两个不同的滤波器Filter w0、Filter w1</li>
<li>绿色则是两个不同的输出，每一个格子都等于一次滤波窗口内的内积和（RGB三通道相加）</li>
</ul>
<p>​ 随着左边数据窗口的平移滑动，滤波器Filter w0 / Filter w1对不同的局部数据进行卷积计算。如果这一部分看不明白，可以继续看<a target="_blank" rel="noopener" href="http://blog.csdn.net/v_july_v/article/details/51812459">CNN笔记：通俗理解卷积神经网络</a>，这里讲的非常详细。</p>
<h4 id="单层卷积网络">单层卷积网络</h4>
<p>和普通的神经网络单层前向传播的过程类似，卷积神经网络也是一个先由输入和权重及偏置做线性运算，然后得到的结果输入一个激活函数中，得到最终的输出：</p>
<p><span class="math display">\[z^{[1]}=w^{[1]}a^{[0]}+b^{[1]}\]</span></p>
<p><span class="math display">\[a^{[1]}=g(z^{[1]})\]</span></p>
<p>不同点是在卷积神经网络中，权重和输入进行的是卷积运算。</p>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-12-06-15-28-06.png" /></p>
<p><strong>单层卷积的参数个数：</strong></p>
<p>在一个卷积层中，如果我们有10个 3×3×3 大小的卷积核，那么加上每个卷积核对应的偏置，则对于一个卷积层，我们共有的参数个数为：</p>
<p><span class="math display">\[(3×3×3+1)×10=280\]</span></p>
<p>无论图片大小是多少，该例子中的卷积层参数个数一直都是280个，相对于普通的神经网络，卷积神经网络的参数个数要少很多。</p>
<h4 id="多层卷积网络">多层卷积网络</h4>
<p>多层卷积构成卷积神经网络，下面是一个卷积神经网络的例子：</p>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-12-06-15-30-34.png" /></p>
<h2 id="激励层">激励层</h2>
<p>几种不同的激活函数<span class="math inline">\(g(x)\)</span>：</p>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-12-06-14-16-43.png" /></p>
<ul>
<li><p>sigmoid：</p>
<p><span class="math display">\[a = \frac{1}{1+e^{-z}}\]</span></p>
<p>导数：<span class="math inline">\(a′=a(1−a)\)</span></p></li>
<li><p>tanh：</p>
<p><span class="math display">\[a = \frac{e^z - e^{-z}}{e^z + e{-z}}\]</span></p>
<p>导数：<span class="math inline">\(a′=1−a2\)</span></p></li>
<li><p>ReLU（修正线性单元）： <span class="math display">\[a=max(0,z)\]</span></p></li>
<li><p>Leaky ReLU： <span class="math display">\[a=max(0.01z,z)\]</span></p></li>
</ul>
<p><strong>激活函数的选择</strong></p>
<p>sigmoid函数和tanh函数比较：</p>
<ul>
<li>隐藏层：tanh函数的表现要好于sigmoid函数，因为tanh取值范围为[−1,+1]，输出分布在0值的附近，均值为0，从隐藏层到输出层数据起到了归一化（均值为0）的效果。</li>
<li>输出层：对于二分类任务的输出取值为{0,1}，故一般会选择sigmoid函数。</li>
</ul>
<p>然而sigmoid和tanh函数在当|z|很大的时候，梯度会很小，在依据梯度的算法中，更新在后期会变得很慢。在实际应用中，要使|z|尽可能的落在0值附近。</p>
<p>ReLU弥补了前两者的缺陷，当z&gt;0时，梯度始终为1，从而提高神经网络基于梯度算法的运算速度。然而当z&lt;0时，梯度一直为0，但是实际的运用中，该缺陷的影响不是很大。</p>
<p>Leaky ReLU保证在z&lt;0的时候，梯度仍然不为0。</p>
<p>在选择激活函数的时候，如果在不知道该选什么的时候就选择ReLU，当然也没有固定答案，要依据实际问题在交叉验证集合中进行验证分析。</p>
<h2 id="池化层">池化层</h2>
<p><strong>池化函数</strong></p>
<p>使用某一位置的相邻输出的总体统计特征来代替网络再该位置的输出。</p>
<p>最大池化函数：给出相邻矩形区域内的最大值。</p>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-12-06-15-33-58.png" /></p>
<p>在最大池化中，有一组超参数需要进行调整，其中，$f <span class="math inline">\(表示池化的大小，\)</span>s$表示步长。</p>
<ul>
<li>池化前：<span class="math inline">\(n×n\)</span></li>
<li>池化后：<span class="math inline">\(⌊\frac{n+2p−f}{s}+1⌋×⌊\frac{n+2p−f}{s}+1⌋\)</span></li>
</ul>
<p>此外还有平均池化、最小池化等等。注意，池化层没有需要学习的参数。</p>
<p><strong>池化的用途</strong></p>
<p>池化函数帮助输入近似不变：即当我们对输入进行少量平移时，经过池化函数后的大多数输出并不会发生改变。通俗地说就是——为了让我们的网络具有平移不变形（我的理解是无论输入轻微旋转或平移，输出都不变），我们引入池化这个骚操作来达到这个目的。</p>
<p>例如下图所示的例子。上图是一个网络，下图是一个网络，每个网络的下层是非线性输出，上层是最大池化输出。下图的非线性输出是通过向右平移一个像素得到的。我们可以发现，池化层的输出只有一半发生了改变，这是因为最大池化单元只对周围的最大值较敏感，而不是精确的位置。</p>
<p><img src="https://i.loli.net/2017/11/01/59f939076125c.png" /></p>
<p>当我们只关心某个特征是否出现（比如是否有眼睛），而不关心它的具体位置时，局部平移不变性是一个非常有用的性质。</p>
<p>对空间区域进行池化产生了平移不变性。下图是一种学习不变性的实例：反映的是池化的旋转不变性，对于输入手写5，有三个滤波器分别检测选择不同角度的手写5。当滤波器和对应的手写5匹配时，滤波器会得到一个较大的激活值，然后池化会选择得到最大的激活值，无论手写5是怎样的旋转的。</p>
<p><img src="https://ooo.0o0.ooo/2017/11/01/59f95b688c95b.png" /></p>
<p>总的来说就是：通过卷积后，为了引入不变性，同时防止过拟合问题或欠拟合问题、降低计算量，我们常进行池化处理。</p>
<h1 id="卷积网络的优势">卷积网络的优势</h1>
<p>我们先说一下卷积网络的概念：卷积神经网络（Convolutional Neural Networks）的卷积操作是通过可训练的滤波器对上一层的输出进行卷积求和，然后添加上偏移量经过激活函数，得到了特征映射图作为下一层的输入。卷积操作相对于传统神经网络主要有稀疏链接、权值共享和等变表达的特性。</p>
<p>卷积通过三个重要思想来帮助改进机器学习系统：稀疏交互、参数共享、等变表示。</p>
<p>与普通的全连接神经网络相比，卷积神经网络的参数更少。如图中的例子，卷积神经网络仅有6×(5×5+1)=156个参数，而普通的全连接网络有3072×4704≈14M个参数。</p>
<p><strong>稀疏交互</strong></p>
<p>对于一张图像来说，输入图像可能包含上千万像素点。但我们可以通过只占用几十或几百的核来检测一些小的但有意义的特征，例如图像边缘。即——在每一层中，每个输出值只取决于少量的输入，也就是稀疏交互。</p>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-12-06-15-51-25.png" /></p>
<p>下图是一种稀疏连接的例子，从下往上看，我们强调了一个输入单元<span class="math inline">\(x_3\)</span>以及<span class="math inline">\(s\)</span>中受该单元影响的输出单元。这个是当<span class="math inline">\(s\)</span>由核宽度为3的卷积产生的，只有3个输出受到了<span class="math inline">\(x\)</span>的影响：</p>
<p><img src="https://i.loli.net/2017/10/31/59f865cb07946.png" /></p>
<p>从另一个角度，从上往下看，这次我们抢到了一个输出单元<span class="math inline">\(s_3\)</span>以及<span class="math inline">\(x\)</span>中影响该单元的输入单元。这些单元被称为<span class="math inline">\(s_3\)</span>的<strong>接受域</strong>。</p>
<p><img src="https://i.loli.net/2017/10/31/59f86ae962147.png" /></p>
<p>从深层的网络来看，我们可以看到尽管连接稀疏，但处在更深层的单元可以间接地连接到全部或大部分输入图像中。</p>
<p><img src="https://i.loli.net/2017/10/31/59f86aff4a4b1.png" /></p>
<p><strong>参数共享</strong></p>
<p>一个特征检测器（filter）对图片的一部分有用的同时也有可能对图片的另外一部分有用。</p>
<p>因为核的每一个元素都作用在输入的每一个位置上，因此卷积运算会导致用于一个输入的权重也会被绑定在其它权重上。这样的参数共享保证了我们只需要学习一个参数集合，而不是对每一个位置都需要学习一个单独的参数集合。如下图所示，黑色箭头表示两个不同模型中使用了特殊的参数连接。灰色箭头表示它用了黑色箭头的参数。其实就是一个<span class="math inline">\(x\)</span>只有一个参数，但这个参数被用于了多个下一层。</p>
<p><img src="https://i.loli.net/2017/10/31/59f86f09c700e.png" /></p>
<p>对于卷积，参数共享的特殊形式使得神经网络层具有对<strong>平移等变的性质</strong>：先平移后卷积=先卷积后平移。</p>
<p><strong>边缘检测的例子</strong></p>
<p>如图所示，我们使用每个像素减去左边相邻像素形成的。这其实就是一种最简单的卷积。</p>
<p><img src="https://i.loli.net/2017/10/31/59f879f482dd9.png" /></p>
<h1 id="训练卷积神经网络">训练卷积神经网络</h1>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-12-06-16-04-01.png" /></p>
<p>我们将训练集输入到卷积神经网络中，对网络进行训练。利用梯度下降（Adam、momentum等优化算法）最小化代价函数来寻找网络最优的参数。</p>
<h1 id="复杂度">复杂度</h1>
<h2 id="卷积网络的时间复杂度">卷积网络的时间复杂度</h2>
<h3 id="单个卷积层的时间复杂度">单个卷积层的时间复杂度</h3>
<p><span class="math display">\[O(M^2 K^2 C_{in}C_{out})\]</span></p>
<ul>
<li>M : 每个卷积核输出特征图（feature map）的边长
<ul>
<li><strong>输出</strong>特征图尺寸本身又由<strong>输入</strong>矩阵尺寸 X 、卷积核尺寸K、填充大小Padding、步长Stride 这四个参数所决定，表示如下： <span class="math display">\[M = (X - K + 2 * Padding) / Stride + 1\]</span></li>
</ul></li>
<li>K : 每个卷积核的边长</li>
<li>Cin : 每个卷积核的通道数，也即输入通道数，也即上一层的输出通道数</li>
<li>Cout : 本卷积层具有的卷积核个数，也即输出通道数</li>
</ul>
<h3 id="卷积神经网络整体的时间复杂度">卷积神经网络整体的时间复杂度</h3>
<p><span class="math display">\[O\sum_{l = 1}^D(M^2_l K_l ^2 C_{l-1}C_{l})\]</span></p>
<ul>
<li>D : 网络深度</li>
</ul>
<h2 id="卷积网络的空间复杂度">卷积网络的空间复杂度</h2>
<p><span class="math display">\[O(\sum_{l = 1}^D K_l^2 C_{l - 1}C_l)\]</span></p>
<ul>
<li>与输入数据大小无关</li>
<li>当我们需要裁剪模型时，由于卷积核的尺寸通常已经很小，而网络的深度又与模型的能力紧密相关，不宜过多削减，因此模型裁剪通常最先下手的地方就是通道数</li>
</ul>
<h1 id="参考文献">参考文献</h1>
<ol type="1">
<li><a href="">深度学习</a></li>
<li><a target="_blank" rel="noopener" href="http://www.datagrand.com/blog/neural.html">达观数据深度学习</a></li>
<li><a target="_blank" rel="noopener" href="http://www.dlworld.cn/ZiLiaoXiaZai/1757.html">深度学习笔记（一）卷积神经网络(Convolutional Neural Networks)</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/v_july_v/article/details/51812459">CNN笔记：通俗理解卷积神经网络</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/31575074">卷积神经网络的复杂度分析</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2017/10/26/%E6%95%B0%E5%AD%A6-%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/26/%E6%95%B0%E5%AD%A6-%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/" class="post-title-link" itemprop="url">数学-最大似然估计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-26 21:03:27" itemprop="dateCreated datePublished" datetime="2017-10-26T21:03:27+08:00">2017-10-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:42:03" itemprop="dateModified" datetime="2018-12-17T15:42:03+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">数学</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>其实在之前的博客<a href="https://jiayi797.github.io/2017/07/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%9A%84%E7%90%86%E8%A7%A3/">朴素贝叶斯的理解</a>一文中曾经提到过最大似然估计。</p>
<p>极大似然估计的核心思想是：我们已知<span class="math inline">\(x\)</span>已发生，我们再根据实际情况写出<span class="math inline">\(x\)</span>发生的概率<span class="math inline">\(p(x;θ)\)</span>。目标函数是使得这个概率<span class="math inline">\(p(x;θ)\)</span>最大，然后求得<span class="math inline">\(θ\)</span>：</p>
<p><span class="math display">\[\theta_{ML}=arg max_\theta p(X;\theta)=arg max_\theta ∏_{i=1}^mp(x^{i};\theta)\]</span> <font size=2.5>上公式中： <span class="math inline">\(p(X;\theta)\)</span>是样本集<span class="math inline">\(X\)</span>出现的概率； <span class="math inline">\(p(x^{i};\theta)\)</span>是某个样本出现的概率； 左式等于右式原因是每个样本出现的概率独立； </font></p>
<p>多个数的连乘容易溢出，我们可以将它转化为log运算： <span class="math display">\[\theta_{ML}=arg max_\theta \sum{i=1}^mlog p(x^{i};\theta)\]</span> 将上式除以<span class="math inline">\(m\)</span>，得到一种期望： <span class="math display">\[\theta_{ML}=arg max_\theta E_{x\text{~}p&#39;_{data}}log p(x^{i};\theta) \tag{公式1}\]</span> 这个式子的含义是：在经验分布<span class="math inline">\(x\text{~}p^`\)</span>上，求得一个<span class="math inline">\(\theta\)</span>，使得模型分布的期望最大化。</p>
<p>此时我们暂时先不看上面这个公式。我们从另一个角度——误差来衡量。训练集上的经验分布<span class="math inline">\(p&#39;_{data}​\)</span>和模型之间的分布差异可以用KL散度衡量：</p>
<p><span class="math display">\[D_{KL}(p&#39;_{data}||p_{model}) = E_{x\text{~}p&#39;_{data}}[logp&#39;_{data}(x)-logp_{model}(x)]\]</span></p>
<p>我们的目标是使上式最小化。减号左边是在训练集上的，是一个常数；我们只关心右边：</p>
<p><span class="math display">\[\theta_{KL}=argmin_{\theta} -E_{x\text{~}p&#39;_{data}}[logp_{model}(x)]\tag{公式2}\]</span></p>
<p>很明显我们可以看到，公式2与公式1其实是一样的。我们从这个角度证明了这种度量下的误差与极大似然是相同的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2017/10/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E8%AF%AF%E5%B7%AE%E5%87%BD%E6%95%B0%E6%8E%A2%E7%A9%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E8%AF%AF%E5%B7%AE%E5%87%BD%E6%95%B0%E6%8E%A2%E7%A9%B6/" class="post-title-link" itemprop="url">深度学习算法-误差函数探究</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-25 11:11:00" itemprop="dateCreated datePublished" datetime="2017-10-25T11:11:00+08:00">2017-10-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:42:03" itemprop="dateModified" datetime="2018-12-17T15:42:03+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">深度学习算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前我们在<a href="https://jiayi797.github.io/2017/09/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%80%E4%BB%8B/">神经网络简介</a>中曾经提到过误差函数。这一节我们总结一下误差函数。</p>
<p>误差函数一般有两种来源：</p>
<ol type="1">
<li>如果参数模型定义了一个分布<span class="math inline">\(p(y|x;\theta)\)</span>，我们采用最大似然原理得到代价函数：训练数据和模型预测间的交叉熵。这个在之后会详细解释。</li>
<li>如果不预测y的完整概率分布，仅仅预测在给定x条件下y的某种统计量，那就用某些专门的损失函数来计算。</li>
</ol>
<h1 id="方法1使用最大似然学习条件分布">方法1，使用最大似然学习条件分布</h1>
<p>可以在博客<a href="https://jiayi797.github.io/2017/10/26/%E6%95%B0%E5%AD%A6-%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/">最大似然估计</a>中看到，参数模型定义了一个分布<span class="math inline">\(p(y|x;\theta)\)</span>，为了求得参数，我们使用最大似然原理，得到最终的目标函数是最小化代价函数J——<strong>训练数据</strong>和<strong>模型预测</strong>间的<strong>交叉熵:</strong></p>
<p><span class="math display">\[J(\theta)=-E_{x,y\sim p&#39;_{data}}log p_{model}(y|x)\]</span></p>
<p>上式的意义是：在<span class="math inline">\(x,y\)</span>服从训练数据$ p'<em>{data}<span class="math inline">\(分布下，使得模型的\)</span>-Elog p</em>{model}(y|x)$最小。</p>
<p>用似然解决问题带来的好处：</p>
<ol type="1">
<li>当明确了一个模型<span class="math inline">\(p(y|x)\)</span>时，就自动地确定了代价函数<span class="math inline">\(logp(y|x)\)</span>。</li>
<li>对数函数能帮我们避免梯度过小（例如有的输出单元有一个指数函数，取对数后梯度就不那么小了）</li>
</ol>
<h1 id="方法2简单学习条件统计量">方法2，简单学习条件统计量</h1>
<p>我们用历史的数据，计算出特征x下y发生的概率：<span class="math inline">\(f(x)=p(y|x)\)</span>，将它作为x特征下y的预测。学习这个条件统计量的过程就是我们这节介绍的方法。</p>
<h2 id="均方误差">均方误差</h2>
<p>通过解优化问题：</p>
<p><span class="math display">\[f^*=arg min_f E_{x,y\sim p_{data}}||y-f(x)||^2 \tag{均方误差最小化时的f^{※}}\]</span></p>
<p>得到<span class="math inline">\(f^*\)</span>,我们用它来进行预测得到：</p>
<p><span class="math display">\[f^*(x)=E_{y\sim p_{data}(y|x)}[y]\tag{将所有服从p_{data}(y|x)的y的y均值作为x特征下y的预测}\]</span></p>
<p>可以看出，这样得到的函数是可以用来对每个x的值预测出y的<strong>均值</strong>。</p>
<h2 id="平均绝对误差">平均绝对误差</h2>
<p>还有另一种误差叫平均绝对误差，通过解优化问题：</p>
<p><span class="math display">\[f^*=arg min_f E_{x,y \sim p_{data}}||y-f(x)||_1\]</span></p>
<p>得到的函数，可以对每个x预测y取值的<strong>中位数</strong>。</p>
<h1 id="比较">比较</h1>
<p>一般，均方误差和平均绝对误差在梯度下降法表现不好，因为饱和的输出单元梯度非常小。所以一般来说交叉熵代价函数更受欢迎。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2017/09/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-L2R%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BA%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-L2R%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BA%86%E8%A7%A3/" class="post-title-link" itemprop="url">机器学习算法-L2R进一步了解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-25 15:30:16" itemprop="dateCreated datePublished" datetime="2017-09-25T15:30:16+08:00">2017-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:42:01" itemprop="dateModified" datetime="2018-12-17T15:42:01+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">机器学习算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前的博客中简单介绍了Learning to Rank的基本原理，也讲到了Learning to Rank的几类常用的方法：pointwise，pairwise，listwise。这篇博客就pairwise中的RankSVM、GBRank和LambdaRank做简要介绍。</p>
<p>RankSVM是2000年提出的；GBRank是2007年提出的；LambdaMART是2008年提出的。因此我们按照提出顺序来讲解这三种算法。</p>
<h1 id="引言">引言</h1>
<p>机器学习一般都是解决分类问题。而在Rank中我们遇到的是排序问题。那么如何将排序问题转化为分类问题成了当下的关键。</p>
<h2 id="如何将排序问题转化为分类问题">如何将排序问题转化为分类问题？</h2>
<p>对于一个query-doc pair（检索-文档结果对），我们可以将其用一个feature vector表示：x。而排序函数为f(x)，我们根据f(x)的大小来决定哪个doc排在前面，哪个doc排在后面。即如果f(xi) &gt; f(xj)，则xi应该排在xj的前面，反之亦然。可以用下面的公式表示：</p>
<p><img src="https://i.loli.net/2017/09/25/59c8b1ffea865.png" /></p>
<p>理论上，f(x)可以是任意函数，为了简单起见，我们假设其为线性函数： <img src="https://i.loli.net/2017/09/25/59c8b2152e915.png" /> 如果这个排序函数f(x)是一个线性函数，那么我们便可以将一个排序问题转化为一个二元分类问题。理由如下： 首先，对于任意两个feature vector xi和 xj，在f(x)是线性函数的前提下，下面的关系都是存在的： <img src="https://i.loli.net/2017/09/25/59c8b41b9bba0.png" /> 然后，便可以对xi和 xj的差值向量考虑二元分类问题。特别地，我们可以对其赋值一个label： <img src="https://i.loli.net/2017/09/25/59c8b4335d7e6.png" /></p>
<p>有一个很好的例子说明了如何将排序问题转化为分类问题，在L2R的笔记中已提到过，此处不再多加阐述。</p>
<p>将排序问题转化为分类问题之后, 我们就可以使用常用的机器学习方法解决该问题。</p>
<h1 id="ranksvm">RankSVM</h1>
<p>RankSVM的<strong>基本思想</strong>是，将排序问题转化为pairwise的分类问题，然后使用SVM分类模型进行学习并求解。Ranking SVM使用SVM来进行分类: <img src="https://i.loli.net/2017/09/25/59c8b8e74b0df.png" /></p>
<p>其中w为参数向量, x为文档的特征,y为文档对之间的相对相关性, ξ为松弛变量。</p>
<p>对这个公式，<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/23764120">知乎</a>上有一个很好的解释： 之前svm为实现软间隔最大化，约束条件里有<img src="https://i.loli.net/2017/09/25/59c8b458a2a54.png" /> 。而rank-svm是典型的pairwise方法，考虑两个有偏序关系的文档对，训练样本是xi<sup>(1)-xi</sup>(2)，所以要把约束条件改成<img src="https://i.loli.net/2017/09/25/59c8b472b130b.png" /> ，由于相减不再需要偏置b。而优化问题中的目标函数和其他约束项不变。</p>
<h2 id="使用clikthrough数据作为训练数据">使用Clikthrough数据作为训练数据</h2>
<p>T. Joachims提出了一种非常巧妙的方法, 来使用Clickthrough数据作为Ranking SVM的训练数据。</p>
<p>假设给定一个查询"Support Vector Machine", 搜索引擎的返回结果为 <img src="https://ooo.0o0.ooo/2017/09/25/59c8b9563cab6.png" /> 其中1, 3, 7三个结果被用户点击过, 其他的则没有。因为返回的结果本身是有序的, 用户更倾向于点击排在前面的结果, 所以用户的点击行为本身是有偏(Bias)的。为了从有偏的点击数据中获得文档的相关信息, 我们认为: 如果一个用户点击了a而没有点击b, 但是b在排序结果中的位置高于a, 则a&gt;b。 所以上面的用户点击行为意味着: 3&gt;2, 7&gt;2, 7&gt;4, 7&gt;5, 7&gt;6。</p>
<h2 id="ranking-svm的开源实现">Ranking SVM的开源实现</h2>
<p><a target="_blank" rel="noopener" href="http://www.cs.cornell.edu/people/tj/svm_light/svm_rank.html">Joachims的主页</a>上有Ranking SVM的开源实现。</p>
<p>数据的格式与LIBSVM的输入格式比较相似, 第一列代表文档的相关性, 值越大代表越相关, 第二列代表查询, 后面的代表特征: qid:1 1:1 2:1 3:0 4:0.2 5:0 # 1A qid:1 1:0 2:0 3:1 4:0.1 5:1 # 1B qid:1 1:0 2:1 3:0 4:0.4 5:0 # 1C qid:1 1:0 2:0 3:1 4:0.3 5:0 # 1D<br />
qid:2 1:0 2:0 3:1 4:0.2 5:0 # 2A<br />
qid:2 1:1 2:0 3:1 4:0.4 5:0 # 2B qid:2 1:0 2:0 3:1 4:0.1 5:0 # 2C qid:2 1:0 2:0 3:1 4:0.2 5:0 # 2D<br />
qid:3 1:0 2:0 3:1 4:0.1 5:1 # 3A qid:3 1:1 2:1 3:0 4:0.3 5:0 # 3B qid:3 1:1 2:0 3:0 4:0.4 5:1 # 3C qid:3 1:0 2:1 3:1 4:0.5 5:0 # 3D</p>
<h1 id="gbrank">GBRank</h1>
<p>参考文献<a target="_blank" rel="noopener" href="http://www.tuicool.com/articles/yAfiQ3r">GBRank:一种基于回归的学习排序算法</a> 对GBRank做出了较好的解释。原论文是[A Regression Framework for Learning Ranking Functions Using Relative Relevance Judgments]。下面对这个博客和论文进行摘录和整理。</p>
<h2 id="算法原理">算法原理</h2>
<p>一般来说在搜索引擎里面，相关性越高的越应该排在前面。现在 query-doc 的特征使用向量x或者y表示，假设现在有一个文档对&lt;xi,yi&gt;，当xi排在yi前面时，我们使用xi&gt;yi来表示。我们含顺序的 pair 对用如下集合表示(也就是真的xi真的排在yi前面): <img src="https://i.loli.net/2017/09/25/59c8b9d26d47d.png" /> 现假设学习的排序函数为h，我们希望当h(xi)&gt;h(yi)时，满足xi&gt;yi的数量越多越好。那么如何来评价这个h到底好不好呢，那么我们可以定义h的风险函数为: <img src="https://i.loli.net/2017/09/25/59c8ba28f012e.png" /> 对于这个风险函数，我们可以做如下解释。我们的目标是：对于集合S中的某个文档对&lt;xi,yi&gt;来说，h要符合我们之前的设定，也就是：</p>
<p>当h(xi)&gt;h(yi)时，h是正确的，不造成损失； 当h(xi)&lt;h(yi)时，h是不符合预期的，会造成损失，并且损失的大小成残差的平方级别；</p>
<p>将R(h)与每个 pair 对&lt;xi,yi&gt;的cost画成图可表示为： <img src="https://i.loli.net/2017/09/25/59c8ba5bd7a2e.png" /></p>
<p>上述风险函数直接优化比较困难，这里一个巧妙的解决方案：也就是首先固定h(xi)或者h(yi)当中其中的一个，然后再通过回归的方式来解决问题。 为了避免优化函数h是一个常量，我们对风险函数加入一个平滑项τ(0&lt;τ≤10)： <img src="https://i.loli.net/2017/09/25/59c8ba71a4abd.png" /> 其实加上了这个平滑项之后，一来可以防止h变为常数，二来还对损失函数给了更严格的条件：如果希望xi&gt;yi，就得有h(xi)&gt;h(yi)+τ，也就是更为严格了。</p>
<p>接下来我们用Functional Gradient Descent法来求解h.</p>
<p>参考文献<a target="_blank" rel="noopener" href="http://www.cnblogs.com/bentuwuying/p/6684585.html">Learning to Rank算法介绍：GBRank</a>对这个求解方法做了扼要的介绍：</p>
<p>在GBDT中，Functional Gradient Descent的使用为：将需要求解的F(x)表示成一个additive model，即将一个函数分解为若干个小函数的加和形式，而这每个小函数的产生过程是串行生成的，即每个小函数都是在拟合 loss function在已有的F(x)上的梯度方向（由于训练数据是有限个数的，所以F(x)是离散值的向量，而此梯度方向也表示成一个离散值的向量），然后将拟合的结果函数进一步更新到F(x)中，形成一个新的F(x)。</p>
<ol type="1">
<li>将h(xi)和h(xi)作为未知数。梯度下降使得R最小，来求得这些未知数。</li>
<li>对R计算h的负梯度： <img src="https://i.loli.net/2017/09/25/59c8baf10df1f.png" /></li>
<li>当pair对&lt;xi,yi&gt;符合条件时，上述梯度为0；反之，他们对应的梯度为： <img src="https://i.loli.net/2017/09/25/59c8bb529920a.png" /></li>
<li>接下来，还需要知道如何将梯度作用到h的更新上。通过设定xi的目标值为h(yi)+τ。yi的目标值为h(xi)−τ（这一步我的理解就是首先固定x/y中的某一个，然后去计算另一个）。因此在每轮迭代中，当h不满足&lt;xi,yi&gt;会产生一组数据：<img src="https://i.loli.net/2017/09/25/59c8bb6276a5c.png" /></li>
</ol>
<p>我们需要拟合本轮产生的所有负例。</p>
<p>下面形式化本算法： <img src="https://ooo.0o0.ooo/2017/09/25/59c8d9a57ef9f.png" /> 可以看到step3里面每轮都拟合误判的结果，在迭代中这个集合会越来越小。还有一种做法是将曾经误判的集合维持在训练集中，那么训练集就会始终增长。在这个步骤中使用GBDT模型进行回归预测，当然其他的回归方法也可以使用。</p>
<h1 id="lambdamart">LambdaMART</h1>
<p>在learn to rank的成长过程中，2000提出了SVMRank，2006年提出GBrank，2008年提出lambdaMART。看了几个比较大的框架，我发现现在市面上最常见的learn to rank算法就是LambdaMART了。接下来先介绍一下LambdaMART的原理，然后再介绍xgboost中是怎么写的LambdaMart。</p>
<h2 id="lambdamart的原理">LambdaMart的原理</h2>
<p>这一小节主要参考资料<a target="_blank" rel="noopener" href="https://liam0205.me/2016/07/10/a-not-so-simple-introduction-to-lambdamart/">LambdaMART 不太简短之介绍</a></p>
<p>Pointwise和Pairwise类型的LTR算法，将排序问题转化为回归、分类或者有序分类问题。Listwise 类型的 LTR 算法则另辟蹊径，将用户查询（Query）所得的结果作为整体，作为训练用的实例（Instance）。</p>
<p>LambdaMART 是一种 Listwise 类型的 LTR 算法，它基于 LambdaRank 算法和 MART(Multiple Additive Regression Tree)算法，<strong>将搜索引擎结果排序问题转化为回归决策树问题</strong>。MART实际就是梯度提升决策树（GBDT, Gradient Boosting Decision Tree）算法。GBDT 的核心思想是在不断的迭代中，新一轮迭代产生的回归决策树模型拟合损失函数的梯度，最终将所有的回归决策树叠加得到最终的模型。LambdaMART使用一个特殊的 Lambda 值来代替上述梯度，也就是将LambdaRank算法与MART算法加和起来。考虑到LambdaRank是基于RankNet算法的，所以在搞清楚LambdaMART算法之前，我们首先需要了解 MART、RankNet 和 LambdaRank 是怎么回事。</p>
<p>MART其实也是GBDT。此处对GBDT不再做过多的介绍。值得一提的是，MART并不对损失函数的形式做具体规定。实际上，损失函数几乎只需要满足可导这一条件就可以了。这一点非常重要，意味着我们可以把任何合理的可导函数安插在 MART 模型中。LambdaMART 就是用一个 λ 值代替了损失函数的梯度，将 λ和 MART 结合起来罢了。</p>
<h2 id="lambdamart是怎么来的">LambdaMART是怎么来的</h2>
<p>Lambda 的设计，最早是由 LambdaRank 从 RankNet 继承而来。因此，我们先要从 RankNet 讲起。 后记：其实这些文章都是到处整理得来，远不及直接看论文的好。如果有兴趣的话，可以读一读微软整理的这篇论文https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/MSR-TR-2010-82.pdf</p>
<p><strong>RankNet的创新</strong></p>
<p>Ranking常见的评价指标都无法求梯度，因此没法直接对评价指标做梯度下降。</p>
<p>RankNet 的创新之处在于，它将不适宜用梯度下降求解的Ranking问题，转化为对概率的交叉熵损失函数的优化问题，从而适用梯度下降方法。</p>
<p>RankNet的终极目标是得到一个带参的算分函数s = f(x;w)</p>
<p>参考文献机器学习---RankNet.md](https://github.com/MangoLiu/mangoliu.github.io/blob/master/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0---RankNet.md)给了一个非常好的例子：那么如何通过pair来训练，并最终作用到针对point的算分函数上，请看下面的简单例子。假设有以下同一个query下的4个文档，并且有3个特征维度，并对它们进行了人工打分，我们就利用它们来训练model。</p>
<pre><code>point       特征f1  特征f2  特征f3  label     
文档doc1      3       2        1      3(很好) 
文档doc2      1       2        1      2（好） 
文档doc3      1       1        2      1（一般） 
文档doc4      1       0        3      0（不好） </code></pre>
<p>于是，根据这个算分函数，我们可以根据特征来计算文档xi和xj的得分si和sj： Si = f(xi;w),sj = f(xj,w)</p>
<p>我们并不知道每个特征维度的具体权值w[i]。但我们感觉到要训练出这样的结果，就是使label得分比较高的样本得分尽量大，让label低的样本得分尽量小。 即本例中，我们应该让f(doc1)得分尽量大，f(doc4)得分尽量小。其实也就是f(doc1)-f(doc4)的结果尽量大，因为这个分差实际就包含了前者尽量大后者尽量小的含义。并且之前那个常量b通过作差后，不见了。 这样两两文档即可组成一个文档对，我们把前者好于后者的成为正向文档对；反之称之为负向文档对。正向对表示前者好于后者，负向对表示后者劣于前者。其实表述的是同样的意义。因此，我们只需要正向的对就好了。因为负向对不能再额外提供有意义的信息了。那么我们提取出上面的正向对：</p>
<pre><code>Pair  作差       特征f1 特征f2  特征f3
P12 (doc1-doc2)    2      0       0
P13 (doc1-doc3)    2      1      -1
P14 (doc1-doc4)    2      2      -2
P23 (doc2-doc3)    0      1      -1
P24 (doc2-doc4)    0      2      -2
P34 (doc3-doc4)    0      1      -1</code></pre>
<p>需要注意的是，这里的特征也进行了相减！</p>
<p>我们再引入一个文档对概率，表示文档i好于文档j的概率。我们将它称为两者的偏序概率：(这个东西我理解为是将偏序关系转化为概率的函数，类似于lr里面的sigmod函数) <img src="https://i.loli.net/2017/09/25/59c8db05e3ddb.png" /></p>
<p>那么，现在这个问题就转化成了使所有正向对的概率和最大。我们现在已经知道了目标函数，那么接下来就需要一个损失函数来将这个目标函数最优化。 再将以上的交叉熵定义为损失函数： <img src="https://i.loli.net/2017/09/25/59c8db19cd5b2.png" /> 然后对这个损失函数进行梯度下降： <img src="https://i.loli.net/2017/09/25/59c8db276ebc2.png" /> 在以上的方法中，我们将偏序关系转化为目标函数，然后再定义目标函数的损失函数，再通过梯度下降法求参数使得损失函数最小，得到目标函数。那么我们能不能直接定义梯度呢？</p>
<p><strong>LambdaRank</strong></p>
<p>参考文献<a target="_blank" rel="noopener" href="http://blog.csdn.net/huagong_adu/article/details/40710305">Learning To Rank之LambdaMART的前世今生</a>对下面这个图有非常详细的解释。此处对一些重点内容进行摘录。 <img src="https://ooo.0o0.ooo/2017/09/25/59c8db4cb37ec.png" /> 如图所示，每个线条表示文档，蓝色表示相关文档，灰色表示不相关文档。 RankNet以pairwise error的方式计算cost，左图的cost为13，右图通过把第一个相关文档下调3个位置，第二个文档上条5个位置，将cost降为11，但是像NDCG或者ERR等评价指标只关注top k个结果的排序，在优化过程中下调前面相关文档的位置不是我们想要得到的结果。图 1右图左边黑色的箭头表示RankNet下一轮的调序方向和强度，但我们真正需要的是右边红色箭头代表的方向和强度，即更关注靠前位置的相关文档的排序位置的提升。</p>
<p>LambdaRank正是基于这个思想演化而来，其中Lambda指的就是红色箭头，代表下一次迭代优化的方向和强度，也就是梯度。 受LambdaNet的启发，LambdaRank对RankNet的梯度做因式分解： <img src="https://i.loli.net/2017/09/25/59c8db76c9652.png" /> 注意有下面对称性 <img src="https://i.loli.net/2017/09/25/59c8db85eb3f3.png" /> <img src="https://i.loli.net/2017/09/25/59c8db9255992.png" /> 也就是说：<strong>每条文档移动的方向和趋势取决于其他所有与之 label 不同的文档</strong>。 现在回过头来看，看看我们做了些什么？ - 分析了梯度的物理意义； - 绕开损失函数，直接定义梯度。 当然，我们可以反推一下 LambdaRank 的损失函数： <img src="https://i.loli.net/2017/09/25/59c8dbaf0603f.png" /></p>
<p><strong>LambdaMART</strong> 现在的情况变成了这样： - MART 是一个框架，缺一个「梯度」； - LambdaRank 定义了一个「梯度」。 于是，就有了 LambdaMART： <img src="https://i.loli.net/2017/09/25/59c8dbc928934.png" /></p>
<h1 id="xgboost中的learning-to-rank">Xgboost中的Learning to rank</h1>
<p>为了后续方便后续小伙伴们的使用，我将官方文档<a target="_blank" rel="noopener" href="https://github.com/dmlc/xgboost/tree/master/demo/rank">xgboost的learning to rank文档</a>进行扼要的翻译，并在此贴出。 Xgboost的rank模型是基于lambdaRank的。 XGBoost支持以ranking为目标的学习。在ranking的情况下，数据集一般都需要被格式化为group input： 在ranking中，数据是根据不同的真实场景被分为groups的。例如，在学习web pages的rank场景下，rank page数据是根据不同的queries分到各groups的。</p>
<p><strong>数据形式</strong> <strong>基本数据形式train.txt</strong> Xgboost接受像libSVM格式数据，例如：</p>
<pre><code>1 101:1.2 102:0.03
0 1:2.1 10001:300 10002:400
0 0:1.3 1:0.3
1 0:0.01 1:0.3
0 0:0.2 1:0.3</code></pre>
<p>每行表示：</p>
<pre><code>label   特征1索引:值 特征2索引:值</code></pre>
<p><strong>groups索引文件train.txt.group</strong> 除了group input format,XGboost需要一个索引group信息的文件，索引文件train.txt.group格式如下：</p>
<pre><code>2
3</code></pre>
<p>这意味着，数据集包含5个实例，前两个是一个group，后三个是一个group。</p>
<p><strong>实例权重文件train.txt.weight</strong></p>
<p>XGboost还支持每个实例的权重调整，数据格式如下：</p>
<pre><code>1
0.5
0.5
1
0.5</code></pre>
<p><strong>初始margin文件train.txt.base_margin</strong></p>
<p>XGBoost还可以支持每个实例的初始化margin prediction.例如我们对train.txt可以有一个initial margin file:</p>
<pre><code>-0.4
1.0
3.4</code></pre>
<p>XGBoost will take these values as initial margin prediction and boost from that. An important note about base_margin is that it should be margin prediction before transformation, so if you are doing logistic loss, you will need to put in value before logistic transformation. If you are using XGBoost predictor, use pred_margin=1 to output margin values.</p>
<p><strong>使用Demo:</strong></p>
<p><a target="_blank" rel="noopener" href="https://github.com/stegben/kaggle_outbrain/blob/990f5e1cc18ff0f6156a56b9d919ac0d52222268/train_xgb.py">https://github.com/stegben/kaggle_outbrain/blob/990f5e1cc18ff0f6156a56b9d919ac0d52222268/train_xgb.py</a></p>
<p><strong>xgboost的pairwiseRank实现</strong></p>
<p>****如何构造pair对？<strong> xgboost/src/objective/rank_obj.cc,75行开始构造pair对。如上理论所说，每条文档移动的方向和趋势取决于其他所有与之 label 不同的文档。因此我们只需要构造不同label的“正向文档对”。其方法主要为:遍历所有的样本，从与本样本label不同的其他label桶中，任意取一个样本，构造成正样本； 如何定义梯度？</strong> xgboost/src/objective/rank_obj.cc中，写到了它是使用lambdaWeight. 然后将梯度和文档对输入GBDT训练即可。 ****输出是什么？** 根据labdaMart原理，输出是模型对每个文档的打分。</p>
<p>#　参考文献</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/kemaswill/p/3241963.html">Learning to Rank之Ranking SVM 简介</a> <a target="_blank" rel="noopener" href="http://www.tuicool.com/articles/yAfiQ3r">GBRank:一种基于回归的学习排序算法</a> <a target="_blank" rel="noopener" href="http://mlnote.com/2016/09/18/gbRank-logsitRank-from-up-to-bottom/">gbRank &amp; logsitcRank自顶向下</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2017/09/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">深度学习算法-神经网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-05 21:26:11" itemprop="dateCreated datePublished" datetime="2017-09-05T21:26:11+08:00">2017-09-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:42:03" itemprop="dateModified" datetime="2018-12-17T15:42:03+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">深度学习算法</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">神经网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文是吴恩达老师的课程总结。主要参考了<a target="_blank" rel="noopener" href="http://blog.csdn.net/koala_tree">大树先生</a>和<a target="_blank" rel="noopener" href="http://www.bijishequ.com/authorarticle.html?author=PilgrimHui#">PilgrimHui</a> 的笔记。如有不当之处，还请各位指出。</p>
<p>本课程附带编程作业。本文的编程作业有：</p>
<ol type="1">
<li><p>实现浅层神经网络 ：<a href="/2017/12/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-1-3-%E6%9E%84%E5%BB%BA%E6%B5%85%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" title="深度学习实践-1-3-构建浅层神经网络">深度学习实践-1-3-构建浅层神经网络</a></p></li>
<li><p>实现深层神经网络： <a href="/2017/12/10/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-1-4-1-%E6%9E%84%E5%BB%BA%E6%B7%B1%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" title="深度学习实践-1-4-1-构建深层神经网络">深度学习实践-1-4-1-构建深层神经网络</a></p></li>
<li><p>用神经网络做猫脸识别：<a href="/2017/12/10/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-1-4-2-%E7%94%A8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AF%86%E5%88%AB%E7%8C%AB/" title="深度学习实践-1-4-2-用神经网络识别猫">深度学习实践-1-4-2-用神经网络识别猫</a></p></li>
<li><p>待续</p></li>
</ol>
<h1 id="神经网络概念">神经网络概念</h1>
<p>所谓神经网络就是将许多个单一“神经元”联结在一起，这样，一个“神经元”的输出就可以是另一个“神经元”的输入。神经网络就是按照一定规则将多个神经元连接起来的网络。</p>
<p><img src="https://i.loli.net/2017/09/05/59aea656bf8da.png" /> 我们使用圆圈来表示神经网络的输入，标上“+1”的圆圈被称为<strong>偏置节点</strong>，也就是截距项。神经网络最左边的一层叫做<strong>输入层</strong>，最右的一层叫做<strong>输出层</strong>（本例中，输出层只有一个节点）。中间所有节点组成的一层叫做<strong>隐藏层</strong>，因为我们不能在训练样本集中观测到它们的值。同时可以看到，以上神经网络的例子中有3个<strong>输入单元</strong>（偏置单元不计在内），3个<strong>隐藏单元</strong>及一个<strong>输出单元</strong>。</p>
<p>记： <span class="math inline">\(a^{[0]} = X\)</span>，表示输入特征，也表示“acitive value” <span class="math inline">\(a^{[1]}\)</span>，表示隐藏层的“active value” <span class="math inline">\(a^{[2]} = y^{\text{~}}\)</span>，表示输出层</p>
<p>刚才提到的是一种最简单的神经网络，叫<strong>深度前馈(feedforword)网络</strong>，又称前馈神经网络、多层感知机，是典型的深度学习模型。</p>
<p>前馈网络的目标是近似某个函数<span class="math inline">\(f^*(x)\)</span>,将输入<span class="math inline">\(x\)</span>映射到输出<span class="math inline">\(y\)</span>。</p>
<p>而映射$ f(x;)<span class="math inline">\(，并且学习参数\)</span><span class="math inline">\(的值，使它能够得到最佳函数\)</span>f^*(x) $的近似。</p>
<p>前馈是因为没有反馈连接。如果有反馈的话，叫循环(recurrent)神经网络。</p>
<p>全连接：第N层的每个神经单元和第N-1层的所有神经元相连。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2017/09/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2017/09/04/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04-%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84%E5%88%97%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/04/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04-%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84%E5%88%97%E8%A1%A8/" class="post-title-link" itemprop="url">Java学习笔记4-泛型数组列表(ArrayList)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-04 20:19:00" itemprop="dateCreated datePublished" datetime="2017-09-04T20:19:00+08:00">2017-09-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:41:59" itemprop="dateModified" datetime="2018-12-17T15:41:59+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>ArrayList : 是一个采用类型参数(type parameter)的泛型类(generic class)（泛型类指数组内的元素可以是任意类型）。</p>
<p>新建：</p>
<pre><code>ArrayList&lt;Employee&gt; staff = new ArrayList&lt;Employee&gt;();</code></pre>
<p>增：</p>
<pre><code>add();</code></pre>
<p>若调用add且内部数组已经满了，数组列表就自动地创建一个更大的数组，并将所有的对象从较小的数组中拷贝到较大的数组中。</p>
<p>指定数组大小：</p>
<pre><code>test.ensureCapacity(100);</code></pre>
<p>或</p>
<pre><code>ArrayList&lt;Employee&gt; staff = new ArrayList&lt;&gt;(100);</code></pre>
<p>一旦确定数组大小不再发生变化，即可调用<code>trimeToSize</code>方法，使得存储区域的大小调整为当前元素数量所需的存储空间数目。垃圾回收器将回收多余的存储空间。</p>
<p>其它操作：</p>
<pre><code>get(index);
set(index,element);
add(index,element);
remove(index);</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2017/09/04/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E5%BC%95%E8%A8%80-LR%E7%9A%84%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/04/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E5%BC%95%E8%A8%80-LR%E7%9A%84%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95/" class="post-title-link" itemprop="url">深度学习算法-引言-LR的梯度下降法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-04 12:13:01" itemprop="dateCreated datePublished" datetime="2017-09-04T12:13:01+08:00">2017-09-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:42:03" itemprop="dateModified" datetime="2018-12-17T15:42:03+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">深度学习算法</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">神经网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本节是吴恩达老师在deepLearning.ai第二周课程的笔记。</p>
<p>本节以逻辑回归的梯度下降法为例，讲了我们究竟如何使用梯度下降法。</p>
<h1 id="lr的梯度下降">LR的梯度下降</h1>
<p>在LR中，我们想要得到z=wx+b，并且这个z在样本上，损失函数L(a,y)最小。那么，我们可以不断地改变w和b，找到一个合适的w和b，达到我们上述的目的。</p>
<p><img src="https://i.loli.net/2017/09/04/59acd4eac78da.png" /></p>
<p>如何改变w和b，能更快地得到最优的w和b呢？那么我们就要使用梯度下降法。 <img src="https://i.loli.net/2017/09/04/59acd39e1a9ea.png" /></p>
<p>上图中，从左到右的计算过程就是前向传播法。</p>
<p>一般来说，我们都用后向传播法来计算这个过程：</p>
<p>在单个样本中， 想要计算<span class="math inline">\(L(a,y)\)</span>的导数: 1. 先向前一步，计算损失函数<span class="math inline">\(L(a,y)\)</span>关于<span class="math inline">\(a\)</span>的导数<span class="math inline">\(da = \frac{dL(a,y)}{da} = -\frac{y}{a} + \frac{1-y}{1-a}\)</span>。 2. 再向前一步，计算<span class="math inline">\(dz = \frac{dL}{dz} = a - y\)</span> 3. 再向前一步，计算<span class="math inline">\(dw = \frac{dL}{dw} = ...=x(a-y), db = ...=a-y\)</span> 4. 用 $ w = w - dw,b = b - db$</p>
<p>在m个训练集中， <span class="math inline">\(J(w,b) = \frac{1}{m} \sum{_i^m L(a^{(i)},y^{(i)})}\)</span> 那么： <span class="math inline">\(\frac{d(J(w,b))}{w1} = \frac{1}{m}\sum_i^m\frac{d(L(w^{(i)},y^{(i)}))}{w_i}\)</span></p>
<p>也就是说，m个训练样本的损失函数的导数 = 每个训练样本损失函数导数的均值</p>
<p>伪代码：</p>
<pre><code>J = 0; dw1 = 0; dw2 = 0 ; db = 0;
for i = 1 to m :
    z = w1x1[i] + w2x2[i] + b ;
    y = sigmod(z) ;
    a = get(i) ;
    J += ylog(a) + (1-y)log(1-a);
    dz = a - y; # 先算dz
    dw1+= x1dz; # 后算dw,db
    dw2 += x2dz;
    db+= dz;
J/= m;
dw1 /= m;
dw2 /= m;
db /= m; </code></pre>
<p>此时就已经得到了全部样本的dw1,dw2,db,J</p>
<p>然后应用梯度下降：</p>
<pre><code>w1 = w1 - sdw1
w2 = w2 - sdw2
b = b - sb</code></pre>
<p>其中，s是步长。</p>
<h1 id="向量化">向量化</h1>
<p>一般来说，for循环是很不好的。可以使用向量化来摆脱for循环，加速运算。接下来我们来讲一讲向量化。</p>
<p>一般来说，如果我们想计算<span class="math inline">\(z = w^T x + b\)</span>,其中，w和x都是一个n维的列向量。在非向量化实现中，我们会用：</p>
<pre><code>z = 0;
for i in range(n):
    z += w[i]*x[i];
z += b ;</code></pre>
<p>在向量化（例如numpy中），我们用：</p>
<pre><code>z = np.dot(w,x) + b</code></pre>
<p>向量运算非常快（主要原因是并行运算）。因此我们尽量将loop运算转换为向量运算。</p>
<h1 id="向量化的lr">向量化的LR</h1>
<p>x是m维向量</p>
<pre><code>import numpy as np
J = 0; dw1 = 0; dw2 = 0 ; db = 0;
z = np.dot(w.T,x) + b; # m维列向量
y = sigmod(z) ;# m维列向量
a = label;# m维列向量
J = np.dot(y.T,log(a)) + np.dot((1-y).T,log(1-a));
J/= m;
dz = a - y; # 先算dz
dw1 = np.dot(x1.T,dz) /m ; # 后算dw,db
dw2 = np.dot(x2.T,dz) /m ;
db= np.sum(dz) /m ;</code></pre>
<p>然后应用梯度下降：</p>
<pre><code>w1 = w1 - sdw1
w2 = w2 - sdw2
b = b - sb</code></pre>
<h1 id="总结">总结</h1>
<p>这一节主要讲了我们如何将梯度下降法应用到LR中，以及强调了Nuppy。应该只是为了后续的学习做一些准备。</p>
<p>一定一定要看这个作业<a target="_blank" rel="noopener" href="http://kakack.github.io/2017/09/Logistic-Regression-with-a-Neural-Network-mindset/">通过神经网络mindset实现简单的Logistic Regression</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">jiayi797</p>
  <div class="site-description" itemprop="description">.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">150</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jiayi797</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
    <span class="post-count">| 博客共334.5k字</span>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
