<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
<!-- Referrer Policy调整致不蒜子单页面统计出错:https://senorui.top/posts/c33f.html -->
<meta name="referrer" content="no-referrer-when-downgrade">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jiayi797.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content=".">
<meta property="og:type" content="website">
<meta property="og:title" content="甲乙小朋友的房子">
<meta property="og:url" content="http://jiayi797.github.io/about/page/4/index.html">
<meta property="og:site_name" content="甲乙小朋友的房子">
<meta property="og:description" content=".">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="jiayi797">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://jiayi797.github.io/about/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>甲乙小朋友的房子</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">甲乙小朋友的房子</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">甲乙小朋友很笨，但甲乙小朋友不会放弃</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2018/03/04/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/04/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">面试总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-04 16:39:49" itemprop="dateCreated datePublished" datetime="2018-03-04T16:39:49+08:00">2018-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:42:02" itemprop="dateModified" datetime="2018-12-17T15:42:02+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="算法题">算法题</h1>
<ol type="1">
<li>大数取TOPK问题 堆：O(nlogk) 快速选择第K大的数，复杂度是O(N)。然后将比它小的全部拿出来，复杂度是O(N)。因此总复杂度是O(2N) = O(N)</li>
<li>大数排序问题 分治+K路归并（K路归并可以用堆优化）</li>
</ol>
<h1 id="机器学习">机器学习</h1>
<h2 id="相关资料">相关资料</h2>
<ol type="1">
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/shenxiaoming77/article/details/53894973">agging与boosting两种集成模型的偏差和方差的理解</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3b512ca9035b">模型任何之——Bagging和Boostting的区别</a></li>
<li><a target="_blank" rel="noopener" href="http://www.csuldw.com/2016/02/26/2016-02-26-choosing-a-machine-learning-classifier/">机器学习算法比较</a></li>
</ol>
<h2 id="相关题">相关题</h2>
<ol type="1">
<li>监督学习与无监督学习的区别</li>
<li>Xgboost与LightGBM</li>
<li>判别式模型与生成模型</li>
</ol>
<h1 id="其它">其它</h1>
<h2 id="数学相关">数学相关</h2>
<ul>
<li>中心极限定理：在适当的条件下，大量相互独立随机变量的均值经适当标准化后依分布收敛于正态分布</li>
<li>大数定理：在试验不变的条件下，重复试验多次，随机事件的频率近似于它的概率</li>
<li>大数定律成立条件较宽松。</li>
</ul>
<h2 id="osi七层模型">OSI七层模型</h2>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2018-03-10-17-14-00.png" /></p>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2018-03-10-17-14-26.png" /></p>
<h2 id="tcp">TCP</h2>
<p>TCP是TCP/IP体系中一个非常复杂的协议。</p>
<ol type="1">
<li>TCP是面向连接的<strong>运输层</strong> 协议。面向连接的意思是：用之前，必须先建立TCP连接；用完后，必须释放连接。</li>
<li>TCP连接只能是点对点的。</li>
<li>TCP提供全双工通信，即允许通信双方在任何时候都能发送数据。（通过发送缓存和接受缓存来实现）</li>
<li>TCP连接的端点叫：套接字(socket) = (ip地址：端口号)</li>
<li>滑动窗口是TCP的精髓：发送方每收到一个确认，就把发送窗口前滑一。</li>
<li>TCP首部20字节，后面4n字节是内容。</li>
</ol>
<p><strong>TCP三次握手：</strong></p>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2018-03-10-17-11-22.png" /></p>
<ul>
<li>第二次对话保证：乙能听懂甲</li>
<li>第三次对话保证：甲能听懂乙</li>
</ul>
<p><strong>TCP四次挥手</strong></p>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2018-03-10-17-15-33.png" /></p>
<ul>
<li>第一对FIN和ACK保证了乙知道了要关机；第二对FIN和ACK保证了乙已经关机；</li>
</ul>
<h2 id="java内存泄漏">Java内存泄漏</h2>
<p>但是在Java中，我们不用（也没办法）自己释放内存，无用的对象由GC自动清理，这也极大的简化了我们的编程工作。但，实际有时候一些不再会被使用的对象，在GC看来不能被释放，就会造成内存泄露。</p>
<p>简单例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line">    Object object;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        object = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="comment">//...其他代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 这里的object实例，其实我们期望它只作用于method1()方法中，且其他地方不会再用到它，但是，当method1()方法执行完成后，object对象所分配的内存不会马上被认为是可以被释放的对象，只有在Simple类创建的对象被释放后才会被释放，严格的说，这就是一种内存泄露。解决方法就是将object作为method1()方法中的局部变量。当然，如果一定要这么写，可以改为这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line">    Object object;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        object = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="comment">//...其他代码</span></span><br><span class="line">        object = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决的原则就是尽量减小对象的作用域（比如android studio中，上面的代码就会发出警告，并给出的建议是将类的成员变量改写为方法内的局部变量）以及手动设置null值。</p>
<h1 id="参考文献">参考文献</h1>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://github.com/jawil/blog/issues/14">通俗大白话来理解TCP协议的三次握手和四次分手</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/whuslei/article/details/6667471">TCP协议中的三次握手和四次挥手(图解)</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2018/03/03/%E7%AE%97%E6%B3%95-B%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/03/%E7%AE%97%E6%B3%95-B%E6%A0%91/" class="post-title-link" itemprop="url">算法-B树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-03 14:35:53" itemprop="dateCreated datePublished" datetime="2018-03-03T14:35:53+08:00">2018-03-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:42:03" itemprop="dateModified" datetime="2018-12-17T15:42:03+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>B树是为实现高效的磁盘存取而设计的多叉平衡搜索树。这个概念在文件系统，数据库系统中非常重要。</p>
<p>B树是一种查找树，我们知道，这一类树（比如二叉查找树，红黑树等等）最初生成的目的都是为了解决某种系统中，查找效率低的问题。B树也是如此，它最初启发于二叉查找树，二叉查找树的特点是每个非叶节点都只有两个孩子节点。然而这种做法会导致当数据量非常大时，二叉查找树的深度过深，搜索算法自根节点向下搜索时，需要访问的节点也就变的相当多。如果这些节点存储在外存储器中，每访问一个节点，相当于就是进行了一次I/O操作，随着树高度的增加，频繁的I/O操作一定会降低查询的效率。</p>
<p>这里有一个基本的概念，就是说我们从外存储器中读取信息的步骤，简单来分，大致有两步：</p>
<ol type="1">
<li>找到存储这个数据所对应的磁盘页面，这个过程是机械化的过程，需要依靠磁臂的转动，找到对应磁道，所以耗时长。</li>
<li>读取数据进内存，并实施运算，这是电子化的过程，相当快。</li>
</ol>
<p>综上，对于外存储器的信息读取最大的时间消耗在于寻找磁盘页面。那么一个基本的想法就是能不能减少这种读取的次数，在一个磁盘页面上，多存储一些索引信息。B树的基本逻辑就是这个思路，它要改二叉为多叉，每个节点存储更多的指针信息，以降低I/O操作数。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2018/03/03/%E7%AE%97%E6%B3%95-B%E6%A0%91/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2018/03/02/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E-%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%9B%9E%E9%A1%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/02/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E-%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%9B%9E%E9%A1%BE/" class="post-title-link" itemprop="url">搜索引擎-编程之美搜索引擎回顾</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-02 17:01:30" itemprop="dateCreated datePublished" datetime="2018-03-02T17:01:30+08:00">2018-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:42:03" itemprop="dateModified" datetime="2018-12-17T15:42:03+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/" itemprop="url" rel="index"><span itemprop="name">搜索引擎</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文回顾并总结了编程之美搜索引擎端的相关原理</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2018/03/02/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E-%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%9B%9E%E9%A1%BE/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2018/02/08/%E7%AE%97%E6%B3%95-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E3%80%81%E6%A1%B6%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/02/08/%E7%AE%97%E6%B3%95-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E3%80%81%E6%A1%B6%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">计数排序、基数排序、桶排序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-02-08 15:03:21" itemprop="dateCreated datePublished" datetime="2018-02-08T15:03:21+08:00">2018-02-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:42:05" itemprop="dateModified" datetime="2018-12-17T15:42:05+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">排序算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="非比较排序">非比较排序</h1>
<p>插入排序、归并排序、堆排序、快速排序这四种排序算法，他们的运行时间上界不会超过O(nlgn)。这些算法都有一个有趣的性质：在排序的最终结果中，各元素的次序依赖于它们之间的比较。我们把这类排序算法称为比较排序。</p>
<p>可以证明，基于比较的排序算法在最坏情况下的时间下界是Ω(nlgn)。堆排序和归并排序的运行时间上界为O(nlgn)，因此这两种排序算法都是渐进最优的比较排序算法。</p>
<p>而<strong>非基于比较的排序</strong>，如计数排序，桶排序，和在此基础上的基数排序，则可以突破O(NlogN)时间下限，达到线性时间复杂度<span class="math display">\[O(n)\]</span>。但要注意的是，非基于比较的排序算法的使用都是有条件限制的，例如元素的大小限制，相反，基于比较的排序则没有这种限制(在一定范围内)。但并非因为有条件限制就会使非基于比较的排序算法变得无用，对于特定场合有着特殊的性质数据，非基于比较的排序算法则能够非常巧妙地解决。</p>
<p>基数排序：O(dn) (d次调用桶排序)，空间复杂度 O(k)</p>
<p>桶排序：O(n)时间复杂度，O(n)空间复杂度</p>
<p>计数排序：O(n)时间复杂度，O(k)空间复杂度，每一个元素都是整数，并且位于0到k - 1之间</p>
<h1 id="计数排序">计数排序</h1>
<p>计数排序假设n个输入元素中的每一个都是在<strong>0到k区间内的一个整数</strong>，其中k为某个整数。当k=O(n)时，排序的运行时间为Θ(n)。</p>
<p>计数排序的思想是，对每一个输入元素，计算小于它的元素个数，如果有10个元素小于它，那么它就应该放在11的位置上，如果有17个元素小于它，它就应该放在18的位置上。当有几个元素相同时，这一方案要略做修改，因为不能把它们放在同一个输出位置上。下图展示了实际的运行过程。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/1186132-945c959a74a71c1c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/597" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>计数排序</p>
<p>构造辅助数组C，C的长度为k。第一次遍历A后，得到[0,k)区间上每个数出现的次数，将这些次数写入C，得到图(a)的结果。然后把C中每个元素变成前面所有元素的累加和，得到图(b)的结果。接下来，再次从后向前遍历数组A，根据取出的元素查找C中对应下标的值，再把这个值作为下标找到B中的位置，即是该元素排序后的位置。例如，图中A的最后一个元素是3，找到C[3]是7，再令B[7]=3即可，然后顺便把C[3]减一，这是防止相同的数被放到同一个位置。</p>
<p>计数排序的时间代价可以这样计算，第一次遍历A并计算C所花时间是Θ(n)，C累加所花时间是Θ(k)，再次遍历A并给B赋值所花时间是Θ(n)，因此，总时间为Θ(k + n)。在实际中，当k=O(n)时，我们一般会采用计数排序，这时的运行时间为Θ(n)。</p>
<h1 id="基数排序">基数排序</h1>
<p>对于一组数据，我们可以按照每一位对它们进行排序。比如，考虑下面一组十进制数 329 457 839 355</p>
<p>先按最后一位从小到大排序，得到 35<strong>5</strong> 45<strong>7</strong> 32<strong>9</strong> 83<strong>9</strong></p>
<p>再按中间一位从小到大排序，得到 3<strong>2</strong>9 8<strong>3</strong>9 3<strong>5</strong>5 4<strong>5</strong>7</p>
<p>最后按第一位从小到大排序，得到 <strong>3</strong>29 <strong>3</strong>55 <strong>4</strong>57 <strong>8</strong>39</p>
<p>其中，对任何一位的排序算法必须是稳定的，即相同数字不能改变它们的前后顺序。</p>
<p>基数排序算法的运行时间很容易计算，对于n个k进制d位数，假如每一位的排序使用计数排序算法，则该位排序用时为Θ(n + k)，总共d位数，总排序用时就是Θ(d(n + k))。当d为常数且k=O(n)时，总排序时间为Θ(n)。</p>
<h1 id="桶排序">桶排序</h1>
<p>桶排序假设输入是由一个随机过程产生，该过程将元素均匀、独立地分布在[0,1)区间上。</p>
<p>我们将[0,1)区间划分为n个相同大小的子区间，称为桶。然后将输入数据分别放到各个桶中。如果数据分布得很均匀，每个桶中的数据就不会太多，都会维持在常数量级。我们先对每个桶中的元素排序，然后把所有桶中的元素顺序列出来即可。下图为n=10的一个案例。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/1186132-1ea2b9a00e9dbeb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/675" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>桶排序.png</p>
<p>创建一个长度也为10的数组，将A中的元素按照大小找到B中合适的位置，插入链表。之后，分别对B中每个链表中的元素执行插入排序。最后将B中的所有元素依次取出即可。</p>
<p>现在分析桶排序的时间代价。将A中元素放入B用时Θ(n)，B中每个链表执行插入排序的用时，可以证明是O(2 - 1/n)，于是总用时就是Θ(n) + n * O(2 - 1/n) = Θ(n)。具体证明过程比较难理解，这里我想给出一个容易理解的解释，虽然不一定对，但还是可以帮助理解为什么总用时是Θ(n)。n个数放入n个桶，平均下来每个桶只有一个数，在实际中，可能有的多有的少，但都不会差得太离谱。因此我们可以认为每个桶中只有常数个数，那么对常数个数执行插入排序所用的时间当然也就是O(1)了。于是n个桶总用时就是O(n)，加上前面的Θ(n)，桶排序总用时就是Θ(n)了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2018/02/08/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/02/08/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E6%B3%95/" class="post-title-link" itemprop="url">算法-贪心法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-02-08 14:50:54" itemprop="dateCreated datePublished" datetime="2018-02-08T14:50:54+08:00">2018-02-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:42:06" itemprop="dateModified" datetime="2018-12-17T15:42:06+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%B4%AA%E5%BF%83%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">贪心法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="leetcode题">Leetcode题</h1>
<h2 id="jump-game-ii">Jump Game II</h2>
<p>给一个数组[2,3,1,1,4]，每个元素代表当前可以跳跃的步数。求问最少跳多少次可以从idx = 0跳到idx = n - 1</p>
<p>dp超时，只能用贪心</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> endGlobal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (endGlobal &lt; nums.length - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; ++i)&#123;</span><br><span class="line">            endGlobal = Math.max(endGlobal, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        start = end;</span><br><span class="line">        end = endGlobal;</span><br><span class="line">        ++step;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="remove-k-digits">Remove K Digits</h2>
<p>给一个str代表一个数字。给一个k。求删掉k个字符后，能够变成的最小数字。</p>
<p><strong>方法一，dp(超时)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">String[][] memo;</span><br><span class="line">String num;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">helper</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(idx == -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(memo[idx][k] != <span class="keyword">null</span>) <span class="keyword">return</span> memo[idx][k];</span><br><span class="line">    String min = num;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = idx; i + <span class="number">1</span> &gt;= k; --i)&#123;</span><br><span class="line">        String temp = helper(i - <span class="number">1</span>, k - <span class="number">1</span>) + num.substring(i + <span class="number">1</span>, idx + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(temp.compareTo(min) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            min = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    memo[idx][k] = min;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">removeKdigits</span><span class="params">(String num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.num = num;</span><br><span class="line">    <span class="keyword">this</span>.n = num.length();</span><br><span class="line">    memo = <span class="keyword">new</span> String[n][k+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        memo[i][<span class="number">0</span>] = num.substring(<span class="number">0</span>, i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; k)memo[i][i+<span class="number">1</span>] = <span class="string">&quot;&quot;</span>; <span class="comment">// k == i+1时，必须把前k个全部删掉才可以</span></span><br><span class="line">    &#125;</span><br><span class="line">    String result = helper(n - <span class="number">1</span>, k);</span><br><span class="line">    <span class="keyword">if</span>(result.length() == <span class="number">0</span>) result = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="comment">// 去掉前导零</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; result.length() - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(result.charAt(i) == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.substring(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法二，贪心</strong></p>
<p>假设数字<code>abcdef</code> ，从左到右看。如果<code>c &gt; a</code> ，那么明显删掉c比删掉a合适。</p>
<p>那么就要存下来之前遇到的最大值，然后如果之前的比较大，就把之前的删掉。如果当前大，就把当前删掉。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">removeKdigits</span><span class="params">(String num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> num;</span><br><span class="line">        <span class="keyword">char</span>[] stack = <span class="keyword">new</span> <span class="keyword">char</span>[num.length()];</span><br><span class="line">        Arrays.fill(stack, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">int</span> stackTail = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> digit = num.length() - k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length(); ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(k &gt; <span class="number">0</span> &amp;&amp; stackTail &gt;= <span class="number">0</span> &amp;&amp;num.charAt(i) &lt; stack[stackTail]) &#123;</span><br><span class="line">                --k; <span class="comment">// 如果遇到之前那个值大于后面的值，那就把它删掉</span></span><br><span class="line">                --stackTail;</span><br><span class="line">            &#125;</span><br><span class="line">            stack[++stackTail] = num.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 去掉前导0</span></span><br><span class="line">        <span class="keyword">int</span> stackHead = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (stackHead &lt; digit &amp;&amp; stack[stackHead] == <span class="string">&#x27;0&#x27;</span>) ++stackHead;</span><br><span class="line">        <span class="keyword">if</span>(stackHead == digit) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">new</span> String(stack, stackHead, digit - stackHead);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2018/02/03/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1%E7%9F%AD%E7%BD%91%E5%9D%80%E7%B3%BB%E7%BB%9FTiny-URL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/02/03/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1%E7%9F%AD%E7%BD%91%E5%9D%80%E7%B3%BB%E7%BB%9FTiny-URL/" class="post-title-link" itemprop="url">系统设计-设计短网址系统Tiny-URL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-02-03 22:29:21" itemprop="dateCreated datePublished" datetime="2018-02-03T22:29:21+08:00">2018-02-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:42:07" itemprop="dateModified" datetime="2018-12-17T15:42:07+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>例如goo.gl</p>
<h1 id="系统设计常见误区">系统设计常见误区</h1>
<p><strong>以下几个是误区</strong></p>
<ul>
<li>系统一定巨大无比 —— ×</li>
<li>必须用NoSQL —— ×</li>
<li>必须是分布式 —— ×</li>
</ul>
<p>不可以扔关键词，必须一步步分析。</p>
<p><strong>4S分析法</strong></p>
<ol type="1">
<li>提问：分析功能/需求/QPS/存储容量——Scenario</li>
<li>画图：根据分析结果设计“可行解”—— Service+Storage</li>
<li>进化：研究可能遇到的问题，优化系统 —— Scale</li>
</ol>
<h1 id="分析需求">分析需求</h1>
<p><strong>需求有两个：</strong></p>
<ul>
<li>根据长URL生成短URL <img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2018-02-03-22-35-36.png" /></li>
<li>根据短URL还原长URL <img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2018-02-03-22-36-01.png" /></li>
</ul>
<p><strong>QPS?</strong></p>
<p>假设这个是用来给微博做短网址的跳转。那么QPS能有多少？</p>
<ol type="1">
<li>询问微博日活用户 —— 约100M</li>
<li>推算产生一条Tiny URL的QPS
<ul>
<li>假设每个用户平均每天发0.1条微博，</li>
<li>平均写QPS = 100M * 0.1 / 86400 ~ 100</li>
<li>峰值QPS = 100 * 2 = 200</li>
</ul></li>
<li>推算点击一条Tiny URL的QPS
<ul>
<li>假设每个用户平均点1个Tiny URL</li>
<li>平均读QPS = 100M * 1 / 86400 ~ 1k</li>
<li>峰值QPS = 2k</li>
</ul></li>
<li>推算每天产生的新的 URL 所占存储
<ul>
<li>100M * 0.1 ~ 10M 条</li>
<li>每一条 URL 长度平均 100 算，一共1G</li>
<li>1T 的硬盘可以用 3 年</li>
</ul></li>
</ol>
<p>前3点：2k QPS ，一台SSD支持的MySQL完全可以搞定！</p>
<h1 id="服务逻辑块聚类与接口设计">服务——逻辑块聚类与接口设计</h1>
<p>TinyUrl只有一个UrlService</p>
<ul>
<li>本身就是一个小Application</li>
<li>无需关心其他的</li>
</ul>
<p>函数设计</p>
<ul>
<li><code>UrlService.encode(long_url)</code></li>
<li><code>UrlService.decode(short_url)</code></li>
</ul>
<p>访问端口设计</p>
<ul>
<li><code>GET /&lt;short_url&gt;</code>
<ul>
<li><code>return a Http redirect response</code></li>
</ul></li>
<li><code>POST /data/shorten/</code>
<ul>
<li><code>Data = &#123;url: http://xxxx &#125;</code></li>
<li><code>Return short url</code></li>
</ul></li>
</ul>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2018-02-03-22-49-19.png" /></p>
<h1 id="数据存取">数据存取</h1>
<p>两个步骤：</p>
<ul>
<li>选择存储结构</li>
<li>细化数据表</li>
</ul>
<h2 id="选择存储结构">选择存储结构</h2>
<p><strong>SQL vs NoSQL</strong></p>
<ul>
<li>是否需要支持 Transaction（事务）？
<ul>
<li>NoSQL不支持Transaction</li>
<li>是否需要丰富的 SQL Query？</li>
</ul></li>
<li>NoSQL的SQL Query不是太丰富
<ul>
<li>也有一些NoSQL的数据库提供简单的SQL Query支持</li>
</ul></li>
<li>是否想偷懒？
<ul>
<li>大多数 Web Framework 与 SQL 数据库兼容得很好</li>
<li>用SQL比用NoSQL少写很多代码</li>
</ul></li>
<li>是否需要Sequential ID？
<ul>
<li>SQL 为你提供了 auto-increment 的 Sequential ID。也就是1,2,3,4,5 …</li>
<li>NoSQL的ID并不是 Sequential 的</li>
</ul></li>
<li>对QPS的要求有多高？
<ul>
<li>NoSQL 的性能更高</li>
</ul></li>
<li>对Scalability的要求有多高？
<ul>
<li>SQL 需要码农自己写代码来 Scale</li>
<li>还记得Db那节课中怎么做 Sharding，Replica 的么？</li>
</ul></li>
<li>NoSQL 这些都帮你做了</li>
</ul>
<p><strong>选择</strong></p>
<ul>
<li>是否需要支持 Transaction？——不需要。NoSQL +1</li>
<li>是否需要丰富的 SQL Query？——不需要。NoSQL +1</li>
<li>是否想偷懒？——Tiny URL 需要写的代码并不复杂。NoSQL+1</li>
<li>对QPS的要求有多高？—— 经计算，2k QPS并不高，而且2k读可以用Cache，写很少。SQL +1</li>
<li>对Scalability的要求有多高？—— 存储和QPS要求都不高，单机都可以搞定。SQL+1</li>
<li>是否需要Sequential ID？—— 取决于你的算法是什么 : 如何将Long URL 转化为 Short URL</li>
</ul>
<h2 id="如何将long-url-转化为-short-url">如何将Long URL 转化为 Short URL</h2>
<p><strong>算法1 使用哈希函数 Hash Function（不可行） </strong></p>
<p>比如取 Long Url 的 MD5 的最后 6 位——这个方法肯定是有问题的 • 优点：快 • 缺点：难以设计一个没有冲突的哈希算法</p>
<p><strong>算法2：随机生成 + 数据库去重</strong></p>
<p>随机一个 6 位的 ShortURL，如果没有被用过，就绑定到该 LongURL • 伪代码如下： <img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2018-02-03-23-00-12.png" /> • 优点：实现简单 • 缺点：生成短网址的长度随着短网址越来越多变得越来越慢 • 可行性：其实能凑合用。在生活中有很多随机编码的，例如机票码、酒店码，是不可重复的，就是用这种方法弄的。</p>
<p><strong>算法3：进制转换 Base62</strong></p>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2018-02-10-20-55-32.png" /></p>
<ul>
<li>Base62
<ul>
<li>将6位的short url看成一个62进制的数（0-9,a-z,A-Z）</li>
<li>每个short url对应到一个整数</li>
<li>该整数对应数据库表的主键——Sequential ID</li>
</ul></li>
<li>6位可以表示不同的URL有多少？
<ul>
<li>5位 = <span class="math inline">\(62^5\)</span> = 9亿</li>
<li>6位 = <span class="math inline">\(62^6\)</span> = 570亿</li>
<li>7位 = <span class="math inline">\(62^7\)</span> = 35000亿</li>
</ul></li>
<li>优缺点
<ul>
<li>优点：效率高</li>
<li>缺点：依赖于全局的自增ID</li>
</ul></li>
</ul>
<p><strong>算法2与3的比较</strong></p>
<ul>
<li><strong>基于随机生成的方法</strong> 需要根据 Long 查询 Short，也需要根据 Short 查询 Long。基本上work solution如下图所示： <img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2018-02-10-21-00-54.png" /> 如果选择用 SQL 型数据库，表结构如下： <img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2018-02-10-20-58-03.png" /> 并且需要对shortKey和longURL分别建索引 • <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95">什么是索引？</a> • <a target="_blank" rel="noopener" href="http://www.cnblogs.com/morvenhuang/archive/2009/03/30/1425534.html">索引的原理？</a> 也可以选用 NoSQL 数据库，但是需要建立两张表（大多数NoSQL数据库不支持二级索引）。以 Cassandra 为例子 第一张表：根据 Long 查询 Short row_key=longURL, column_key=ShortURL, value=null or timestamp 第二张表：根据 Short 查询 Long row_key=shortURL, column_key=LongURL, value=null or timestamp</li>
<li><strong>基于进制转换的方法</strong> 因为需要用到自增ID（Sequential ID），因此只能选择使用 SQL 型数据库。表单结构如下，shortURL 可以不存储在表单里，因为可以根据 id 来进行换算 <img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2018-02-10-21-02-19.png" /></li>
</ul>
<h1 id="优化">优化</h1>
<p><strong>读操作的优化</strong></p>
<p>既然读操作比较多，那么可以用cache的方式去提速。</p>
<ul>
<li>cache里存什么？
<ul>
<li>long to short(生成新short url时需要)</li>
<li>short to long(查询short url时需要)</li>
</ul></li>
<li>查询的流程图： <img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2018-02-10-21-22-22.png" /></li>
</ul>
<p><strong>如何提速</strong></p>
<ul>
<li>利用地理位置信息加速</li>
<li>优化服务器速度
<ul>
<li>不同地区，使用不同Web服务器</li>
<li>通过DNS解析不同地区的用户到不同的服务器</li>
</ul></li>
<li>优化数据访问速度
<ul>
<li>使用Centralized MySQL + Distributed Memcached</li>
<li>一个MySQL配多个Memcached, Memcached跨地区分布 <img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2018-02-10-21-31-37.png" /> ​</li>
</ul></li>
</ul>
<p><strong>如何扩展机器</strong></p>
<ul>
<li><p>什么时候需要多台服务器？</p>
<ul>
<li>Cache资源不够</li>
<li>写操作越来越多</li>
<li>请求太多，无法通过Cache满足</li>
</ul></li>
<li><p>增加多台数据库可以优化什么？</p>
<ul>
<li>解决存不下的问题——Storage角度（TinyURL一般遇不到这种问题）</li>
<li>解决忙不过来的问题——QPS角度</li>
<li>TinyURL主要是什么问题？？——忙不过来的问题</li>
</ul></li>
<li><p>如何解决忙不过来的问题？</p>
<p><strong>拆分 ：</strong></p>
<ul>
<li>纵向切分？不同列放不同数据库？不可行！</li>
<li>横向拆分？一个表放多个机器？ 就将不同的short key放到不同的机器上，能解决short 2 long问题。但此时如果要解决long 2 short问题，就不好搞了。可能需要遍历每一个机器。但是回过来问，long 2 short这个问题的意义是什么。没有必要根据long查询short哇。一个long可以对应多个short，因此没必要一个long对应一个short。</li>
</ul></li>
<li><p>如果最开始shortkey为6位，那就增加一位前置位：</p>
<ul>
<li>AB1234 --&gt; 0AB1234（该前置位由hash(long_url)%62得到（可以用consistent hash算法），因此是唯一的。这个前置位可以作为机器的ID等）</li>
<li>另一种做法，把第一位单独留出来做sharding key，总共还是6位</li>
</ul></li>
</ul>
<p>那么当前的架构就变成了：</p>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2018-02-10-22-18-36.png" /></p>
<p><strong>还有优化的地方吗</strong></p>
<p>网站服务器 (Web Server) 与 数据库服务器 (Database) 之间的通信问题。</p>
<p>中心化的服务器集群（Centralized DB set）与 跨地域的 Web Server 之间通信较慢。比如中国的服务器需要访问美国的数据库那么何不让中国的服务器访问中国的数据库？</p>
<p>如果数据是重复写到中国的数据库，那么如何解决一致性问题？——很难解决</p>
<p>中国的用户访问时，会被DNS分配中国的服务器，这非常的慢。</p>
<p>而中国的用户访问的网站一般都是中国的网站，所以我们可以按照网站的地域信息进行 Sharding。（如何获得网站的地域信息？只需要将用户比较常访问的网站弄一张表就好了）</p>
<p>中国的用户访问美国的网站怎么办？那就让中国的服务器访问美国的数据好了，反正也不会慢多少。中国访问中国是主流需求，优化系统就是要优化主要的需求</p>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2018-02-10-22-23-52.png" /></p>
<p><strong>能不能提供个性化的URL?</strong></p>
<p>就是把后面的短url个性化。可以的，只要与其它short不重复就行了。如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shortURL   longURL</span><br><span class="line">1234AB     www.baidu.com</span><br><span class="line">bd         www.baidu.com</span><br></pre></td></tr></table></figure>
<p>但最好不要新开一列custom。因为这样很浪费空间。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2018/01/30/Java-Iterator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/01/30/Java-Iterator/" class="post-title-link" itemprop="url">Java-Iterator</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-01-30 19:49:29" itemprop="dateCreated datePublished" datetime="2018-01-30T19:49:29+08:00">2018-01-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:41:59" itemprop="dateModified" datetime="2018-12-17T15:41:59+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我们常常使用 JDK 提供的迭代接口进行 Java 集合的迭代。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            String string = iterator.next();</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>迭代其实我们可以简单地理解为遍历，是一个标准化遍历各类容器里面的所有对象的方法类，它是一个很典型的设计模式。Iterator 模式是用于遍历集合类的标准访问方法。它可以把访问逻辑从不同类型的集合类中抽象出来，从而避免向客户端暴露集合的内部结构。 在没有迭代器时我们都是这么进行处理的。如下：</p>
<p>对于数组我们是使用下标来进行处理的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arrays = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; arrays.length ; i++)&#123;</span><br><span class="line">       <span class="keyword">int</span> a = arrays[i];</span><br><span class="line">       <span class="comment">//do something</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于 ArrayList 是这么处理的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; list.size() ;  i++)&#123;</span><br><span class="line">      String string = list.get(i);</span><br><span class="line">      <span class="comment">//do something</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于这两种方式，我们总是都事先知道集合的内部结构，访问代码和集合本身是紧密耦合的，无法将访问逻辑从集合类和客户端代码中分离出来。同时每一种集合对应一种遍历方法，客户端代码无法复用。 在实际应用中如何需要将上面将两个集合进行整合是相当麻烦的。所以为了解决以上问题， Iterator 模式腾空出世，它总是用同一种逻辑来遍历集合。使得客户端自身不需要来维护集合的内部结构，所有的内部状态都由 Iterator 来维护。客户端从不直接和集合类打交道，它总是控制 Iterator，向它发送”向前”，”向后”，”取当前元素”的命令，就可以间接遍历整个集合。</p>
<p>上面只是对 Iterator 模式进行简单的说明，下面我们看看 Java 中 Iterator 接口，看他是如何来进行实现的。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2018/01/30/Java-Iterator/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2018/01/29/%E7%AE%97%E6%B3%95-%E6%89%AB%E6%8F%8F%E7%BA%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/01/29/%E7%AE%97%E6%B3%95-%E6%89%AB%E6%8F%8F%E7%BA%BF/" class="post-title-link" itemprop="url">算法-扫描线</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-01-29 21:44:29" itemprop="dateCreated datePublished" datetime="2018-01-29T21:44:29+08:00">2018-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:42:05" itemprop="dateModified" datetime="2018-12-17T15:42:05+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="经典扫描线">经典扫描线</h1>
<p>经典问题：<strong>数飞机问题</strong></p>
<p>给一些飞机飞行的时间区间。求天上最多有多少个飞机同时在飞。</p>
<p>例如给</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[1,3]</span><br><span class="line">[2,4]</span><br><span class="line">[5,6]</span><br><span class="line"></span><br><span class="line">求天上同时有多少架飞机</span><br></pre></td></tr></table></figure>
<p><strong>思路一，细粒度扫描</strong></p>
<p>遍历每个时刻粒度，检测每个时刻有多少个飞机</p>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2018-01-29-21-51-14.png" /></p>
<p><strong>思路二，扫描线！</strong></p>
<p>不需要检测每一时刻，只需要检测起点或者终点的位置！（交点变化的位置只有起点或者终点）</p>
<ol type="1">
<li>将数据拆成二元组 [起点/终点标识，时刻]</li>
<li>按照时刻排序</li>
<li>依次扫描</li>
</ol>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2018/01/29/%E7%AE%97%E6%B3%95-%E6%89%AB%E6%8F%8F%E7%BA%BF/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2018/01/29/%E7%AE%97%E6%B3%95-%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3%E4%B9%A0%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/01/29/%E7%AE%97%E6%B3%95-%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3%E4%B9%A0%E9%A2%98/" class="post-title-link" itemprop="url">算法-数学相关习题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-01-29 18:10:15" itemprop="dateCreated datePublished" datetime="2018-01-29T18:10:15+08:00">2018-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:42:05" itemprop="dateModified" datetime="2018-12-17T15:42:05+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="素数">素数</h1>
<h2 id="判断n是素数">判断n是素数</h2>
<p><strong>解法一，暴解</strong></p>
<p>如果n是素数，那么n不能被任何数（1和n除外）的数字整除。暴力的方法就是从2~n-1进行探测，探测<span class="math inline">\(\frac{n}{k}, k = 2,3,...,n-1\)</span> 是否是整数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">ifPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>; k &lt; n; ++k)&#123;</span><br><span class="line">    <span class="keyword">if</span>(n % k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解法二，优化</strong></p>
<p>事实上，如果n不是素数，那么一定存在<span class="math inline">\(n = a \times b\)</span> ，而a和b的可能性有：</p>
<table>
<thead>
<tr class="header">
<th>a</th>
<th>b</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2</td>
<td>n/2</td>
</tr>
<tr class="even">
<td>3</td>
<td>n/3</td>
</tr>
<tr class="odd">
<td>...</td>
<td>...</td>
</tr>
<tr class="even">
<td>n/3</td>
<td>3</td>
</tr>
<tr class="odd">
<td>n/2</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>我们发现，a和b有重复计算的部分，即如果a &lt; sqrt(n) , 那么b &gt; sqrt(n) 。因此a只用探测到sqrt(n)即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">ifPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">int</span> sqrt = (<span class="keyword">int</span>)Math.sqrt(n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>; k &lt; sqrt; ++k)&#123;</span><br><span class="line">    <span class="keyword">if</span>(n % k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解法三，素数筛——生成素数序列：埃拉托斯特尼筛法</strong></p>
<p>素数筛能非常高效地生成素数序列。原理是剔除所有可被素数整除的非素数。</p>
<ol type="1">
<li>列出2~max所有的数字</li>
<li>剔除所有2的倍数（2保留）</li>
<li>剔除下一个没有被划掉的倍数</li>
<li>循环直到max</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span>[] notPrime = <span class="keyword">new</span> <span class="keyword">boolean</span>[n]; <span class="comment">// notPrime[i]==true代表i-1不是素数</span></span><br><span class="line">       <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">           <span class="keyword">if</span>(notPrime[i] == <span class="keyword">false</span>)&#123;</span><br><span class="line">               ++counter;</span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>; k*i &lt; n; ++k)&#123;</span><br><span class="line">                   notPrime[k*i] = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> counter;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="面积问题">面积问题</h1>
<h2 id="perfect-rectangle">Perfect Rectangle</h2>
<p>假设一个矩形有四个数表示<code>[a,b,c,d]</code> 。其中<code>[a,b]</code> 代表left bottom角的坐标，<code>[c,d]</code> 表示right top的坐标。给一堆矩形，判断它是否能刚刚好（不重合也不漏缺）地构成一个大的矩形</p>
<p>这道题耗费了较长时间。因为没想通。</p>
<p>核心思想就是:能够正好围成一个矩形的情况就是: 有且只有:</p>
<ul>
<li>最左下 最左上 最右下 最右上 的四个点只出现过一次,其他肯定是成对出现的(保证完全覆盖)</li>
<li>上面四个点围成的面积,正好等于所有子矩形的面积之和(保证不重复)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    Pair(<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object oo)</span></span>&#123;</span><br><span class="line">        Pair o = (Pair)oo;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x == o.x &amp;&amp; <span class="keyword">this</span>.y == o.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123; <span class="comment">//在使用HashSet（contains也是调用HashMap中的方法）、HashMap等集合时，如果用到contains系列方法时，记得需同时重写equals与hashCode方法。</span></span><br><span class="line">        <span class="keyword">return</span> x + y*<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="string">&quot;[&quot;</span>+ x + <span class="string">&quot;,&quot;</span> + y + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, bottom = <span class="number">1</span>, right = <span class="number">2</span>, top = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRectangleCover</span><span class="params">(<span class="keyword">int</span>[][] rectangles)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 能够成矩形的条件：</span></span><br><span class="line">    <span class="comment">// 1. 最边上的四个点只到达了一次</span></span><br><span class="line">    <span class="comment">// 2. 其余的所有点到达了两次</span></span><br><span class="line">    <span class="comment">// 3. 最大矩阵面积 = 所有面积的和 // 这个很容易忽略</span></span><br><span class="line">    HashMap&lt;Pair,Integer&gt; memo = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] corner = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rectangles[<span class="number">0</span>].length; ++i)&#123;</span><br><span class="line">        corner[i] = rectangles[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] corners4 = &#123;&#123;left, bottom&#125;,&#123;right,top&#125;, &#123;left,top&#125;,&#123;right,bottom&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] rectangle : rectangles)&#123;</span><br><span class="line">        corner[left] = Math.min(rectangle[left], corner[left]);</span><br><span class="line">        corner[bottom] = Math.min(rectangle[bottom], corner[bottom]);</span><br><span class="line">        corner[top] = Math.max(rectangle[top],corner[top]);</span><br><span class="line">        corner[right] = Math.max(rectangle[right], corner[right]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] cor : corners4)&#123;</span><br><span class="line">            Pair pair = <span class="keyword">new</span> Pair(rectangle[cor[<span class="number">0</span>]], rectangle[cor[<span class="number">1</span>]]);</span><br><span class="line">            memo.put(pair, memo.getOrDefault(pair, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        area += (rectangle[<span class="number">2</span>] -rectangle[<span class="number">0</span>])*(rectangle[<span class="number">3</span>] - rectangle[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查面积</span></span><br><span class="line">    <span class="keyword">if</span>(area != (corner[<span class="number">2</span>] - corner[<span class="number">0</span>])*(corner[<span class="number">3</span>] - corner[<span class="number">1</span>])) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 检查四个角是否只到达了一次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] cor : corners4)&#123;</span><br><span class="line">        Pair pair = <span class="keyword">new</span> Pair(corner[cor[<span class="number">0</span>]], corner[cor[<span class="number">1</span>]]);</span><br><span class="line">        <span class="keyword">if</span>(memo.getOrDefault(pair,<span class="number">0</span>) != <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        memo.remove(pair);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查其余节点是否都是两次</span></span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;Pair, Integer&gt; entry : memo.entrySet())&#123;</span><br><span class="line">        <span class="keyword">if</span>(entry.getValue() != <span class="number">2</span> &amp;&amp; entry.getValue() != <span class="number">4</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="perfect-number">Perfect Number</h2>
<p>定义完美数字为：除了它自己以外的所有除数相加都等于它本身。判断一个数是不是一个完美数字。</p>
<p>与上面的类似解法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkPerfectNumber</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 寻找所有的除数</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max = (<span class="keyword">int</span>)Math.sqrt(num);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= max; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num % i == <span class="number">0</span>)&#123;</span><br><span class="line">                sum += i;</span><br><span class="line">                sum += num/i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum == num;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="组合数学">组合数学</h1>
<h2 id="环形染色问题">环形染色问题</h2>
<p>如果把一个圆环分成n个区域<span class="math inline">\(A_n\)</span>。用m种不同颜色为这n个区域染色。要求相邻两个区域<span class="math inline">\(A_i\)</span> 和 <span class="math inline">\(A_{i+1}\)</span> 颜色不同，则不同的染色方式有多少种？</p>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2018-03-06-22-52-53.png" /></p>
<ul>
<li>对于区域<span class="math inline">\(A_1\)</span> ，有m种染色法；</li>
<li>对于区域<span class="math inline">\(A_2,...,A_{n-1}\)</span> ，分别有m-1种染色法</li>
<li>假设暂时不考虑<span class="math inline">\(A_n\)</span> 与<span class="math inline">\(A_1\)</span> ，那么对于区域<span class="math inline">\(A_n\)</span> ，有<span class="math inline">\(m-1\)</span> 种染法。
<ul>
<li>如果<span class="math inline">\(A_n\)</span> 与<span class="math inline">\(A_1\)</span> 同色，那么就将这两个看成同一个区域，这就退化成了n-1个区域的染色种类，即<span class="math inline">\(a_{n-1}\)</span></li>
</ul></li>
<li>因此有<span class="math display">\[a_n + a_{n-1} = m(m-1)^{n-1}\]</span></li>
</ul>
<p>接下来通过数列递推公式求通项公式：</p>
<p>由于对上式两边同时减去<span class="math inline">\((m-1)^n\)</span>：</p>
<p><span class="math display">\[a_n + a_{n-1} - (m-1)^n = m(m-1)^{n-1} - (m-1)^n\]</span> ，递推可得：</p>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2018-03-06-23-04-07.png" /></p>
<p>因此，环形染色问题的解为：</p>
<p><span class="math display">\[a_n = (m-1)^n + (-1)^n(m-1)\]</span></p>
<h1 id="计算几何">计算几何</h1>
<h2 id="valid-square">Valid Square</h2>
<p>验证给定的四个点是否能组成正方形。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validSquare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b, <span class="keyword">int</span>[] c, <span class="keyword">int</span>[] d)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/** 矩形: 对角线一定相等且垂直且平分</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">if</span>(diagonal(a,b,c,d) &amp;&amp; equal(a,b,c,d) &amp;&amp; divideEqual(a,b,c,d)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(diagonal(a,c,b,d) &amp;&amp; equal(a,c,b,d) &amp;&amp; divideEqual(a,c,b,d)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(diagonal(a,d,c,b) &amp;&amp; equal(a,d,c,b) &amp;&amp; divideEqual(a,d,c,b)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断ab与cd互相平分</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">divideEqual</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b, <span class="keyword">int</span>[] c, <span class="keyword">int</span>[] d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] media_ab = &#123;a[<span class="number">0</span>] + b[<span class="number">0</span>], a[<span class="number">1</span>] + b[<span class="number">1</span>]&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] media_cd = &#123;c[<span class="number">0</span>] + d[<span class="number">0</span>], c[<span class="number">1</span>] + d[<span class="number">1</span>]&#125;;</span><br><span class="line">        <span class="keyword">return</span> media_ab[<span class="number">0</span>] == media_cd[<span class="number">0</span>] &amp;&amp; media_ab[<span class="number">1</span>] == media_cd[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**判断ab与cd两直线相等**/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">equal</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b, <span class="keyword">int</span>[] c, <span class="keyword">int</span>[] d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dist(a,b) != <span class="number">0</span> &amp;&amp; dist(a,b) == dist(c,d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dist</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a[<span class="number">0</span>]-b[<span class="number">0</span>])*(a[<span class="number">0</span>]-b[<span class="number">0</span>]) + (a[<span class="number">1</span>]-b[<span class="number">1</span>])*(a[<span class="number">1</span>]-b[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    判断ab与cd两直线是否垂直</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">diagonal</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b, <span class="keyword">int</span>[] c, <span class="keyword">int</span>[] d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] vector_ab = &#123;a[<span class="number">0</span>] - b[<span class="number">0</span>], a[<span class="number">1</span>] - b[<span class="number">1</span>]&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] vector_cd = &#123;c[<span class="number">0</span>] - d[<span class="number">0</span>], c[<span class="number">1</span>] - d[<span class="number">1</span>]&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// dot</span></span><br><span class="line">        <span class="keyword">int</span> dot = vector_ab[<span class="number">0</span>]*vector_cd[<span class="number">0</span>] + vector_ab[<span class="number">1</span>]*vector_cd[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> dot == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2018/01/29/Java-LinkedHashMap%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/01/29/Java-LinkedHashMap%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/" class="post-title-link" itemprop="url">Java-LinkedHashMap原理探究</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-01-29 16:01:57" itemprop="dateCreated datePublished" datetime="2018-01-29T16:01:57+08:00">2018-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:41:59" itemprop="dateModified" datetime="2018-12-17T15:41:59+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在之前的 <a href="/2018/01/27/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95/" title="系统设计-缓存算法">系统设计-缓存算法</a> 一文里我用到了LinkedHashMap。这是最近刚接触到的一个新的数据结构。在此进行原理的探究。</p>
<p>LinkedHashMap 是 HashMap 的一个子类，它<strong>保留插入的顺序</strong>，如果需要输出的顺序和输入时的相同，那么就选用 LinkedHashMap。</p>
<p>LinkedHashMap 实现与 HashMap 的不同之处在于，LinkedHashMap 维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。</p>
<p>注意，此实现不是同步的。如果多个线程同时访问链接的哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。</p>
<p>根据链表中元素的顺序可以分为：按插入顺序的链表，和按访问顺序(调用 get 方法)的链表。默认是按插入顺序排序，如果指定按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2018/01/29/Java-LinkedHashMap%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">jiayi797</p>
  <div class="site-description" itemprop="description">.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">150</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jiayi797</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
    <span class="post-count">| 博客共334.5k字</span>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
