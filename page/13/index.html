<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
<!-- Referrer Policy调整致不蒜子单页面统计出错:https://senorui.top/posts/c33f.html -->
<meta name="referrer" content="no-referrer-when-downgrade">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jiayi797.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content=".">
<meta property="og:type" content="website">
<meta property="og:title" content="甲乙小朋友的房子">
<meta property="og:url" content="http://jiayi797.github.io/about/page/13/index.html">
<meta property="og:site_name" content="甲乙小朋友的房子">
<meta property="og:description" content=".">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="jiayi797">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://jiayi797.github.io/about/page/13/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>甲乙小朋友的房子</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">甲乙小朋友的房子</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">甲乙小朋友很笨，但甲乙小朋友不会放弃</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2017/03/31/%E6%95%B0%E5%AD%A6-QR%E5%88%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/03/31/%E6%95%B0%E5%AD%A6-QR%E5%88%86%E8%A7%A3/" class="post-title-link" itemprop="url">QR分解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-03-31 12:02:39" itemprop="dateCreated datePublished" datetime="2017-03-31T12:02:39+08:00">2017-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:42:03" itemprop="dateModified" datetime="2018-12-17T15:42:03+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">数学</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="qr分解">QR分解</h1>
<p><strong>引理</strong>：</p>
<ol type="1">
<li>对于任意的<span class="math inline">\(A\in C^{n\times n}\)</span>,若存在<span class="math inline">\(n\)</span>阶正交矩阵<span class="math inline">\(Q\)</span>和<span class="math inline">\(n\)</span>阶上三角矩阵<span class="math inline">\(R\)</span>，使得<span class="math inline">\(A=QR\)</span>，则称<span class="math inline">\(QR\)</span>为<span class="math inline">\(A\)</span>的<span class="math inline">\(QR\)</span>分解。</li>
<li>若<span class="math inline">\(A\in C^{n\times n}\)</span>可逆，则存在正交矩阵<span class="math inline">\(Q\)</span>和正对角元的上三角矩阵<span class="math inline">\(R\)</span>，使得<span class="math inline">\(A=QR\)</span>，且表示式唯一。</li>
</ol>
<p>备注：正交矩阵：<span class="math inline">\(A^{-1}=A^T\)</span> <strong>QR分解定理</strong>：<img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-31-12-06-04.png" /> ，则A有QR分解：<img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-31-12-06-23.png" /> Q是m<em>m的正交矩阵 R是n</em>n的有非负对角元的上三角阵</p>
<p>当m=n，且A非奇异时，上述分解唯一。</p>
<p><strong>计算QR分解的方法</strong> <img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-31-22-28-42.png" /></p>
<p>备注： 计算A(j:m,j:n)=(I(m-j+1)-bvvT)A(j:m,j:n)时， I(m-j+1)-bvvT可以表示为： <img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-04-01-21-24-25.png" /></p>
<p><strong>QR分解的存储方法</strong> <img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-04-01-21-54-20.png" /></p>
<p><strong>用QR分解解线性方程组</strong> <span class="math inline">\(Ax=b\)</span> <span class="math inline">\(QRx=b\)</span> <span class="math inline">\(Rx=Q^{-1}b\)</span> <span class="math inline">\(x=R^{-1}Q^{-1}b\)</span> <span class="math inline">\(x=R^{-1}Q^Tb\)</span></p>
<h1 id="householder方法">householder方法</h1>
<p>利用Householder变换逐步将A化为上三角矩阵。</p>
<p>使用Gauss变换将矩阵化为上三角的理论依据————对于一个给定的向量x，可构造一个初等下三角阵L，使得<span class="math inline">\(Lx=ae_1\)</span>，其中<span class="math inline">\(e_1\)</span>是I的第一列，a是实数。（I是单位矩阵）</p>
<p>householder变换目的： 求一个初等正交矩阵，使其具有矩阵L的功能。</p>
<p>使得： 可以通过一系列初等正交变换来完成矩阵的上三角化任务。</p>
<p><strong>Householder变换</strong> <img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-31-22-03-16.png" /></p>
<p>其中： I是单位矩阵 w是实的单位列向量（单位正交矩阵），<span class="math inline">\(ww^T=I\)</span></p>
<p>HouseHolder变换可以将一个向量映射到一个超平面上。</p>
<p><strong>Householder变换的性质</strong></p>
<ol type="1">
<li>对称性。<span class="math inline">\(H^T=H\)</span></li>
<li>正交性。<span class="math inline">\(H^TH=I\)</span></li>
<li>对合性。<span class="math inline">\(H^2=I\)</span></li>
<li>反射性(householder变换的物理意义)：<img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-31-22-09-23.png" /> <img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-31-22-10-12.png" /></li>
</ol>
<p><strong>Householder变换的用途</strong></p>
<p>它能如Gauss变换一样，可以通过适当选取单位向量w，把一个给定向量的若干指定的分量变为零。 <img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-31-22-12-23.png" /> 由以上定理可知，对于任意的x，都可以构造出Householder矩阵H，使得Hx的后n-1个分量为零。</p>
<p><strong>Householder变换方法</strong> 计算某一行向量的houser变换： <img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-31-22-24-15.png" /> <img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-31-22-24-37.png" /> <img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-31-22-24-58.png" /></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2017/03/30/%E6%95%B0%E5%AD%A6-%E6%B1%82%E7%BA%BF%E4%BB%A3%E6%96%B9%E7%A8%8B%E7%9A%84%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/03/30/%E6%95%B0%E5%AD%A6-%E6%B1%82%E7%BA%BF%E4%BB%A3%E6%96%B9%E7%A8%8B%E7%9A%84%E8%A7%A3/" class="post-title-link" itemprop="url">求线代方程的解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-03-30 14:48:21" itemprop="dateCreated datePublished" datetime="2017-03-30T14:48:21+08:00">2017-03-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:42:03" itemprop="dateModified" datetime="2018-12-17T15:42:03+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">数学</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="lu分解条件">LU分解条件</h1>
<p>如果n阶方阵A的各阶顺序主子式<img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-29-19-34-31.png" /> ，即A的各阶顺序主子矩阵Ak都可逆，则存在唯一的单位下三角矩阵L与唯一的非奇异上三角矩阵U，使得A=LU</p>
<p>其中k阶顺序主子式指 <img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-29-19-36-08.png" /></p>
<h1 id="lu分解方法">LU分解方法</h1>
<p>由于L存在可逆矩阵L'，即LL'=E 则L'A=LL'U=U 因此得出一般的分解方法： 通过对(A,E)做初等行变换得到(U,L'),再由L'得到L.</p>
<p>其中：</p>
<ol type="1">
<li>L是单位下三角矩阵（对角线上的系数都为1的下三角矩阵）；L'也是单位上三角矩阵；</li>
<li>U是非奇异上三角矩阵；</li>
</ol>
<h1 id="求解方法">求解方法</h1>
<p>对于一般的线性方程组： <span class="math display">\[Ax=b\]</span> 如果我们能将A分解成<span class="math inline">\(A=LU\)</span>,即一个下三角阵和一个上三角阵U的乘积，那原方程组的解x便可由下面两步得到：</p>
<ol type="1">
<li>用前代法解<span class="math inline">\(Ly=b\)</span>的y； <img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-30-16-20-29.png" /></li>
<li>用回代法解<span class="math inline">\(Ux=y\)</span>的x. <img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-30-16-31-08.png" /></li>
</ol>
<p>对于列主元消去法，求线性方程组<span class="math inline">\(Ax=b\)</span>的计算过程可以按照以下步骤进行：</p>
<ol type="1">
<li>求A的列主元LU分解<span class="math inline">\(PA=LU\)</span></li>
<li>解下三角形方程组<span class="math inline">\(Ly=Pb\)</span></li>
<li>解上三角形方程组<span class="math inline">\(Ux=y\)</span></li>
</ol>
<h1 id="实现">实现</h1>
<p>前代法： 需要注意的是，回代法在计算的过程中需要考虑到主元位置序列，并同时对b进行调整。</p>
<pre><code>double * forwardSub(double *lu,int n,double *b,int *p)&#123;
    //double *y=new double[n];
    double temp;
      //按qivot对b行变换，与LU匹配
      for(int i=0; i&lt;n-1; i++)  
      &#123;
            temp = b[p[i]];
            b[p[i]] = b[i];
            b[i]=temp;
      &#125;
    for(int i=0; i&lt;n; i++)
            for(int j=0; j&lt;i; j++)
                b[i]=b[i]-lu[n*i+j]*b[j];
    b[n-1]=b[n-1];
    return b;
&#125;</code></pre>
<p>回代法： 由于U是上三角矩阵，所以要从x[n-1]开始计算。</p>
<pre><code>double * backSub(double *b,double *lu,int n)&#123;
     for(int i=n-1; i&gt;=0; i--)
      &#123;
            for(int j=n-1; j&gt;i; j--)
                b[i]=b[i]-lu[n*i+j]*b[j];
            b[i]=b[i]/lu[n*i+i];
      &#125;
    return b;
&#125;</code></pre>
<p>计算：</p>
<pre><code>bool guass(double *lu,int *p,double*b,int n)&#123;
    double * y = forwardSub(lu,n,b,p);
    double * x = backSub(y,lu,n);
    std::cout&lt;&lt;endl&lt;&lt;&quot;the sulution is ; &quot;&lt;&lt;endl;
    for(int i=0;i&lt;n;i++)&#123;
        std::cout&lt;&lt;x[i]&lt;&lt;&quot;\t&quot;;
    &#125;
    std::cout&lt;&lt;endl;
&#125;</code></pre>
<p>输出： <img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-31-11-02-01.png" /></p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;iomanip&gt;
#define LIM -100000000
using namespace std;
double *luReult;
void printmat(double *mat,int n,string s)&#123;
    std::cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;s&lt;&lt;endl;
    for(int i=0;i&lt;n;i++)&#123;
        for(int j=0;j&lt;n;j++)&#123;
            printf(&quot;%.5f\t&quot;,mat[i*n+j]);
        &#125;
        std::cout&lt;&lt;endl;
    &#125;
&#125;
void printarr(int *mat,int n,string s)&#123;
    std::cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;s&lt;&lt;endl;
    for(int i=0;i&lt;n;i++)&#123;
        std::cout&lt;&lt;mat[i]&lt;&lt;&quot;\t&quot;;
        //printf(&quot;%s\t&quot;,mat[i]);
    &#125;
&#125;
int findMainNumber(double *a,int n,int r)&#123;
    float maxa=-99999;
    int maxaIdx=-1;
    //printmat(a,n,&quot;a is now :&quot;);
    for(int i=r;i&lt;n;i++)&#123;
        if(a[i*n+r]&gt;maxa)&#123;
            maxa=a[i*n+r];
            maxaIdx=i;
        &#125;
    &#125;
    return maxaIdx;
&#125;
void exchange(double *a,int n,int e,int r)&#123;
    float temp=0;
    for(int i=0;i&lt;n;i++)&#123;
        temp = a[r*n+i];
        a[r*n+i]=a[e*n+i];
        a[e*n+i]=temp;
    &#125;
&#125;
bool lu(double* a, int* pivot, int n)//矩阵LU分解
&#123;
      for(int k=0;k&lt;n;k++)&#123;
        //寻找第k列的主元
        int p = findMainNumber(a,n,k);
        exchange(a,n,p,k);//交换k行和p行
        pivot[k]=p;//记录置换矩阵p
        if(a[k*n+k]!=0)&#123;
                for(int i=k+1;i&lt;n;i++)&#123;//部分下三角L
                    a[i*n+k]=a[i*n+k]/a[k*n+k];
                &#125;
                for(int i=k+1;i&lt;n;i++)&#123;//计算上三角U
                    for(int j=k+1;j&lt;n;j++)&#123;
                        a[i*n+j]=a[i*n+j]-a[i*n+k]*a[k*n+j];
                    &#125;
                &#125;
        &#125;else&#123;
            return true;//矩阵奇异
        &#125;
      &#125;
      /*
      //计算下三角L
      double temp=0;
       for(int i=0; i&lt;n-2; i++)//i行k列
            for(int k=i+1; k&lt;n-1;k++)
            &#123;
                    temp=a[n*pivot[k] + i];
                    a[n*pivot[k] + i]=a[k*n + i];
                    a[k*n + i]=temp;
            &#125;
        */
      luReult=a;
      printmat(a,n,&quot;lu&quot;);
      return false ;
&#125;
double radio(int a,int b)&#123;
    return (double)(a)/(double)(b);
&#125;
void buildHilbert(double *a,double *b,int n)&#123;
    for(int r=0;r&lt;n;r++)&#123;
        for(int j=0;j&lt;n;j++)&#123;
            a[r*n+j]=radio(1,j+r+1);
            b[r]=b[r]+a[r*n+j];
        &#125;
    &#125;
&#125;
void exchangeb(double *b,int n,int r,int e)&#123;
    double temp=0;
    temp=b[e];
    b[e]=b[r];
    b[r]=temp;
    /*r(int i=0;i&lt;n;i++)&#123;
        temp=b[r*n+i];
        b[r*n+i]=b[e*n+i];
        b[e*n+i]=temp;
    &#125;*/
&#125;
double * forwardSub(double *lu,int n,double *b,int *p)&#123;
    //double *y=new double[n];
    double temp;
      //按qivot对b行变换，与LU匹配
      for(int i=0; i&lt;n-1; i++)
      &#123;
            temp = b[p[i]];
            b[p[i]] = b[i];
            b[i]=temp;
      &#125;
    for(int i=0; i&lt;n; i++)
            for(int j=0; j&lt;i; j++)
                b[i]=b[i]-lu[n*i+j]*b[j];
    b[n-1]=b[n-1];
    return b;
&#125;

double * backSub(double *b,double *lu,int n)&#123;
     for(int i=n-1; i&gt;=0; i--)
      &#123;
            for(int j=n-1; j&gt;i; j--)
                b[i]=b[i]-lu[n*i+j]*b[j];
            b[i]=b[i]/lu[n*i+i];
      &#125;
    return b;
&#125;

bool guass(double *lu,int *p,double*b,int n)&#123;
    double * y = forwardSub(lu,n,b,p);
    double * x = backSub(y,lu,n);
    std::cout&lt;&lt;endl&lt;&lt;&quot;the sulution is ; &quot;&lt;&lt;endl;
    for(int i=0;i&lt;n;i++)&#123;
        std::cout&lt;&lt;x[i]&lt;&lt;&quot;\t&quot;;
    &#125;
    std::cout&lt;&lt;endl;
&#125;
int main()
&#123;
    int n=6;//矩阵是n*n的
    double *b=new double[n];
    double *a=new double[n*n];
    /*double input[n*n]=&#123;0.001,1.00,1.00,2.00&#125;;
    a=input;
    double inputb[n]=&#123;1.00,3.00&#125;;
    b=inputb;*/
    buildHilbert(a,b,n);
    printmat(a,n,&quot;a:&quot;);
    int *pivot=new int[n*n];
    luReult=new double[n*n];
    lu(a,pivot,n);
    printarr(pivot,n,&quot;p:&quot;);
     guass(luReult,pivot,b,n);
    //cout &lt;&lt; &quot;Hello world!&quot; &lt;&lt; endl;
    return 0;
&#125;</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2017/03/29/%E6%95%B0%E5%AD%A6-%E7%9F%A9%E9%98%B5LU%E5%88%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/03/29/%E6%95%B0%E5%AD%A6-%E7%9F%A9%E9%98%B5LU%E5%88%86%E8%A7%A3/" class="post-title-link" itemprop="url">矩阵LU分解及其实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-03-29 19:27:31" itemprop="dateCreated datePublished" datetime="2017-03-29T19:27:31+08:00">2017-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:42:03" itemprop="dateModified" datetime="2018-12-17T15:42:03+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">数学</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>LU分解:可以将一个矩阵分解为一个<strong>单位下三角矩阵</strong>和一个<strong>上三角矩阵</strong>的<strong>乘积</strong>（有时是它们和一个置换矩阵的乘积）。LU分解主要应用在数值分析中，用来解线性方程、求反矩阵或计算行列式。</p>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-29-19-31-33.png" /></p>
<h1 id="lu分解条件">LU分解条件</h1>
<p>如果n阶方阵A的各阶顺序主子式<img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-29-19-34-31.png" /> ，即A的各阶顺序主子矩阵Ak都可逆，则存在唯一的单位下三角矩阵L与唯一的非奇异上三角矩阵U，使得A=LU</p>
<p>其中k阶顺序主子式指 <img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-29-19-36-08.png" /></p>
<h1 id="lu分解方法">LU分解方法</h1>
<p>由于L存在可逆矩阵L'，即LL'=E 则L'A=LL'U=U 因此得出一般的分解方法： 通过对(A,E)做初等行变换得到(U,L'),再由L'得到L.</p>
<p>其中：</p>
<ol type="1">
<li>L是单位下三角矩阵（对角线上的系数都为1的下三角矩阵）；L'也是单位上三角矩阵；</li>
<li>U是非奇异上三角矩阵；</li>
</ol>
<h1 id="直接消去法的矩阵解释">直接消去法的矩阵解释</h1>
<p>计算过程如图所示： <img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-29-20-13-15.png" /></p>
<p><strong>目的</strong>：将[A|E]--&gt;[U|L]形式，其中U是上三角矩阵</p>
<p><strong>过程</strong>：每轮将一列的下三角消为0，就相当于给A左乘一个下三角单位矩阵Lk（对角线为1，保证变换后对角线元素不变）。</p>
<p><strong>第一轮消元</strong>：将第一列的下三角消为0，相当于对A1左乘矩阵L1，即：<img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-29-20-54-39.png" /> 其中， <img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-29-20-55-24.png" /> 我们注意到li1恰好使得第i行的第一列元素变为零，即ai1-li1*a11=0。</p>
<p><strong>第二轮消元</strong>：将第二列的下三角消为0，对应于<img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-29-20-57-24.png" /></p>
<p><strong>第k轮消元</strong>:<img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-29-20-57-48.png" /> 其中，<img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-29-20-58-09.png" /></p>
<p>把k轮消元相乘，即： <strong>整个消元过程为</strong>： <img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-29-20-59-09.png" /></p>
<p><strong>总结</strong> <img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-29-21-05-36.png" /> 初始（第一步）： <img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-29-21-00-46.png" /></p>
<p>迭代第r步： 即 ur=f(u1,u2,...,u(r-1),l1,l2,...,l(r-1)),第r项由前r-1项计算得到 lr=g(u1,u2,...,u(r-1),l1,l2,...,l(r-1)) <img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-29-21-02-44.png" /></p>
<p>计算顺序：</p>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-30-10-36-28.png" /></p>
<p>需要注意的是，我们在计算时需要判断本阶的顺序主子式是否为零。</p>
<p><strong>代码实现</strong> 备注：其中的piovt暂时没有卵用。</p>
<p>输入矩阵：<img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-30-14-16-46.png" /></p>
<pre><code>bool lu(double *a,int *pivot,int n)&#123;//矩阵是n*n的
double test = det(a,r,n);//检验本阶顺序主子式是否为0
 if(test==0)&#123;
    return true;
 &#125;
//数组a在内存中按行优先次序存放
//pivot:输出参数
//pivot[0,n)中存放主元的位置排列
//成功时返回false，否则返回ture
//int len = sizeof(a)/sizeof(a[0]);
double *U,*L;
U = new double[n*n];
L = new double[n*n];
set0(U,n);
set0(L,n);
//先算urj(固定r，计算完所有的urj)，再算ljr(固定i，计算完所有的ljr)
for(int r=0;r&lt;n;r++)&#123;
    //计算urj(固定r，计算完所有的urj)
    //计算ljr(固定i，计算完所有的ljr)
    for(int j=r;j&lt;n;j++)&#123;
        double sum_lu1=0;
        double sum_lu2=0;
        for(int k=0;k&lt;r;k++)&#123;
            sum_lu1 = sum_lu1+L[r*n+k]*U[k*n+j];
            sum_lu2 = sum_lu2+L[j*n+k]*U[k*n+r];
        &#125;
        U[r*n+j]=a[r*n+j]-sum_lu1;
        if(j==r)&#123;
            L[j*n+r]=1;
        &#125;else&#123;
            L[j*n+r]=a[j*n+r]-sum_lu2;
            L[j*n+r]=L[j*n+r]/U[r*n+r];
        &#125;
    &#125;
&#125;
return false;
&#125;</code></pre>
<p>结果： <img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-30-14-22-05.png" /></p>
<p>不知道为什么，我的答案与网上的之前学长做过的这道题的答案统统不一样。仔细检查后还是查不出来。又用Matlab验证了一下LU分解，MATLAB跑的结果为： <img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-30-14-39-25.png" /> 与我自己的L矩阵一致。决定还是相信自己。</p>
<h1 id="列主元高斯消去法">列主元高斯消去法</h1>
<p>主要思想是在每次计算第r行时，选取当前第r列下的最大的a[i,r]的所在的第i行作为主元，即将第i行与第r行交换，再进行计算。</p>
<p>主要理论见参考文献-北邮理学院数值分析课件chapter5.</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;iomanip&gt;
#define LIM -100000000
using namespace std;
double *luReult;
void printmat(double *mat,int n,string s)&#123;
    std::cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;s&lt;&lt;endl;
    for(int i=0;i&lt;n;i++)&#123;
        for(int j=0;j&lt;n;j++)&#123;
            printf(&quot;%.5f\t&quot;,mat[i*n+j]);
        &#125;
        std::cout&lt;&lt;endl;
    &#125;
&#125;
void printarr(int *mat,int n,string s)&#123;
    std::cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;s&lt;&lt;endl;
    for(int i=0;i&lt;n;i++)&#123;
        std::cout&lt;&lt;mat[i]&lt;&lt;&quot;\t&quot;;
        //printf(&quot;%s\t&quot;,mat[i]);
    &#125;
&#125;
int findMainNumber(double *a,int n,int r)&#123;
    float maxa=-99999;
    int maxaIdx=-1;
    //printmat(a,n,&quot;a is now :&quot;);
    for(int i=r;i&lt;n;i++)&#123;
        if(a[i*n+r]&gt;maxa)&#123;
            maxa=a[i*n+r];
            maxaIdx=i;
        &#125;
    &#125;
    return maxaIdx;
&#125;
void exchange(double *a,int n,int e,int r)&#123;
    float temp=0;
    for(int i=0;i&lt;n;i++)&#123;
        temp = a[r*n+i];
        a[r*n+i]=a[e*n+i];
        a[e*n+i]=temp;
    &#125;
&#125;
bool lu(double* a, int* pivot, int n)//矩阵LU分解
&#123;
      for(int k=0;k&lt;n;k++)&#123;
        //寻找第k列的主元
        int p = findMainNumber(a,n,k);
        exchange(a,n,p,k);//交换k行和p行
        pivot[k]=p;//记录置换矩阵p
        if(a[k*n+k]!=0)&#123;
                for(int i=k+1;i&lt;n;i++)&#123;//部分下三角L
                    a[i*n+k]=a[i*n+k]/a[k*n+k];
                &#125;
                for(int i=k+1;i&lt;n;i++)&#123;//计算上三角U
                    for(int j=k+1;j&lt;n;j++)&#123;
                        a[i*n+j]=a[i*n+j]-a[i*n+k]*a[k*n+j];
                    &#125;
                &#125;
        &#125;else&#123;
            return true;//矩阵奇异
        &#125;
      &#125;
      /*
      //计算下三角L
      double temp=0;
       for(int i=0; i&lt;n-2; i++)//i行k列
            for(int k=i+1; k&lt;n-1;k++)
            &#123;
                    temp=a[n*pivot[k] + i];
                    a[n*pivot[k] + i]=a[k*n + i];
                    a[k*n + i]=temp;
            &#125;
        */
      luReult=a;
      printmat(a,n,&quot;lu&quot;);
      return false ;
&#125;
double radio(int a,int b)&#123;
    return (double)(a)/(double)(b);
&#125;
void buildHilbert(double *a,double *b,int n)&#123;
    for(int r=0;r&lt;n;r++)&#123;
        for(int j=0;j&lt;n;j++)&#123;
            a[r*n+j]=radio(1,j+r+1);
            b[r]=b[r]+a[r*n+j];
        &#125;
    &#125;
&#125;
void exchangeb(double *b,int n,int r,int e)&#123;
    double temp=0;
    temp=b[e];
    b[e]=b[r];
    b[r]=temp;
    /*r(int i=0;i&lt;n;i++)&#123;
        temp=b[r*n+i];
        b[r*n+i]=b[e*n+i];
        b[e*n+i]=temp;
    &#125;*/
&#125;

int main()
&#123;
    int n=6;//矩阵是n*n的
    double *b=new double[n];
    double *a=new double[n*n];
    /*double input[n*n]=&#123;0.001,1.00,1.00,2.00&#125;;
    a=input;
    double inputb[n]=&#123;1.00,3.00&#125;;
    b=inputb;*/
    buildHilbert(a,b,n);
    printmat(a,n,&quot;a:&quot;);
    int *pivot=new int[n*n];
    luReult=new double[n*n];
    lu(a,pivot,n);
    printarr(pivot,n,&quot;p:&quot;);
    //cout &lt;&lt; &quot;Hello world!&quot; &lt;&lt; endl;
    return 0;
&#125;</code></pre>
<p>输出： <img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-31-11-02-01.png" /></p>
<h1 id="参考文献">参考文献</h1>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://ccjou.wordpress.com/2010/09/01/lu-%E5%88%86%E8%A7%A3/">LU 分解</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/u010945683/article/details/45803141">矩阵分析——LU分解</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2017/03/28/%E7%AE%97%E6%B3%95-%E6%9C%80%E5%A4%A7%E6%B5%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/03/28/%E7%AE%97%E6%B3%95-%E6%9C%80%E5%A4%A7%E6%B5%81/" class="post-title-link" itemprop="url">最大流</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-03-28 19:20:05" itemprop="dateCreated datePublished" datetime="2017-03-28T19:20:05+08:00">2017-03-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:42:06" itemprop="dateModified" datetime="2018-12-17T15:42:06+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最大流问题：给定流网络、源节点、汇点，找到值最大的一个流。</p>
<h1 id="ford-fullkerson方法">Ford-Fullkerson方法</h1>
<p><strong>主要思想</strong>：循环增加流的值。</p>
<h2 id="几个概念">几个概念</h2>
<h3 id="残存网络g_f">残存网络<span class="math inline">\(G_f\)</span></h3>
<p>残存网络简单定义：</p>
<pre><code>残存网络=网络容量Capacity-流量网络flow</code></pre>
<p>残存网络形式化定义：</p>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-28-19-36-03.png" /></p>
<p>说明： 第一项很好理解，就是=网络容量Capacity-流量网络flow</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2017/03/27/ACM-poj1789-TruckHistory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/03/27/ACM-poj1789-TruckHistory/" class="post-title-link" itemprop="url">ACM-poj1789-TruckHistory</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-03-27 15:56:38" itemprop="dateCreated datePublished" datetime="2017-03-27T15:56:38+08:00">2017-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:41:58" itemprop="dateModified" datetime="2018-12-17T15:41:58+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ACM/" itemprop="url" rel="index"><span itemprop="name">ACM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="description">Description</h1>
<p>Advanced Cargo Movement, Ltd. uses trucks of different types. Some trucks are used for vegetable delivery, other for furniture, or for bricks. The company has its own code describing each type of a truck. The code is simply a string of exactly seven lowercase letters (each letter on each position has a very special meaning but that is unimportant for this task). At the beginning of company's history, just a single truck type was used but later other types were derived from it, then from the new types another types were derived, and so on.</p>
<p>Movement:运动 trucks：卡车 exactly seven lowercase letters ：正好七个小写字母 derived：派生</p>
<p>Today, ACM is rich enough to pay historians to study its history. One thing historians tried to find out is so called derivation plan -- i.e. how the truck types were derived. They defined the distance of truck types as the number of positions with different letters in truck type codes. They also assumed that each truck type was derived from exactly one other truck type (except for the first truck type which was not derived from any other type). The quality of a derivation plan was then defined as <code>1/Σ(to,td)d(to,td)</code></p>
<p>quality：质量</p>
<p>where the sum goes over all pairs of types in the derivation plan such that to is the original type and td the type derived from it and d(to,td) is the distance of the types. Since historians failed, you are to write a program to help them. Given the codes of truck types, your program should find the highest possible quality of a derivation plan.</p>
<h1 id="input">Input</h1>
<p>The input consists of several test cases. Each test case begins with a line containing the number of truck types, N, 2 &lt;= N &lt;= 2 000. Each of the following N lines of input contains one truck type code (a string of seven lowercase letters). You may assume that the codes uniquely describe the trucks, i.e., no two of these N lines are the same. The input is terminated with zero at the place of number of truck types.</p>
<h1 id="output">Output</h1>
<p>For each test case, your program should output the text "The highest possible quality is 1/Q.", where 1/Q is the quality of the best derivation plan. Sample Input</p>
<p>4 aaaaaaa baaaaaa abaaaaa aabaaaa 0 # Sample Output</p>
<p>The highest possible quality is 1/3.</p>
<h1 id="解决方案">解决方案</h1>
<p>t:表示卡车的七个字母的字符串 d(t0,td)=t0和td两卡车的字符串不相同的个数</p>
<p>每个卡车都是由另一个卡车派生而来。 现在给出n种不同型号的truck，问怎样使quality的值最小————即找到一条连接所有truck的最短路径</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2017/03/26/%E7%AE%97%E6%B3%95-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/03/26/%E7%AE%97%E6%B3%95-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">算法-最小生成树算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-03-26 20:01:21" itemprop="dateCreated datePublished" datetime="2017-03-26T20:01:21+08:00">2017-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:42:06" itemprop="dateModified" datetime="2018-12-17T15:42:06+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>带权图分为有向和无向，无向图的最短路径又叫做最小生成树，有prime算法和kruskal算法；有向图的最短路径算法有dijkstra算法和floyd算法。</p>
<p>最小生成树问题：给定一个连通无向图，寻找一颗无环树，使得树上所有边权值之和最小。</p>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-26-20-15-02.png" /></p>
<h1 id="最小生成树的贪心策略的通用方法">最小生成树的贪心策略的通用方法</h1>
<h2 id="问题描述">问题描述</h2>
<p><strong>已知</strong>：连通无向图<span class="math inline">\(G=(V,E)\)</span>，权重函数<span class="math inline">\(w:E \rightarrow R\)</span> <strong>循环不变式</strong>：在每边循环之前，A是某颗最小生成树的一个子集。 <strong>伪代码</strong></p>
<pre><code>GENERIC-MST(G,w)
A=&#123;&#125;
while A does not form a spanning tree // 当A不是一个生成树时
    find an edge(u,v) that is safe for A // 找到一条A的安全边
    A = A ∪ &#123;(u,v)&#125;
return A</code></pre>
<p>注：安全边是指加入A后，不会使得A违反循环不变式。即 A ∪ {(u,v)}也是某颗最小生成树的一个子集</p>
<p><strong>问题</strong>：如何寻找安全边</p>
<h2 id="求安全边">求安全边</h2>
<p><strong>定理</strong>：设A是图G的某最小生成树的一个子集。设（S,V-S）是图G中尊重集合A的任意一个切割，又设(u,v)是横跨切割(S,V-S)的一条轻量级边，则边(u,v)对于集合A是安全的。</p>
<p><strong>切割</strong>：图中的线 <strong>切割尊重集合A</strong>：集合A中不存在横跨切割的边（如图a中的灰粗线构成的集合） <strong>轻量级边</strong>：横跨一个切割的所有边中权重最小的边（不唯一）。</p>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-26-21-11-54.png" /></p>
<h1 id="kruskal和prim关系">Kruskal和Prim关系</h1>
<table>
<thead>
<tr class="header">
<th>term</th>
<th style="text-align: right;">集合A</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">共性</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Kruskal</td>
<td style="text-align: right;">森林</td>
<td style="text-align: center;">结点是原图结点，安全边是权重最小的连接两个不同分量的边</td>
<td style="text-align: center;">都是用具体的规则来确定安全边的方法</td>
</tr>
<tr class="even">
<td>Prim</td>
<td style="text-align: right;">树</td>
<td style="text-align: center;">安全边是连接A和A之外某个节点的边中权重最小的边</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<h1 id="kruskal算法">Kruskal算法</h1>
<p><strong>寻找安全边</strong>:在所有连接两个不同树的边里，找到权重最小的边(u,v)</p>
<h2 id="伪代码">伪代码</h2>
<pre><code>MST-KRUSKAL(G,w)
A=&#123;&#125;//A是森林
for each vertex v∈G.V
    MAKE-SET(v)//将集合A初始化为空集，并创建M颗子树，每棵树各含一个结点
sort the edges of G.E into nondecreasing order by weight w //对边按照权重排序
for each edge(u,v)∈G.E,taken in nondecreasing order by weight//按权重顺序遍历边
    if FIND-SET(v)!=FIND-SET(u)//(u,v)不在一棵树
        A= A ∪ &#123;(u,v)&#125;
        UNION(u,v)
return A</code></pre>
<h2 id="时间复杂度">时间复杂度</h2>
<p><span class="math inline">\(O(ElgV)\)</span></p>
<h2 id="特点">特点</h2>
<p>图的存贮结构采用边集数组,且权值相等的边在数组中排列次序可以是任意的.该方法对于边相对比较多的不是很实用,浪费时间.</p>
<p>c++实现（写的很好，一定要看）:<a target="_blank" rel="noopener" href="http://blog.csdn.net/niushuai666/article/details/6689285">Kruskal算法</a></p>
<h1 id="prim算法">Prim算法</h1>
<p><strong>寻找安全边</strong>:A总是一颗树。从单一顶点开始，逐步扩大树中所含顶点的数目，直到遍及连通图的所有顶点。</p>
<p>为了快速选择新边， 在算法执行的过程中，所有不在树A中的结点都存放在一个基于key属性的<code>最小优先队列Q</code>中。</p>
<p><code>u.key</code> : 连接结点u和<strong>树</strong>中结点的所有边中最小边的权重。 <code>u.π</code>：u在<strong>树</strong>中的父节点</p>
<h2 id="描述">描述</h2>
<p><strong>输入</strong>:连通图G,边权w,最小生成树的根节点r</p>
<p><strong>初始化</strong>：Vnew = {x}，其中x为集合V中的任一节点（起始点），Enew = {}</p>
<p><strong>循环</strong>：重复以下操作，直到<span class="math inline">\(V_{new}=V\)</span>：</p>
<ol type="1">
<li>在集合E中选取权值最小的边（u,v），其中u是集合Vnew中的元素，而v则是V中没有加入Vnew的顶点；</li>
<li>将v加入Vnew中，将(u,v)加入Enew中；</li>
</ol>
<p><strong>输出</strong>：使用集合Vnew和Enew来描述所得到的最小生成树。</p>
<p>图例：</p>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-27-15-47-24.png" /></p>
<h2 id="伪代码-1">伪代码</h2>
<pre><code>MST-PRIM(G,w,r)//r是最小生成树的根节点
for each u∈G.V
    u.key=∞ 
    u.π=NIL //u在树中的父节点
r.key=0
Q=G.V
while Q!=&#123;&#125;
    u=EXTRACT-MIN(Q)//某条横跨切割(V-Q,Q)的一个轻量级边的端点
    for each v∈G.Adj[u]//遍历u的邻接表
    if v∈Q and w(u,v)&lt;v.key
        v.π=u
        v.key=w(u,v)</code></pre>
<h2 id="时间复杂度-1">时间复杂度</h2>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-27-15-51-25.png" /></p>
<p>通过邻接矩阵图表示的简易实现中，找到所有最小权边共需O（V2）的运行时间。使用简单的二叉堆与邻接表来表示的话，普里姆算法的运行时间则可缩减为O(E log V)，其中E为连通图的边数，V为顶点数。如果使用较为复杂的斐波那契堆，则可将运行时间进一步缩短为O(E + V log V)，这在连通图足够密集时（当E满足Ω（V log V）条件时），可较显著地提高运行速度</p>
<h1 id="参考文献">参考文献</h1>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%99%AE%E6%9E%97%E5%A7%86%E7%AE%97%E6%B3%95">维基百科</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2017/03/23/ACM-poj1860-CurrencyExchange/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/03/23/ACM-poj1860-CurrencyExchange/" class="post-title-link" itemprop="url">ACM-poj1860-CurrencyExchange</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-03-23 22:40:15" itemprop="dateCreated datePublished" datetime="2017-03-23T22:40:15+08:00">2017-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:41:58" itemprop="dateModified" datetime="2018-12-17T15:41:58+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ACM/" itemprop="url" rel="index"><span itemprop="name">ACM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="description">Description</h1>
<p>Several currency exchange points are working in our city. Let us suppose that each point specializes in two particular currencies and performs exchange operations only with these currencies. There can be several points specializing in the same pair of currencies. Each point has its own exchange rates, exchange rate of A to B is the quantity of B you get for 1A. Also each exchange point has some commission, the sum you have to pay for your exchange operation. Commission is always collected in source currency. For example, if you want to exchange 100 US Dollars into Russian Rubles at the exchange point, where the exchange rate is 29.75, and the commission is 0.39 you will get (100 - 0.39) * 29.75 = 2963.3975RUR. You surely know that there are N different currencies you can deal with in our city. Let us assign unique integer number from 1 to N to each currency. Then each exchange point can be described with 6 numbers: integer A and B - numbers of currencies it exchanges, and real RAB, CAB, RBA and CBA - exchange rates and commissions when exchanging A to B and B to A respectively. Nick has some money in currency S and wonders if he can somehow, after some exchange operations, increase his capital. Of course, he wants to have his money in currency S in the end. Help him to answer this difficult question. Nick must always have non-negative sum of money while making his operations.</p>
<p>currency exchange points：货币兑换点 commission：佣金 assign ：分配</p>
<p>每个货币兑换点只能互换两种货币。兑换点可重复。每个点都有自己的兑换率，A to B 的兑换率是指1个A能兑换的B的数量。</p>
<p>兑换时收取一定的佣金，佣金是以来源货币来collect的。例如，如果你想将100dolars兑换成Russian Bules, 兑换点的兑换率是29.75，费用是0.39，，那么你会得到的钱是 (100 - 0.39) * 29.75 = 2963.3975RUR.</p>
<p>假设每种兑换的点数量是1-N，那么每个兑换点可以由6个num来描述：</p>
<p>interger A and B 兑换货币的序号 RAB A to B兑换率 CAB A to B 的佣金 RBA B to A 兑换率 CBA B to A 的佣金</p>
<p>Nick有些S货币，他很好奇他能否通过货币兑换的方式对他的资金进行增值。最终他希望他拿到还是S货币。帮他解决这个问题。Nick在这个过程中不能借钱。</p>
<h1 id="input">Input</h1>
<p>The first line of the input contains four numbers: N - the number of currencies, M - the number of exchange points, S - the number of currency Nick has and V - the quantity of currency units he has.</p>
<p>The following M lines contain 6 numbers each - the description of the corresponding exchange point - in specified above order. Numbers are separated by one or more spaces.</p>
<p>1&lt;=S&lt;=N&lt;=100, 1&lt;=M&lt;=100, V is real number, 0&lt;=V&lt;=103.</p>
<p>For each point exchange rates and commissions are real, given with at most two digits after the decimal point, 10-2&lt;=rate&lt;=102, 0&lt;=commission&lt;=102.</p>
<p>Let us call some sequence of the exchange operations simple if no exchange point is used more than once in this sequence. You may assume that ratio of the numeric values of the sums at the end and at the beginning of any simple sequence of the exchange operations will be less than 104.</p>
<p>corresponding：相应的</p>
<p>第一行包含四个数字： N 货币的种类 M 兑换点的数量 S Nick的货币的序号 V Nick拥有的钱</p>
<p>接下来的M行，每行包含六个数字，描述相应的兑换点的属性。 数字由一个或多个空格隔开</p>
<p>1&lt;=S&lt;=N&lt;=100, 1&lt;=M&lt;=100, V is real number, 0&lt;=V&lt;=103.</p>
<p>每个兑换点的兑换率和手续费都是实数，至多精确到两位小数。</p>
<p>10-2&lt;=rate&lt;=102, 0&lt;=commission&lt;=102</p>
<p>如果在操作序列中不适用多个兑换点，我们可以发起一些简单的兑换操作。你可以假设：（最后的总和/）</p>
<h1 id="输出数据">输出数据</h1>
<p>如果nick能够实现他的愿望，则输出YES，否则输出NO。</p>
<h1 id="样例输入">样例输入</h1>
<p>3 2 1 20.0 1 2 1.00 1.00 1.00 1.00 2 3 1.10 1.00 1.10 1.00</p>
<h1 id="思路">思路</h1>
<p>将货币看做点，每种兑换规则为边，两点的路径长度为兑换后的钱数。建图之后可以看出题意为求图中是否存在正环，用Bellman-Ford求最长路径，如果存在正环输出YES，不存在输出NO。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2017/03/23/%E7%AE%97%E6%B3%95-%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/03/23/%E7%AE%97%E6%B3%95-%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">算法-单源最短路径问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-03-23 16:02:59" itemprop="dateCreated datePublished" datetime="2017-03-23T16:02:59+08:00">2017-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:42:04" itemprop="dateModified" datetime="2018-12-17T15:42:04+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>单源最短路径问题：给定一个图 <span class="math inline">\(G=(V,E)\)</span> ，我们希望找到从给定源节点<span class="math inline">\(s\in V\)</span>到每个节点<span class="math inline">\(v \in V\)</span>的最短路径。</p>
<p>先总结：</p>
<p>Bellman-Ford算法：采用动态规划进行设计。<strong>待总结</strong>。简单，还能侦探含源节点的负权重回路。 Dijkstra算法：采用贪心算法范式进行设计。复杂度低，但要求权重非负。</p>
<h1 id="最短路径树">最短路径树</h1>
<p>一颗根节点为s的最短路径树是一个有向子图<span class="math inline">\(G&#39;=(V&#39;,E&#39;)\)</span>，这里<span class="math inline">\(V&#39;\in V\)</span>,<span class="math inline">\(E&#39;\in E\)</span>,满足： 1. <span class="math inline">\(V&#39;\)</span>是图G中从源节点s可以到达的所有结点的集合； 2. <span class="math inline">\(G&#39;\)</span>形成一颗根节点为s的树； 3. 对于所有结点<span class="math inline">\(v\in V&#39;\)</span>,图<span class="math inline">\(G&#39;\)</span>中从结点s到结点v的唯一简单路径是图G中从结点s到结点v的一条最短路径。</p>
<h1 id="松弛操作">松弛操作</h1>
<p>对每个节点v，我们维持一个属性v.d，记录s→v的最短路径估计</p>
<p>松弛操作：比较s→u→v与s→v的d,然后进行更新。</p>
<pre><code>RELEAX(u,v,w)
    if v.d&gt;u.d+w(u,v)
        v.d=u.d+w(u,v)
        v.π=u</code></pre>
<h1 id="bellman-ford算法">Bellman-Ford算法</h1>
<p><strong>目标</strong>：解决单源最短路径问题 <strong>条件</strong>：边权重可负 <strong>输入</strong>：带权有向图<span class="math inline">\(G=(V,E)\)</span>和权重函数<span class="math inline">\(w:E→R\)</span> <strong>输出</strong>：布尔值，是否存在一个从源节点可以到达的负权重回路。若存在，则算法无解。</p>
<p><strong>思路</strong>：Bellman-Ford通过对边进行松弛操作来渐进地降低从源节点s到每个节点v的最短路径估计值v.d，直到该估计值与实际的最短路径权重<span class="math inline">\(δ(s,v)\)</span>相同为止。</p>
<p>初始函数：</p>
<pre><code>INITIALIZE-SINGLE-SOURCE(G,s)
    for eahc vertex v∈G.V
        v.d=∞
        v.π=null
    s.d=0</code></pre>
<p><strong>算法</strong>：</p>
<pre><code>BELLMAN-FORD(G,w,s)
    INITIALIZE-SINGLE-SOURCE(G,s)//对每个点v.d和v.π初始化
    for i=1 to |G.V|-1 //对每个边处理V-1次
        for each edge(u,v)∈G.E //遍历所有的边
            RELAX(u,v,w)
    for each edge(u,v)∈G.E
        if v.d&gt;u.d+w(u,v)
            return False
        else
            return True</code></pre>
<p><strong>复杂度</strong>：<span class="math inline">\(O(VE)\)</span></p>
<p><strong>对每个边处理V-1的原因</strong>：设p是从s到v的最短路径，则p最多包含V-1条边。</p>
<p>如下图所示的极限条件，v0-v5路径应该为<code>&lt;v0,v1,v2,v3,v4,v5&gt;</code></p>
<p>原本v0-v5的路径是灰色的。 第一轮松弛后，v0-v5路径变为<code>&lt;v0,v1,v5&gt;</code>，即黑色的 同理，第二轮松弛后，v0-v5路径变为<code>&lt;v0,v1,v2,v5&gt;</code> 因此要松弛V-1次才可以 <img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-23-17-07-49.png" /></p>
<h1 id="dijkstra算法">Dijkstra算法</h1>
<p><strong>条件</strong>：所有边的权重非负 <strong>思想</strong>：由上述性质可知，如果存在一条从i到j的最短路径(Vi.....Vk,Vj)，Vk是Vj前面的一顶点。那么(Vi...Vk)也必定是从i到k的最短路径。为了求出最短路径，Dijkstra就提出了以最短路径长度递增，逐次生成最短路径的算法。即：每次找到离源点最近的一个顶点，然后以该顶点为中心进行扩展，最终得到源点到其余所有点的最短路径。</p>
<p><strong>Dijkstra算法的关键</strong>：维持一组节点集合S，从s到该集合中的每个节点的最短路径已经被找到。算法重复从V-S中选择最短路径估计最小的节点u，将u加入结合S，然后对所有从u出发的边进行松弛。</p>
<pre><code>DIJKSTRA(G,w,s)
    INITIALIZE-SINGLE-SOURCE(G,s)//对v.d和v.π初始化
    S=&#123;&#125;
    Q=G.V
    while Q.length != 0
        u = UXTRACT-MIN(Q)//从V-S中选出最短路径估计最小的节点u
        S=S∪&#123;u&#125;
        for each vertex v∈G.Adj[u]
            RELAX(u,v,w)</code></pre>
<p><strong>算法解释</strong> 二维数组 e 来存储顶点之间边的关系，初始值如下： <img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-23-22-23-08.png" /></p>
<p>我们还需要用一个一维数组 dis 来存储 1 号顶点到其余各个顶点的初始路程，如下。 我们将此时 dis 数组中的值称为最短路的“估计值” <img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-23-22-23-38.png" /></p>
<p>图的关系如图所示，1是源点<img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-23-22-22-41.png" /></p>
<p>既然是求 1 号顶点到其余各个顶点的最短路程，那就先找一个离 1 号顶点最近的顶点。通过数组 dis 可知当前离 1 号顶点最近是 2 号顶点。当选择了 2 号顶点后，dis[2]的值就已经从“估计值”变为了“确定值”，即 1 号顶点到 2 号顶点的最短路程就是当前 dis[2]值。 原因：目前离 1 号顶点最近的是 2 号顶点，并且这个图所有的边都是正数，那么肯定不可能通过第三个顶点中转，使得 1 号顶点到 2 号顶点的路程进一步缩短了。因为 1 号顶点到其它顶点的路程肯定没有 1 号到 2 号顶点短，</p>
<p>既然选了 2 号顶点，接下来再来看 2 号顶点有哪些出边呢。有 2-&gt;3 和 2-&gt;4 这两条边。先讨论通过 2-&gt;3 这条边能否让 1 号顶点到 3 号顶点的路程变短。也就是说现在来比较 dis[3]和 dis[2]+e[2][3]的大小。其中 dis[3]表示 1 号顶点到 3 号顶点的路程。dis[2]+e[2][3]中 dis[2]表示 1 号顶点到 2 号顶点的路程，e[2][3]表示 2-&gt;3 这条边。所以 dis[2]+e[2][3]就表示从 1 号顶点先到 2 号顶点，再通过 2-&gt;3 这条边，到达 3 号顶点的路程。</p>
<p>我们发现 dis[3]=12，dis[2]+e[2][3]=1+9=10，dis[3]&gt;dis[2]+e[2][3]，因此 dis[3]要更新为 10。这个过程有个专业术语叫做“松弛”。即 1 号顶点到 3 号顶点的路程即 dis[3]，通过 2-&gt;3 这条边松弛成功。这便是 Dijkstra 算法的主要思想：通过“边”来松弛 1 号顶点到其余各个顶点的路程。</p>
<p>同理通过 2-&gt;4（e[2][4]），可以将 dis[4]的值从 ∞ 松弛为 4（dis[4]初始为 ∞，dis[2]+e[2][4]=1+3=4，dis[4]&gt;dis[2]+e[2][4]，因此 dis[4]要更新为 4）。</p>
<p>刚才我们对 2 号顶点所有的出边进行了松弛。松弛完毕之后 dis 数组为： <img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-23-22-31-33.png" /></p>
<p>以此类推，此处不再多加阐述。</p>
<p>参考文献<a target="_blank" rel="noopener" href="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/dijkstra.html">算法 7：Dijkstra 最短路算法</a></p>
<h1 id="有向无环图的单源最短路径问题">有向无环图的单源最短路径问题</h1>
<p>来日再填坑。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2017/03/22/ACM-Radar-Installation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/03/22/ACM-Radar-Installation/" class="post-title-link" itemprop="url">ACM--Radar Installation</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-03-22 19:30:08" itemprop="dateCreated datePublished" datetime="2017-03-22T19:30:08+08:00">2017-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:41:58" itemprop="dateModified" datetime="2018-12-17T15:41:58+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ACM/" itemprop="url" rel="index"><span itemprop="name">ACM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="题目描述">题目描述</h1>
<p>Assume the coasting is an infinite straight line. Land is in one side of coasting, sea in the other. Each small island is a point locating in the sea side. And any radar installation, locating on the coasting, can only cover d distance, so an island in the sea can be covered by a radius installation, if the distance between them is at most d.</p>
<p>We use Cartesian coordinate system, defining the coasting is the x-axis. The sea side is above x-axis, and the land side below. Given the position of each island in the sea, and given the distance of the coverage of the radar installation, your task is to write a program to find the minimal number of radar installations to cover all the islands. Note that the position of an island is represented by its x-y coordinates.</p>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-22-19-32-14.png" /></p>
<p>coasting：滑行 infinite：无穷的 Cartesian coordinate system：笛卡尔坐标系</p>
<p>已知：海岸线是x轴，以上是海，以下是陆地。雷达安装在海岸线上，覆盖半径是d。 目标：求能够覆盖所有岛屿的雷达安装数目。 需需要注意的是，海岛坐标在x-y坐标系中。</p>
<h1 id="input">Input</h1>
<p>The input consists of several test cases. The first line of each case contains two integers n (1&lt;=n&lt;=1000) and d, where n is the number of islands in the sea and d is the distance of coverage of the radar installation. This is followed by n lines each containing two integers representing the coordinate of the position of each island. Then a blank line follows to separate the cases.</p>
<p>The input is terminated by a line containing pair of zeros</p>
<p>输入一般包含好几组case测试数据。</p>
<p>每个case的第一行是(n,d) 然后是n行岛屿坐标</p>
<p>最后以（0,0）结尾</p>
<h1 id="output">Output</h1>
<p>For each test case output one line consisting of the test case number followed by the minimal number of radar installations needed. "-1" installation means no solution for that case.</p>
<h1 id="思路">思路</h1>
<p>这道题问的是怎样放雷达使其放的雷达数目最少而能够探测到所有的岛屿，这里需要转换为求每个岛屿的能放雷达的区间的问题:</p>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-03-22-21-06-38.png" /></p>
<p>抽象问题:每个小岛都对应一个区域,这个区域内的雷达都能探测到这个小岛,把这N个区域求出来,问题现在就变成了,最少放置几个点,能使得每个区域内都至少有一个点.</p>
<p>这道题目的关键之处就是把面的问题转换成线的问题，每一个座海岛在x轴上有一个区间，在这个区间里面的雷达都可以侦测到海岛，区间的范围即是[x-sqrt(dd – yy), x+sqrt(dd+yy)]，然后先以右端点为基进行从小到大排序，然后把第一个雷达默认放在最左端的xmax，接下来的点只要是xmin小于当前xmax就可以不用增加雷达，如果xmax == xmin的话也不用增加雷达。然后如果xmax &lt; xmin的话就加一个雷达，然后以xmin所属区间的xmax为基进行比较。</p>
<h1 id="代码">代码</h1>
<pre><code>import java.io.PrintWriter;

import java.util.Arrays;
import java.util.Scanner;
public class Main &#123;
    static class Range implements Comparable&lt;Range&gt;&#123;
        double left,right;
        public Range(double left,double right)&#123;
            this.left = left;

            this.right = right;
        &#125;
        @Override

        public int compareTo(Range range) &#123;
            if(range.left == left)&#123;
                return ((Double)right).compareTo((Double)(range.right));
            &#125;else&#123;
                return ((Double)left).compareTo((Double)(range.left));
            &#125;
        &#125;

        @Override
        public String toString() &#123;
            return &quot;(&quot; + left + &quot;,&quot; + right + &quot;)&quot;;
        &#125;

    &#125;


    public static void main(String[] args) &#123;
        Scanner scn = new Scanner(System.in);

        PrintWriter out = new PrintWriter(System.out);
        int n ,d,x,y,num;
        double dx;
        Range[] ranges;
        int index = 0;
        while(true)&#123;
            num = 0;
            n = scn.nextInt();
            d = scn.nextInt();
            if(n == 0)&#123;
                break;
            &#125;
            ranges = new Range[n];
            for(int i = 0; i &lt; n; i++)&#123;
                x = scn.nextInt();
                y = scn.nextInt();
                if(y &gt; d)&#123;
                    num = -1;
                &#125;
                dx = Math.sqrt(d*d - y*y);
                ranges[i] = new Range(x - dx, x + dx);
            &#125;
            Arrays.sort(ranges);//���
            if(num != -1)&#123;
                num = calute(ranges);
            &#125;
            out.format(&quot;Case %d: %d\n&quot;,++index,num);
        &#125;
        out.flush();
            
    &#125;
    
    private static int calute(Range[] ranges) &#123;
        int num = 1;
        int n = ranges.length;
        Range preRange = ranges[0],range;
        for(int i = 1; i &lt; n; i++)&#123;
            range = ranges[i];
            if(range.left &gt;= preRange.left &amp;&amp; range.left &lt;= preRange.right)&#123;
                preRange.left = range.left;
                if(range.right &lt; preRange.right)&#123;
                    preRange.right = range.right;
                &#125;
            &#125;else&#123;
                num++;
                preRange = range;
            &#125;
        &#125;
        return num;
    &#125;
&#125;</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2017/03/21/Python-numpy%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/03/21/Python-numpy%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">numpy笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-03-21 22:05:07" itemprop="dateCreated datePublished" datetime="2017-03-21T22:05:07+08:00">2017-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:42:00" itemprop="dateModified" datetime="2018-12-17T15:42:00+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="numpy结构数组">numpy结构数组</h1>
<p>在c语言中，我们可以使用关键字struct定义结构类型。和c语言一样，numpy也可以创建结构定义，这样可以很方便的读取二进制的C语言结构数组，将其转换为numpy数组对象，假设我们定义的结构数组如下(C语言描述)：</p>
<pre><code>struct Person&#123;
     char name[30];
     int    age;
     float weight; 
&#125;;</code></pre>
<p>我们在python中可以自定义类型如下：</p>
<pre><code>persontype = np.dtype(&#123;
&#39;names&#39;:[&#39;name&#39;,&#39;age&#39;,&#39;weight&#39;],
&#39;formats&#39;:[&#39;S30&#39;,&#39;i&#39;,&#39;f&#39;]&#125;,align = True)</code></pre>
<p>参考文献<a target="_blank" rel="noopener" href="http://www.cnblogs.com/td15980891505/p/6083083.html">numpy中结构数组</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">jiayi797</p>
  <div class="site-description" itemprop="description">.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">150</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jiayi797</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
    <span class="post-count">| 博客共334.5k字</span>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
