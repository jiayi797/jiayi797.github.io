<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
<!-- Referrer Policy调整致不蒜子单页面统计出错:https://senorui.top/posts/c33f.html -->
<meta name="referrer" content="no-referrer-when-downgrade">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jiayi797.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content=".">
<meta property="og:type" content="website">
<meta property="og:title" content="甲乙小朋友的房子">
<meta property="og:url" content="http://jiayi797.github.io/about/page/11/index.html">
<meta property="og:site_name" content="甲乙小朋友的房子">
<meta property="og:description" content=".">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="jiayi797">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://jiayi797.github.io/about/page/11/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>甲乙小朋友的房子</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">甲乙小朋友的房子</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">甲乙小朋友很笨，但甲乙小朋友不会放弃</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2017/05/21/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%AF%94%E8%B5%9B-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/05/21/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%AF%94%E8%B5%9B-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">内存映射文件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-05-21 14:55:49" itemprop="dateCreated datePublished" datetime="2017-05-21T14:55:49+08:00">2017-05-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:42:07" itemprop="dateModified" datetime="2018-12-17T15:42:07+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%AF%94%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">中间件比赛</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>内存映射文件：利用虚拟内存实现将文件“映射”到内存中。文件对应于内存中的一个字节数组，对文件的操作变为对这个字节数组的操作，而字节数组的操作直接映射到文件上。这样这个文件就可以当做是一个内存数组一样的访问，这比传统的文件操作要快得多。</p>
<p>映射：<strong>硬盘上文件</strong>的位置与进程<strong>逻辑地址空间</strong>中一块大小相同的区域之间的一一对应</p>
<p>不过，这种映射是操作系统提供的一种假象，文件一般不会马上加载到内存，操作系统只是记录下了这回事，当实际发生读写时，才会按需加载。</p>
<p>这种按需加载的方式，使得内存映射文件可以方便处理非常大的文件，内存放不下整个文件也不要紧，操作系统会自动进行处理，将需要的内容读到内存，将修改的内容保存到硬盘，将不再使用的内存释放。</p>
<p>内存映射文件也有局限性，比如，它不太适合处理小文件，它是按页分配内存的，对于小文件，会浪费空间，另外，映射文件要消耗一定的操作系统资源，初始化比较慢。</p>
<h1 id="java使用内存映射">java使用内存映射</h1>
<h2 id="步骤">步骤</h2>
<ul>
<li><p>引入java.nio包</p></li>
<li><p>从文件中获得一个通道(channel)。</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileChannel channel = FileChanne.open(path,options)</span><br></pre></td></tr></table></figure></p></li>
<li><p>通过调用FileChannel类的map方法从这个通道中获得一个ByteBuffer,它代表内存中的字节数组。其中，映射文件区域与映射模式支持三种方式： -- FileChannel.MapMode.READ_ONLY:缓冲区只读 -- FileChannel.MapMode.READ_WRITE：可读写。任何缓冲区的修改都会写回文件（非立即） -- FileChannel.MapMode.PRIVATE：缓冲区可写，但修改不会传播到文件中</p></li>
</ul>
<p>映射完成后，文件就可以关闭了，后续对文件的读写可以通过MappedByteBuffer。</p>
<p>例：以读写模式映射文件"abc.dat"，代码可以为：</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;abc.dat&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    MappedByteBuffer buf = file.getChannel().map(MapMode.READ_WRITE, <span class="number">0</span>, file.length());</span><br><span class="line">    <span class="comment">//使用buf...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    file.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<p>##　</p>
<h1 id="参考文献">参考文献</h1>
<p>1.<a target="_blank" rel="noopener" href="https://juejin.im/post/58626ac361ff4b006cf14faf">计算机程序的思维逻辑 (61) - 内存映射文件及其应用 - 实现一个简单的消息队列</a> 2.<a target="_blank" rel="noopener" href="http://blog.csdn.net/king_is_everyone/article/details/28096583">java流的性能优化2-内存映射文件</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2017/05/19/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%AF%94%E8%B5%9B-OpenMessaging%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB2-demo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/05/19/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%AF%94%E8%B5%9B-OpenMessaging%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB2-demo/" class="post-title-link" itemprop="url">OpenMessaging源码阅读2-demo</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-05-19 16:32:48" itemprop="dateCreated datePublished" datetime="2017-05-19T16:32:48+08:00">2017-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:42:07" itemprop="dateModified" datetime="2018-12-17T15:42:07+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%AF%94%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">中间件比赛</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="producer操作">producer操作</h1>
<p>tips:以下涉及到的代码是关键步骤代码。</p>
<ol type="1">
<li><p>====================构造n个<strong>Topic</strong>和n个<strong>Queue</strong>====================</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String topic1 = <span class="string">&quot;TOPIC1&quot;</span>; <span class="comment">//实际测试时大概会有100个Topic左右</span></span><br><span class="line">String queue2 = <span class="string">&quot;QUEUE2&quot;</span>; <span class="comment">//实际测试时，queue数目与消费线程数目相同</span></span><br><span class="line">List&lt;Message&gt; messagesForTopic1 = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1024</span>);</span><br><span class="line">List&lt;Message&gt; messagesForQueue1 = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure></p></li>
<li><p>====================向Topic和Queue中<strong>create</strong>数据====================</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">messagesForTopic1.add(producer.createBytesMessageToTopic(topic1,  (topic1 + i).getBytes()));</span><br></pre></td></tr></table></figure></p></li>
</ol>
<ul>
<li>调用<code>producer</code>的<code>producer.createBytesMessageToTopic()</code>方法来创建<code>BytesMessage</code></li>
<li>将上一步产生的标准消息扔进messagesForTopic1中，即调用了每个<code>messagesForTopic1.add()</code>来向这个<code>Topic</code>中添加消息</li>
</ul>
<p>需要注意的是： - messageFactory,而createBytesMessageToTopic()正是通过messageFactory.createBytesMessageToTopic(topic, body);来创建消息； - messageFactory.createBytesMessageToTopic(topic, body);仅仅只是将消息的body和header放入了一个defaultBytesMessage类型的消息中，并返回 - 每个producer对应一个messageStore <strong>总结：这一步将producer产生的数据放入消息列表messagesForTopic/Queue中</strong></p>
<p>3.====================<strong>send</strong>数据====================</p>
<p>方式：</p>
<pre><code>producer.send(messagesForTopic1.get(i));</code></pre>
<p>然后<code>send()</code>内部是：</p>
<pre><code>String topic = message.headers().getString(MessageHeader.TOPIC);
messageStore.putMessage(topic或queue, message);</code></pre>
<p>需要注意的是：</p>
<ul>
<li>每个producer有一个messageStore，通过调用它的putMessage()来进行发送消息（将消息存储在硬盘中）</li>
<li>MessageStore类有一个成员变量<code>Map &lt;String, ArrayList&lt;Message&gt;&gt; messageBuckets</code>用来装消息，其中键是topic或queue的名字，值是new ArrayList&lt;&gt;(1024)(这里有一点疑问？)</li>
</ul>
<p>而putMessage：</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">putMessage</span><span class="params">(String bucket, Message message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!messageBuckets.containsKey(bucket)) &#123;</span><br><span class="line">        messageBuckets.put(bucket, <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1024</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Message&gt; bucketList = messageBuckets.get(bucket);</span><br><span class="line">    bucketList.add(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<ul>
<li>如果本messageStore的messageBuckets没有本bucket(Topic或Queue)，则将这个buket加入到messageBuckets中,并使得其键值为new ArrayList&lt;&gt;(1024)</li>
<li>从本messageBuckets拿出(get)本bucket，放入消息列表bucketList中</li>
<li>再将本message加入消息列表bucketList</li>
</ul>
<p><strong>总结：将Topic或Queue放入MessageStore的messageBuckets中，将消息体放入bMessageStore的ucketList中</strong></p>
<h1 id="consumer操作">consumer操作</h1>
<ol type="1">
<li>====================进行消息订阅<strong>attach</strong>====================</li>
</ol>
<p>操作：</p>
<pre><code>consumer1.attachQueue(queue1, Collections.singletonList(topic1));</code></pre>
<p>备注： - singletonList(T) 方法用于返回一个只包含指定对象的不可变列表</p>
<p>然后DefaultPullConsumer的attachQueue如下：</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">attachQueue</span><span class="params">(String queueName, Collection&lt;String&gt; topics)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (queue != <span class="keyword">null</span> &amp;&amp; !queue.equals(queueName)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClientOMSException(<span class="string">&quot;You have alreadly attached to a queue &quot;</span> + queue);</span><br><span class="line">    &#125;</span><br><span class="line">    queue = queueName;</span><br><span class="line">    buckets.add(queueName);</span><br><span class="line">    buckets.addAll(topics);</span><br><span class="line">    bucketList.clear();</span><br><span class="line">    bucketList.addAll(buckets);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<ul>
<li>buckets是DefaultPullConsumer的一个成员变量：private Set<String> buckets = new HashSet&lt;&gt;();</li>
<li>bucketList是DefaultPullConsumer的一个成员变量：private List<String> bucketList = new ArrayList&lt;&gt;();</li>
<li>将本queue以及其下的所有topic都加入到buckets中</li>
<li>将bukets都加入到bucketList中</li>
</ul>
<p>2.====================进行消息拉取<strong>pull</strong>====================</p>
<p>操作：</p>
<p>Message message = consumer1.poll();</p>
<p>其中，poll为：</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Message <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (buckets.size() == <span class="number">0</span> || queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//use Round Robin</span></span><br><span class="line">    <span class="keyword">int</span> checkNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (++checkNum &lt;= bucketList.size()) &#123;</span><br><span class="line">        String bucket = bucketList.get((++lastIndex) % (bucketList.size()));</span><br><span class="line">        Message message = messageStore.pullMessage(queue, bucket);</span><br><span class="line">        <span class="keyword">if</span> (message != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<ul>
<li>遍历每个bucketList（bucketList装的是本consumer订阅的topics以及对应的queue）</li>
<li>对遍历到的每个bucket，从messageStore拉取消息</li>
</ul>
<p>而 messageStore.pullMessage为：</p>
<pre><code>```Java
public synchronized Message pullMessage(String queue, String bucket) &#123;
    ArrayList&lt;Message&gt; bucketList = messageBuckets.get(bucket);
    if (bucketList == null) &#123;
        return null;
    &#125;
    HashMap&lt;String, Integer&gt; offsetMap = queueOffsets.get(queue);
    if (offsetMap == null) &#123;
        offsetMap = new HashMap&lt;&gt;();
        queueOffsets.put(queue, offsetMap);
    &#125;
    int offset = offsetMap.getOrDefault(bucket, 0);
    if (offset &gt;= bucketList.size()) &#123;
        return null;
    &#125;
    Message message = bucketList.get(offset);
    offsetMap.put(bucket, ++offset);
    return message;
&#125;```</code></pre>
<ul>
<li>先从messageStore的messageBuckets中get到本bucket的bucketList</li>
<li>将这个consumer绑定的queue放入本messageStore的queueOffsets中</li>
<li>然后我就有点疑惑了？？</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2017/05/17/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%AF%94%E8%B5%9B-RocketMQ%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/05/17/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%AF%94%E8%B5%9B-RocketMQ%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">RocketMQ简介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-05-17 10:49:03" itemprop="dateCreated datePublished" datetime="2017-05-17T10:49:03+08:00">2017-05-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:42:07" itemprop="dateModified" datetime="2018-12-17T15:42:07+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%AF%94%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">中间件比赛</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>RocketMQ:分布式开放消息系统</p>
<h1 id="消息中间件需要解决哪些问题">消息中间件需要解决哪些问题？</h1>
<h2 id="发布订阅publishsubscribe">发布订阅（Publish/Subscribe）</h2>
<p>发布订阅是消息中间件的最基本功能，也是相对于传统RPC通信而言。在此不再详述。</p>
<h2 id="消息优先级message-priority">消息优先级（Message Priority）</h2>
<p>两种方式：</p>
<ol type="1">
<li>严格优先级，例如0-65535。开销大，精准，但可能没有必要。</li>
<li>档位优先级。高、中、低，或其他。每个优先级可以用不同的topic表示，发消息时，指定不同的topic来表示优先级。精确性低。</li>
</ol>
<h2 id="消息有序性message-order">消息有序性（Message Order）</h2>
<ol type="1">
<li>一个订单的发出的消息顺序不能变</li>
<li>订单之间是可以并行消费</li>
</ol>
<h2 id="消息过滤message-filter">消息过滤（Message Filter）</h2>
<h3 id="消息协商器broker端消息过滤">消息协商器（Broker端）消息过滤</h3>
<p>在Broker中，按照Consumer的要求做过滤 1. 优点是减少了对于Consumer无用消息的网络传输。 2. 缺点是增加了Broker的负担，实现相对复杂。</p>
<p>淘宝Notify支持多种过滤方式： 包含直接按照消息类型过滤，灵活的语法表达式过滤，几乎可以满足最苛刻的过滤需求。</p>
<p>淘宝RocketMQ支持按照简单的Message Tag过滤，也支持按照Message Header、body进行过滤。</p>
<p>CORBA Notification规范中也支持灵活的语法表达式过滤。</p>
<h3 id="consumer端消息过滤">Consumer端消息过滤</h3>
<p>这种过滤方式可由应用完全自定义实现，但是缺点是很多无用的消息要传输到Consumer端。</p>
<h3 id="消息持久化message-persistence">消息持久化（Message Persistence）</h3>
<p>持久化（Persistence）：即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。</p>
<p>消息中间件通常采用的几种持久化方式：</p>
<ol type="1">
<li>持久化到数据库，例如Mysql。</li>
<li>持久化到KV存储，例如levelDB、伯克利DB等KV存储系统。</li>
<li>文件记录形式持久化，例如Kafka，RocketMQ</li>
<li>对内存数据做一个持久化镜像，例如beanstalkd，VisiNotify</li>
<li>(1)、(2)、(3)三种持久化方式都具有将内存队列Buffer进行扩展的能力，(4)只是一个内存的镜像，作用是当Broker挂掉重启后仍然能将之前内存的数据恢复出来。</li>
</ol>
<p>JMS与CORBA Notification规范没有明确说明如何持久化，但是持久化部分的性能直接决定了整个消息中间件的性能。</p>
<p>RocketMQ充分利用Linux文件系统内存cache来提高性能。</p>
<h3 id="消息可靠性message-reliablity">消息可靠性（Message Reliablity）</h3>
<p>响消息可靠性的几种情况：</p>
<ol type="1">
<li>Broker正常关闭</li>
<li>Broker异常Crash</li>
<li>OS Crash</li>
<li>机器掉电，但是能立即恢复供电情况。</li>
<li>机器无法开机（可能是cpu、主板、内存等关键设备损坏）</li>
<li>磁盘设备损坏</li>
</ol>
<p>(1)、(2)、(3)、(4)四种情况都属于硬件资源可立即恢复情况，RocketMQ在这四种情况下能保证消息不丢，或者丢失少量数据（依赖刷盘方式是同步还是异步）。</p>
<p>(5)、(6)属于单点故障，且无法恢复，一旦发生，在此单点上的消息全部丢失。RocketMQ在这两种情况下，通过异步复制，可保证99%的消息不丢，但是仍然会有极少量的消息可能丢失。通过同步双写技术可以完全避免单点，同步双写势必会影响性能，适合对消息可靠性要求极高的场合，例如与Money相关的应用。</p>
<p>RocketMQ从3.0版本开始支持同步双写。</p>
<h1 id="参考文献">参考文献</h1>
<ol type="1">
<li><a target="_blank" rel="noopener" href="http://jm.taobao.org/2017/01/12/rocketmq-quick-start-in-10-minutes/">十分钟入门RocketMQ</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2017/05/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-CVR-%E8%BD%AC%E5%8C%96%E7%8E%87%E9%A2%84%E4%BC%B0%E8%B5%84%E6%96%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/05/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-CVR-%E8%BD%AC%E5%8C%96%E7%8E%87%E9%A2%84%E4%BC%B0%E8%B5%84%E6%96%99/" class="post-title-link" itemprop="url">转化率预估资料</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-05-16 13:36:42" itemprop="dateCreated datePublished" datetime="2017-05-16T13:36:42+08:00">2017-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:42:00" itemprop="dateModified" datetime="2018-12-17T15:42:00+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%85%BE%E8%AE%AF%E7%AE%97%E6%B3%95%E5%A4%A7%E8%B5%9B-CVR%E9%A2%84%E4%BC%B0/" itemprop="url" rel="index"><span itemprop="name">腾讯算法大赛-CVR预估</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol type="1">
<li><a target="_blank" rel="noopener" href="http://www.flickering.cn/category/ads/">火光摇曳</a></li>
<li><a target="_blank" rel="noopener" href="http://tech.meituan.com/tag/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0">美团点评技术团队</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2017/05/14/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%AF%94%E8%B5%9B-%E6%9D%8E%E5%81%A5%E8%83%9C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/05/14/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%AF%94%E8%B5%9B-%E6%9D%8E%E5%81%A5%E8%83%9C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" class="post-title-link" itemprop="url">阿里中间件初赛-李健胜解决方案</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-05-14 14:19:14" itemprop="dateCreated datePublished" datetime="2017-05-14T14:19:14+08:00">2017-05-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:42:07" itemprop="dateModified" datetime="2018-12-17T15:42:07+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%AF%94%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">中间件比赛</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="参考资料">参考资料</h1>
<ol type="1">
<li><a target="_blank" rel="noopener" href="http://blog.jesonlee.me/19/">李健胜，阿里中间件大赛初赛解题思路</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Jesonlee1997/open-message">1对应的代码</a></li>
</ol>
<h1 id="题目要求">题目要求</h1>
<p><strong>主角</strong>：消息中间件 <strong>目的</strong>：实现消息中间件的推拉模式。即生产者制造消息，使用消息队列储存消息，消费者从消息队列拉取消息。 <strong>要点</strong>：持久化的消息队列</p>
<h2 id="producer需要实现">Producer需要实现</h2>
<ul>
<li><p>创建一个消息，给消息指定Topic（可以由多个Consumer消费） <code>BytesMessage createBytesMessageToTopic(String topic, byte[] body);</code></p></li>
<li><p>创建一个消息，给消息指定Queue（只能由一个Consumer消费） <code>BytesMessage createBytesMessageToQueue(String queue, byte[] body);</code></p></li>
<li><p>发送消息，message中应当包含目的地（Queue，Topic只能选其一），对于发往同一个Topic和Queue的message顺序要保持一致。 <code>void send(Message message);</code></p></li>
</ul>
<h2 id="pullconsumer需要实现">PullConsumer需要实现</h2>
<ul>
<li>绑定到一个Queue，并订阅topics，即从这些topic和Queue读取消息。 <code>void attachQueue(String queueName, Collection topics);</code></li>
<li>规范要求实现阻塞的接口，由properties来设置阻塞时间，但本赛题不需要用到该特性， 请实现一个非阻塞(也即阻塞时间为0)调用, 也即没有消息则返回null <code>Message poll();</code></li>
</ul>
<h2 id="测试流程">测试流程</h2>
<ul>
<li>创建<code>Topic</code>，创建<code>Queue</code> 创建<code>Producer</code>，多个<code>Producer</code>创建指定<code>Topic</code>和指定<code>Queue</code>的Message，调用<code>send</code>方法发送</li>
<li>将数据保存到磁盘中</li>
<li><code>kill Producer</code>进程，另取进程进行消费 创建<code>PullConsumer</code>线程进行消费，一个<code>Consumer</code>对应一个线程，<code>Consumer</code>连接到一个<code>Queue</code>，可以订阅多个<code>Topic</code>。</li>
<li>不断的调用poll拉取队列的消息，直到完全读完，读取的消息要相对有序。</li>
</ul>
<p>补充： 一个<code>Producer</code>对应一个线程，线程先创建对应的Message，再将Message 发送到对应的队列或<code>topic</code>中，实际情况中会有多个<code>Producer</code>。 一个<code>Consumer</code>对应一个<code>Queue</code>，多个<code>Consumer</code>同时从队列中拉取消息。</p>
<h2 id="技术难点">技术难点</h2>
<ol type="1">
<li><p>大量的消息产生</p></li>
<li><p>并发写</p></li>
<li><p>并发读</p></li>
<li><p>序列化&amp;反序列化</p></li>
<li><p>大量消息 首先根据题目描述，Produce过程会运行5分钟，这个过程中多线程进行消息的发送，然后再考虑将消息持久化。我用自己的程序测试了一下，（不是典型值，只作为参考，在文章的最后我会贴上我的一系列测试结果），多线程发送一亿条消息的时间为27s，而这一亿条消息占据磁盘的大小为将近4G！可以想象在5分钟内会产生多少的消息量，如何将消息存储，如何读取消息都将成为一个非常棘手的问题。</p></li>
<li><p>并发写 并发写的问题也非常显而易见。我们一般情况下为了实现消息队列会选择使用一个List或数组来存储Producer产生的消息。这就引发了一个问题，怎样保证向同一个队列中发送消息的线程不产生竞争条件。</p></li>
<li><p>并发读 最麻烦的一个部分，每个线程都需要读取磁盘上的消息内容，每个线程读取的位置又不尽相同，消息数又那么多不可能全部加载到内存中，这个问题曾让我伤透了脑筋，直到我遇到了mmap(后面详细介绍)。</p></li>
<li><p>序列化和反序列化的问题 大赛刚开始时，我写了一个使用Java自身序列化来实现持久化的版本，这个版本的缺点非常显而易见，就是慢，而这个缺点又是极为致命的。我意识到我需要自己定制一个序列化协议来将消息转化为字节数组，再通过其他方式（如FileOutputStream）写入磁盘，同时再使用这个协议将其从磁盘中恢复。</p></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2017/05/13/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%AF%94%E8%B5%9B-OpenMessaging%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/05/13/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%AF%94%E8%B5%9B-OpenMessaging%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB1/" class="post-title-link" itemprop="url">OpenMessaging源码阅读1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-05-13 15:29:31" itemprop="dateCreated datePublished" datetime="2017-05-13T15:29:31+08:00">2017-05-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:42:07" itemprop="dateModified" datetime="2018-12-17T15:42:07+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%AF%94%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">中间件比赛</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>考虑到自己记性实在太差，还是好好记笔记吧。 本节主要看以下几个接口： - Meaasage - Producer - PullConsumer</p>
<h1 id="message.java">Message.java</h1>
<p>Message接口是所有OMS消息中的根接口。最常用的消息就是BytesMessage。</p>
<p><strong>标准Message</strong> 大多消息导向（message-oriented）的中间件（MOM）产品更趋向于将消息认做轻实体，这个轻实体包含一个header和一个body：</p>
<ul>
<li>header:包含用来路由和识别的信息域；</li>
<li>body:包含将会被发送的应用信息；</li>
</ul>
<p><strong>本Message</strong> 本消息是一个仅包含与具体消息对象相关的property(财产)的轻量级实体。主要包含以下几个方面：</p>
<ul>
<li>Header:所有消息都有同样的header域。header域的值用来给客户端(clients)和提供商（providers）唯一标示消息，以及路由消息。</li>
<li>Properties(财产，特性)：每个消息都有一个消息自有的部分，这部分用来提供“应用定义(application-defined)”的property(财产)值。这一部分为支持“应用定义”消息的过滤提供了很有效的机制。</li>
</ul>
<p><strong>源码解读</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">     <span class="comment">/*headers()返回Message对象的header域，返回值类型是keyValue。*/</span></span><br><span class="line">    <span class="function">KeyValue <span class="title">headers</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*properties()返回消息自有的property域。返回值类型是keyValue。*/</span></span><br><span class="line">    <span class="function">KeyValue <span class="title">properties</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/*putHeaders(String key, int value)将输入(String key, int value)全部传入header*/</span></span><br><span class="line">    <span class="comment">/*参数key:headers的关键字*/</span></span><br><span class="line">    <span class="comment">/*参数values:与key对应的值*/</span></span><br><span class="line">    <span class="function">Message <span class="title">putHeaders</span><span class="params">(String key, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line">    <span class="function">Message <span class="title">putHeaders</span><span class="params">(String key, <span class="keyword">long</span> value)</span></span>;</span><br><span class="line">    <span class="function">Message <span class="title">putHeaders</span><span class="params">(String key, <span class="keyword">double</span> value)</span></span>;</span><br><span class="line">    <span class="function">Message <span class="title">putHeaders</span><span class="params">(String key, String value)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*将key和value全部存入header*/</span></span><br><span class="line">    <span class="comment">/*参数key:headers的关键字*/</span></span><br><span class="line">    <span class="comment">/*参数values:与key对应的值*/</span></span><br><span class="line">    <span class="function">Message <span class="title">putProperties</span><span class="params">(String key, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line">    <span class="function">Message <span class="title">putProperties</span><span class="params">(String key, <span class="keyword">long</span> value)</span></span>;</span><br><span class="line">    <span class="function">Message <span class="title">putProperties</span><span class="params">(String key, <span class="keyword">double</span> value)</span></span>;</span><br><span class="line">    <span class="function">Message <span class="title">putProperties</span><span class="params">(String key, String value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="producer.java">Producer.java</h1>
<p>Producer是一个用来发送消息的简单对象，它是<code>MessagingAccessPoint</code>的一个具体实现。 <strong>创建Producer对象</strong>： <code>Producer</code>的具体实例是通过<code>MessagingAccessPoint#createProducer()</code>方法创建的。 这个方法提供了多种定点发送消息的方式，其中，目的地可以是<code>MessageHeader#TOPIC</code>或<code>MessageHeader#QUEUE</code>。</p>
<p><strong>Producer#send(Message)</strong> 同步定点发送消息方法。 当发送请求完成时，线程将会关闭(block)。</p>
<p><strong>Producer#sendAsync(Message)</strong> 异步定点发送消息方法。 当发送请求完成时，线程不会很快关闭，而会立即返回一个<code>Promise</code>作为发送结果。</p>
<p><strong>Producer#sendOneway(Message)</strong> one way定点发送消息方法。 当发送请求完成时，线程不会很快关闭，而是立即返回。线程发起者不关心发送结果，同时server也对返回值没有责任。</p>
<p><strong>源码解读</strong></p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">MessageFactory</span>, <span class="title">ServiceLifecycle</span> </span>&#123;</span><br><span class="line">     <span class="comment">/*返回本实例的properties*/</span></span><br><span class="line">     <span class="comment">/*返回值的变化不会反应在Producer本身上，并且这个变化可以用ResourceManager#setProducerProperties(String, KeyValue)来修改。（Changes to the return &#123;@code KeyValue&#125; are not reflected in physical &#123;@code Producer&#125;,and use &#123;@link ResourceManager#setProducerProperties(String, KeyValue)&#125; to modify.）*/</span></span><br><span class="line">    <span class="function">KeyValue <span class="title">properties</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*同步定点发送message方法*/</span></span><br><span class="line">    <span class="comment">/*发送目的地应该预置在MessageHeader中。当然其它类型的header域也可以*/</span></span><br><span class="line">    <span class="comment">/*异常OMSRuntimeException：当由于内部原因发送失败时*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(Message message)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(Message message, KeyValue properties)</span></span>;<span class="comment">/*properties是属性值*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*异步定点发送消息方法*/</span></span><br><span class="line">    <span class="comment">/*返回值是Promise类型。同时，登记过的PromiseListener将会被通知*/</span></span><br><span class="line">    <span class="function">Promise&lt;Void&gt; <span class="title">sendAsync</span><span class="params">(Message message)</span></span>;</span><br><span class="line">    <span class="function">Promise&lt;Void&gt; <span class="title">sendAsync</span><span class="params">(Message message, KeyValue properties)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*oneway定点发送消息方法*/</span></span><br><span class="line">    <span class="comment">/*无返回值，也没有thrown。因为oneway发送不在乎发送结果*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendOneway</span><span class="params">(Message message)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendOneway</span><span class="params">(Message message, KeyValue properties)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">BatchToPartition <span class="title">createBatchToPartition</span><span class="params">(String partitionName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">BatchToPartition <span class="title">createBatchToPartition</span><span class="params">(String partitionName, KeyValue properties)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<h1 id="pullconsumer.java">PullConsumer.java</h1>
<p><code>PullConsumer</code>对象能从特定的队列中poll消息。而且支持通过‘ack’方式提交消费结果。</p>
<p><strong>源码分析</strong></p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PullConsumer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*返回本PullConsumer实例的properties*/</span></span><br><span class="line">    <span class="comment">/* Changes to the return &#123;@code KeyValue&#125; are not reflected in physical &#123;@code PullConsumer&#125;,and use &#123;@link ResourceManager#setConsumerProperties(String, KeyValue)&#125; to modify.*/</span></span><br><span class="line">    <span class="function">KeyValue <span class="title">properties</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 规范要求实现阻塞的接口，由properties来设置阻塞时间，但本赛题不需要用到该特性，请实现一个非阻塞(也即阻塞时间为0)调用, 也即没有消息则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*抽取下一条为本pullconsumer生产的消息*/</span></span><br><span class="line">    <span class="comment">/*除非一条消息被产生了，或者本pullConsumer被关闭了，本调用会一直block*/</span></span><br><span class="line">    <span class="comment">/*返回为本PullConsumer生产的下一条消息；当本PullConsumer被同时关闭时返回null*/</span></span><br><span class="line">    <span class="comment">/*当本PullConsumer由于一些内部原因而抽取下一条消息失败时，throw OMSRuntimeException*/</span></span><br><span class="line">    <span class="function">Message <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Message <span class="title">poll</span><span class="params">(<span class="keyword">final</span> KeyValue properties)</span></span>;<span class="comment">/*properties是一些参数*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*用消息id回确认指定的已消费的消息*/</span></span><br><span class="line">    <span class="comment">/*若某消息已被接收，但还未被回确认，那它可能会被重新投递*/</span></span><br><span class="line">    <span class="comment">/*有OMSRuntimeException*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ack</span><span class="params">(String messageId)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ack</span><span class="params">(String messageId, <span class="keyword">final</span> KeyValue properties)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 绑定到一个Queue，并订阅topics，即从这些topic读取消息*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">attachQueue</span><span class="params">(String queueName, Collection&lt;String&gt; topics)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2017/05/12/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/05/12/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">多线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-05-12 13:51:34" itemprop="dateCreated datePublished" datetime="2017-05-12T13:51:34+08:00">2017-05-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:41:59" itemprop="dateModified" datetime="2018-12-17T15:41:59+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>线程(thread)</strong>：每个任务称为一个线程 <strong>线程和进程区别</strong>： 1. 每个进程有自己独立的变量，而线程则共享数据。 2. 线程是进程的执行单元 3. 线程是进程的组成部分。一个进程可以有多个线程，一个线程必须有一个父进程。 4. 线程可以拥有自己的堆栈、自己的程序计数器和自己的局部变量，但不拥有系统资源（与父进程其它线程共享该进程则资源）</p>
<h1 id="线程的创建">线程的创建</h1>
<p>有以下两种方法： 1. 通过继承Thread来创建线程 2. 通过实现Runnable接口创建线程</p>
<h2 id="通过继承thread来创建线程">通过继承Thread来创建线程</h2>
<p>要点：通过继承<code>Thread</code>类创建并启动多线程 步骤：</p>
<ol type="1">
<li><p>定义Thread类的子类，并重写<code>run()</code>方法（线程执行体）</p></li>
<li><p>创建<code>Thread</code>子类的实例(创建线程对象)</p></li>
<li><p>调用<code>start()</code>（启用该线程）</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;run\t&quot;</span>+getName()+<span class="string">&quot;\t&quot;</span>);<span class="comment">//getName()返回thread name</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> FirstThread().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p>以上代码输出：</p>
<pre><code>run  Thread-0</code></pre>
<p><strong>一个有意思的现象</strong></p>
<p>运行如下代码时：</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;run\t&quot;</span>+getName()+<span class="string">&quot;\t&quot;</span>);<span class="comment">//getName()返回thread name</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//调用currentThread()获取当前线程</span></span><br><span class="line">        System.out.println(<span class="string">&quot;currentThread : &quot;</span>+Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">new</span> FirstThread().start();</span><br><span class="line">        System.out.println(<span class="string">&quot;currentThread : &quot;</span>+Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">new</span> FirstThread().start();</span><br><span class="line">        System.out.println(<span class="string">&quot;currentThread : &quot;</span>+Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<p>按照以前的理解，应该是：</p>
<pre><code>currentThread : main
run Thread-0 
currentThread : main 
run Thread-1    
currentThread : main</code></pre>
<p>实际输出：（也有可能是其它顺序）</p>
<pre><code>currentThread : main
currentThread : main
run Thread-0    
run Thread-1    
currentThread : main</code></pre>
<p>新发现：其实<code>start</code>一个线程的时候，<code>main</code>线程在继续运行。<code>main</code>线程不会等<code>start</code>完事儿之后再运行下一句！</p>
<h2 id="通过实现runnable接口创建线程">通过实现Runnable接口创建线程</h2>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;run\t&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>);<span class="comment">//getName()返回thread name</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SecondThread st = <span class="keyword">new</span> SecondThread();</span><br><span class="line">        <span class="keyword">new</span> Thread(st,<span class="string">&quot;new_thread_1&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<p>区别： 需要通过<code>Thread.currentThread().getName()</code>来获取getName() main不同</p>
<p><strong>多线程共享变量</strong></p>
<p>以下是一个多线程共享变量<code>i</code>的情况：</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;<span class="number">5</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;run\t&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+i);<span class="comment">//getName()返回thread name</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SecondThread st = <span class="keyword">new</span> SecondThread();</span><br><span class="line">        <span class="keyword">new</span> Thread(st,<span class="string">&quot;thread_name_1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(st,<span class="string">&quot;thread_name_2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<p>两次运行结果：</p>
<pre><code>run thread_name_1    0
run thread_name_1    1
run thread_name_1    2
run thread_name_1    3
run thread_name_2    3
run thread_name_1    4

run thread_name_1    0
run thread_name_2    0
run thread_name_1    1
run thread_name_2    2
run thread_name_1    3
run thread_name_2    4</code></pre>
<p><strong>发现</strong>：</p>
<ol type="1">
<li>两个线程共有变量<code>i</code></li>
<li>线程间抢占资源</li>
</ol>
<h2 id="使用callable和future创建线程">使用<code>Callable</code>和<code>Future</code>创建线程</h2>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2017/05/11/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%AF%94%E8%B5%9B-OpenMessaging%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/05/11/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%AF%94%E8%B5%9B-OpenMessaging%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">OpenMessaging简介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-05-11 22:58:55" itemprop="dateCreated datePublished" datetime="2017-05-11T22:58:55+08:00">2017-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:42:07" itemprop="dateModified" datetime="2018-12-17T15:42:07+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%AF%94%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">中间件比赛</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>OpenMessaging的主要关系如下图所示：</p>
<p><img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-05-12-16-24-52.png" /></p>
<p>其中，各部分的内容和关系见下述。</p>
<h1 id="namespace">Namespace</h1>
<p>Namespace就像一个cgroup namespace,是用来创建一个有安全保障的独立的空间。每个namespace都有自己的producer,consumer,topic,queue等等。OpenMessaging用 ​<strong>MessagingAccessPoint</strong>​（消息访问点）来访问/读/写指定namespace的<strong>​资源</strong>​。</p>
<h1 id="producer">Producer</h1>
<p>Openmessaging定义了两种Producer:<strong>​Producer</strong>​和 <strong>​SequenceProducer</strong>​</p>
<ul>
<li><strong>​Producer</strong>​:提供各种send方法，用来将一个消息送往指定的destination,<strong>Topic</strong>或者<strong>Queue</strong>。支持三种方式：同步、异步、单向(oneway)</li>
<li><strong>SequenceProducer</strong>:重点在于速度，且支持批处理。能发送多个数据并一次提交。</li>
</ul>
<h1 id="consumer">Consumer</h1>
<p>Openmessaging定义了两种Consumer::<strong>PullConsumer</strong>、<strong>PushConsumer</strong>和<strong>StreamConsumer</strong>.每种Consumer仅支持来自于<strong>Queue</strong>的consume消息。</p>
<ul>
<li><strong>PullConsumer</strong>:从指定队列中pulls消息。支持“submit the consume result by acknowledgement at any time”。每个PullConsumer仅能从固定的队列中pull消息。</li>
<li><strong>PushConsumer</strong>:可从多个队列中接收消息，且这个消息是由MOM server push上去的。PushConsumer可依附于多个独立的、具有不同的MessageListener的队列，并且可以随时通过<strong>ReceivedMessageContext</strong>提交结果。</li>
<li><strong>StreamingConsumer</strong>:一种崭新的consumer类型，是一种面向流的consumer,面向留信息的一体化信息系统。</li>
</ul>
<h1 id="topic-queue-and-routing">Topic Queue and Routing</h1>
<p>这三个概念非常相近。虽然Topic和Queue有不同的用途，但它们总让人迷惑。</p>
<h2 id="topic">Topic</h2>
<p>Topic是原始信息的载体，用来holding消息。消息的分发方式和有序性是没有定义的。</p>
<h2 id="routing">Routing</h2>
<p>Topic中的消息是原始的，是待处理的，一般不易引起consumers的注意。总之，Topic中的数据是producer-orented（导向）的，而不是consumer-oriented。</p>
<p>因此Routing负责加工Topic中的原始消息，并routing去Queue中。每个Routing有一个<strong>操作管线（operator pipeline）</strong>，包含着一系列的操作。消息会通过操作管线从Topic流向Queue。</p>
<p><strong>操作（operator）</strong>是用来处理在Routing流通的消息的。有很多操作，例如expression operator, deduplicator operator, joiner operator, filter operator, rpc operator等等。</p>
<h2 id="queue队列">Queue(队列)</h2>
<p>现在消息已经被routed到Queue中了。现在消息就可以被consumers使用了。</p>
<p>需要注意的是，一个Queue可能会被分为几部分，消息可能通过MessageHeader#SHARDING_KEY被routed到某个特殊的部分中。</p>
<h2 id="topic与queue比较">Topic与Queue比较</h2>
<ul>
<li>都是消息的载体</li>
<li>Topic是preducer-oriented的，而Queue是consumer-oriented的</li>
<li>Topic中的消息来自于Producer,而Queue中的消息来自于Topic或者Producer</li>
<li>Queue包含几个部分，而Topic形状未定义</li>
<li>在大多数情况下，Queue是Topic的一个子集</li>
<li>Queue的创建、销毁都很容易，且与producer无关</li>
</ul>
<h1 id="参考文献">参考文献</h1>
<ol type="1">
<li><a href="openmessaging.github.io">原始文档</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/pugwoo/c/blob/master/linux_ipc/shm/shmqueue.h">pugwoo用c写的</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/openmessaging/openmessaging">原始文档扒的API</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2017/05/11/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%AF%94%E8%B5%9B-%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/05/11/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%AF%94%E8%B5%9B-%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">中间件入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-05-11 16:52:49" itemprop="dateCreated datePublished" datetime="2017-05-11T16:52:49+08:00">2017-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:42:07" itemprop="dateModified" datetime="2018-12-17T15:42:07+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%AF%94%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">中间件比赛</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="中间件概念">中间件概念</h1>
<p><strong>中间件</strong>：处于操作系统和应用程序之间的软件。</p>
<p>中间件简单解释，可以理解为面向信息系统交互，集成过程中的通用部分的集合，屏蔽了底层的通讯，交互，连接等复杂又通用化的功能，以产品的形式提供出来，系统在交互时，直接采用中间件进行连接和交互即可，避免了大量的代码开发和人工成本。</p>
<p>其实，理论上来讲，中间件所提供的功能通过代码编写都可以实现，只不过开发的周期和需要考虑的问题太多，逐渐的，这些部分，以中间件产品的形式进行了替代。</p>
<p>比如常见的消息中间件，即系统之间的通讯与交互的专用通道，类似于邮局，系统只需要把传输的消息交给中间件，由中间件负责传递，并保证传输过程中的各类问题，如网络问题，协议问题，两端的开发接口问题等均由消息中间件屏蔽了，出现了网络故障时，消息中间件会负责缓存消息，以避免信息丢失。相当于你想给美国发一个邮包，只需要把邮包交给邮局，填写地址和收件人，至于运送过程中的一系列问题你都不需要关心了。</p>
<h1 id="中间件分类">中间件分类</h1>
<ol type="1">
<li>消息中间件（MOM：Message-Oriented Middleware）</li>
<li>数据中间件（Database Middleware）</li>
<li>远程过程调用中间件（RPC：Remote Process Call）</li>
<li>对象请求代理中间件（ORB：Object Request Broker）</li>
<li>事务处理中间件（TP Monitor：Transaction Process Monitor）</li>
<li>J2EE中间件</li>
</ol>
<h1 id="open-messaging">Open-Messaging</h1>
<p>是一个建立行业内的指引和消息的协议（charter）。它的streaming规范提供了一个可用于电子商务、物联网和大数据的基础框架。它的主要目标是建立一个在分布式异构环境中面向云、简单、灵活和独立于语言的环境。协议的一致性似的它可以跨平台开发异构消息应用程序。</p>
<p><strong>域结构</strong> <img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-05-11-17-16-52.png" /></p>
<h1 id="消息中间件-message-queue">消息中间件 Message Queue</h1>
<p>Message Queue是一种应用程序对应用程序的通信方法。程序之间通过在消息中发送数据进行通信，而不是通过直接调用彼此来通信，直接调用通常是用于诸如远程过程调用的技术。排队指的是应用程序通过队列来通信。队列的使用除去了接收和发送应用程序同时执行的要求。</p>
<p>提及消息中间件的时候，还会涉及生产者和消费者两个概念。消息中间件是负责接收来自生产者的消息，并存储并转发给对应的消费者，生产者可以按 topic 发布各样消息，消费者也可以按 topic 订阅各样消息。生产者只管往消息队列里推送消息，不用等待消费者的回应；消费者只管从消息队列中取出数据并处理，可用可靠性等问题都交由消息中间件来负责。 <img src="http://jiayi797.oss-cn-beijing.aliyuncs.com/2017-05-12-15-43-09.png" /> 生产者和消费者通常有两种对应关系，一个生产者对应一个消费者，以及一个生产者对应多个消费者。</p>
<h1 id="参考文献">参考文献</h1>
<p>1.<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19730582/answer/16390709">知乎FireJones的回答</a> 2.<a target="_blank" rel="noopener" href="http://wiki.jikexueyuan.com/project/redis/middleware.html">极客学院，消息中间件</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiayi797.github.io/about/2017/05/04/Python-os%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content=".">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="甲乙小朋友的房子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/05/04/Python-os%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">python——os模块</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-05-04 16:06:29" itemprop="dateCreated datePublished" datetime="2017-05-04T16:06:29+08:00">2017-05-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-17 15:42:00" itemprop="dateModified" datetime="2018-12-17T15:42:00+08:00">2018-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="os模块">os模块</h1>
<p>os模块的作用：</p>
<p>　　os，语义为操作系统，所以肯定就是操作系统相关的功能了，可以处理文件和目录这些我们日常手动需要做的操作，就比如说：显示当前目录下所有文件/删除某个文件/获取文件大小……</p>
<p>　　另外，os模块不受平台限制，也就是说：当我们要在linux中显示当前命令时就要用到pwd命令，而Windows中cmd命令行下就要用到这个，额...我擦，我还真不知道，（甭管怎么着，肯定不是pwd），这时候我们使用python中os模块的os.path.abspath(name)功能，甭管是linux或者Windows都可以获取当前的绝对路径。</p>
<h1 id="文件夹操作">文件夹操作</h1>
<h2 id="检验文件夹是否存在">检验文件夹是否存在</h2>
<pre><code>os.path.exists(directory)</code></pre>
<h2 id="创建文件夹">创建文件夹</h2>
<pre><code>os.makedirs(directory)</code></pre>
<p>实例： 检验文件夹是否存在，若不存在，则创建之</p>
<pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_dir</span>(<span class="params">directory</span>):</span></span><br><span class="line">    flag=os.path.exists(directory)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">        os.makedirs(directory)</span><br></pre></td></tr></table></figure></code></pre>
<h2 id="遍历指定目录名显示目录下所有文件">遍历指定目录名，显示目录下所有文件</h2>
<pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pathDir =  os.listdir(filepath)</span><br><span class="line">    <span class="keyword">for</span> allDir <span class="keyword">in</span> pathDir:</span><br><span class="line">        <span class="built_in">print</span> allDir</span><br></pre></td></tr></table></figure></code></pre>
<h1 id="参考文献">参考文献</h1>
<ol type="1">
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/MnCu8261/p/5483657.html">python基础之模块之os模块</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">jiayi797</p>
  <div class="site-description" itemprop="description">.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">150</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jiayi797</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
    <span class="post-count">| 博客共334.5k字</span>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
